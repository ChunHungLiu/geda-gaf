@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File x_multiattrib.c,,,Top
@chapter File @file{x_multiattrib.c}

@section File header

<<x_multiattrib.c : *>>=
<<x_multiattrib.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/x_dialog.nw instead */

/* STILL NEED to clean up line lengths in aa and tr */

<<x_multiattrib.c : include directives>>

/***************** Start of Multiple Attrib Edit dialog box ***********/
<<x_multiattrib.c : multi_attrib_edit_keypress()>>
<<x_multiattrib.c : multi_attrib_edit_parser()>>
<<x_multiattrib.c : multi_attrib_edit_set_values()>>
<<x_multiattrib.c : multi_attrib_edit_clear()>>
<<x_multiattrib.c : multi_attrib_edit_select_row()>>
<<x_multiattrib.c : multi_attrib_edit_add()>>
<<x_multiattrib.c : multi_attrib_edit_change()>>
<<x_multiattrib.c : multi_attrib_edit_delete()>>
<<x_multiattrib.c : multi_attrib_edit_close()>>
<<x_multiattrib.c : multi_attrib_edit()>>
/***************** End of Multiple Attrib Edit dialog box *************/

@


<<x_multiattrib.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<x_multiattrib.c : include directives>>=
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/i_vars.h"
#include "../include/x_states.h"
#include "../include/globals.h"
#include "../include/prototype.h"

@

@section Function @code{multi_attrib_edit_keypress()}

@defun multi_attrib_edit_keypress w w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_keypress()>>=
void
multi_attrib_edit_keypress(GtkWidget * widget, GdkEventKey * event, 
	              TOPLEVEL * w_current)
{
   if (strcmp(gdk_keyval_name(event->keyval), "Escape") == 0) {
	multi_attrib_edit_close(NULL, w_current);	
   }
}
@ %def multi_attrib_edit_keypress


@section Function @code{multi_attrib_edit_parser()}

@defun multi_attrib_edit_parser w text vis show
@end defun

<<x_multiattrib.c : multi_attrib_edit_parser()>>=
char*
multi_attrib_edit_parser (GtkWidget *w,
                          char **text, int *vis, int *show)
{
  GtkWidget *window;
  GtkWidget *label;
  GtkWidget *value;

  GtkWidget *visbutton;
  GtkWidget *showvalbutton;
  GtkWidget *shownamebutton;

  char *newtext;
	
  text[1]=malloc(4*sizeof(char)); /* this needs to be freed somewhere? */
	
  window = gtk_object_get_data(GTK_OBJECT(w),"window");
  label = gtk_object_get_data(GTK_OBJECT(window),"lab_entry");
  value = gtk_object_get_data(GTK_OBJECT(window),"val_entry");

  visbutton = gtk_object_get_data(GTK_OBJECT(window),"visbutton");
  showvalbutton = gtk_object_get_data(GTK_OBJECT(window),"showvalbutton");
  shownamebutton = gtk_object_get_data(GTK_OBJECT(window),"shownamebutton");

  text[0]=gtk_entry_get_text(GTK_ENTRY(label));
  text[2]=gtk_entry_get_text(GTK_ENTRY(value));

  text[1][1]=' ';
  text[1][3]=0;

  newtext = u_basic_strdup_multiple(text[0],"=",text[2],NULL);

  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(visbutton)))
  {
    *vis = VISIBLE;
    text[1][0]='V';
  }
  else
  {
    *vis = INVISIBLE;
    text[1][0]='I';
  }
  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(showvalbutton)))
  {
    *show = SHOW_VALUE;
    text[1][2]='V';
  }
  else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(shownamebutton)))
  {
    *show = SHOW_NAME;
    text[1][2]='N';
  }
  else
  {
    *show = SHOW_NAME_VALUE;
    text[1][2]='B';
  }
  return newtext;
}

@ %def multi_attrib_edit_parser


@section Function @code{multi_attrib_edit_set_values()}

@defun multi_attrib_edit_set_values window attrib
@end defun

<<x_multiattrib.c : multi_attrib_edit_set_values()>>=
void
multi_attrib_edit_set_values (GtkWindow *window, OBJECT *attrib)
{
  GtkWidget *lab_entry;
  GtkWidget *val_entry;
  GtkWidget *showvalbutton;
  GtkWidget *shownamebutton;
  GtkWidget *showbothbutton;
  GtkWidget *visbutton;

  char name[1000];
  char value[1000];

  lab_entry = gtk_object_get_data(GTK_OBJECT(window),"lab_entry");
  val_entry = gtk_object_get_data(GTK_OBJECT(window),"val_entry");

  visbutton = gtk_object_get_data(GTK_OBJECT(window),"visbutton");

  showbothbutton = gtk_object_get_data(GTK_OBJECT(window),"showbothbutton");
  shownamebutton = gtk_object_get_data(GTK_OBJECT(window),"shownamebutton");
  showvalbutton = gtk_object_get_data(GTK_OBJECT(window),"showvalbutton");

  if(!attrib)
  {
    gtk_entry_set_text(GTK_ENTRY(lab_entry),"");
    gtk_entry_set_text(GTK_ENTRY(val_entry),"");
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(visbutton),TRUE);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(showvalbutton),TRUE);
  }
  else
  {
    if(attrib->visibility == VISIBLE)
    gtk_toggle_button_set_active 
    (GTK_TOGGLE_BUTTON (visbutton), TRUE);
    else
    gtk_toggle_button_set_active
    (GTK_TOGGLE_BUTTON (visbutton), FALSE);
	
    if(attrib->show_name_value == SHOW_NAME)
    gtk_toggle_button_set_active 
    (GTK_TOGGLE_BUTTON(shownamebutton),TRUE);
    else if(attrib->show_name_value == SHOW_VALUE)
    gtk_toggle_button_set_active 
    (GTK_TOGGLE_BUTTON(showvalbutton),TRUE);
    else gtk_toggle_button_set_active 
    (GTK_TOGGLE_BUTTON(showbothbutton),TRUE);

    o_attrib_get_name_value(attrib->text->string,name,value);
    gtk_entry_set_text (GTK_ENTRY (val_entry), value);
    gtk_entry_set_text (GTK_ENTRY (lab_entry), name);
    gtk_widget_grab_focus(val_entry);
  }
}


@ %def multi_attrib_edit_set_values


@section Function @code{multi_attrib_edit_clear()}

@defun multi_attrib_edit_clear w window
@end defun

<<x_multiattrib.c : multi_attrib_edit_clear()>>=
void
multi_attrib_edit_clear (GtkWidget *w, GtkWindow *window)
{
  multi_attrib_edit_set_values(window,NULL);
}


@ %def multi_attrib_edit_clear


@section Function @code{multi_attrib_edit_select_row()}

@defun multi_attrib_edit_select_row clist row col event w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_select_row()>>=
void
multi_attrib_edit_select_row (GtkCList *clist, gint row, gint col,
				GdkEventButton *event, TOPLEVEL *w_current)
{
  GtkWidget *window;
  OBJECT *attrib;

  window = w_current->mawindow;
  clist = gtk_object_get_data(GTK_OBJECT(window),"clist");

  gtk_object_set_data(GTK_OBJECT(clist),"selected",(gpointer)row);
  attrib = gtk_clist_get_row_data(clist,row);
  multi_attrib_edit_set_values (GTK_WINDOW(window), attrib);
}


@ %def multi_attrib_edit_select_row


@section Function @code{multi_attrib_edit_add()}

@defun multi_attrib_edit_add w w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_add()>>=
void
multi_attrib_edit_add (GtkWidget *w, TOPLEVEL *w_current)
{
  int vis,show;
  char *newtext;
  gint row;
  OBJECT *attrib;
  OBJECT *object;
  char **text;
  GtkWidget *clist;
  char tmpstr[20];

  clist = gtk_object_get_data(GTK_OBJECT(w_current->mawindow),"clist");

  text=malloc(3*sizeof(char*));

  newtext = multi_attrib_edit_parser (w,text,&vis,&show);

  if(text[0][0] == '\0' || text[0][0] == ' ')
  return;

			
  row = gtk_clist_append(GTK_CLIST(clist),text);

  object = o_select_return_first_object(w_current); 
  attrib = o_attrib_add_attrib(w_current, newtext, vis, show, object);

  /* handle slot= attribute, it's a special case */
  if ( (!strcmp(text[0],"slot")) & (strlen(text[2])<3) ) {
    sprintf (tmpstr,"%s=%i",text[0],atoi(text[2]));
    o_slot_end(w_current,tmpstr,strlen(tmpstr));
  }

  w_current->page_current->CHANGED=1;
  o_undo_savestate(w_current, UNDO_ALL);

  if (attrib != NULL) {
    gtk_clist_set_row_data(GTK_CLIST(clist),row,attrib);
    multi_attrib_edit_clear(NULL,GTK_WINDOW(w_current->mawindow));
  }

  free(newtext);
  free(text);
}


@ %def multi_attrib_edit_add


@section Function @code{multi_attrib_edit_change()}

@defun multi_attrib_edit_change w w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_change()>>=
void
multi_attrib_edit_change (GtkWidget *w, TOPLEVEL *w_current)
{
  int vis,show;
  char *newtext;
  gint row;
  OBJECT *attrib;
  char **text;
  GtkWidget *clist;
  char tmpstr[20];

  clist = gtk_object_get_data(GTK_OBJECT(w_current->mawindow),"clist");

  text=malloc(3*sizeof(char*));
  newtext = multi_attrib_edit_parser (w,text,&vis,&show);

  if(text[0][0] != '\0' && text[0][0] != ' ')
  {
    row = (int)gtk_object_get_data(GTK_OBJECT(clist),"selected");
    if(row != -1)
    {
      attrib = gtk_clist_get_row_data(GTK_CLIST(clist),row);
      o_text_change(w_current,attrib,newtext,vis,show);
      o_undo_savestate(w_current, UNDO_ALL);
      /*			multi_attrib_edit_clear(NULL,GTK_WINDOW(w_current->mawindow));*/
      gtk_clist_set_text(GTK_CLIST(clist),row,0,text[0]);
      gtk_clist_set_text(GTK_CLIST(clist),row,1,text[1]);
      gtk_clist_set_text(GTK_CLIST(clist),row,2,text[2]);
    }
  }
	
  if ( (!strcmp(text[0],"slot")) & (strlen(text[2])<3) )
  {
    sprintf (tmpstr,"%s=%i",text[0],atoi(text[2]));
    o_slot_end(w_current,tmpstr,strlen(tmpstr));
  }

  free(newtext);
  free(text);

  if (gtk_object_get_data(GTK_OBJECT(w), "close")) {
    multi_attrib_edit_close (w,w_current);
  }
}


@ %def multi_attrib_edit_change


@section Function @code{multi_attrib_edit_delete()}

@defun multi_attrib_edit_delete w w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_delete()>>=
void
multi_attrib_edit_delete (GtkWidget *w, TOPLEVEL *w_current)
{
  OBJECT *attrib;
  GtkCList *clist;
  gint selected;
	
  clist = gtk_object_get_data(GTK_OBJECT(w_current->mawindow),"clist");

  selected = (gint)gtk_object_get_data(GTK_OBJECT(clist),"selected");
  if(selected == -1)
  return;
  attrib = gtk_clist_get_row_data(clist,selected);
  gtk_clist_remove(clist,selected);
  gtk_object_set_data(GTK_OBJECT(clist),"selected",(gpointer)-1);
	
  o_selection_remove(w_current->page_current->selection2_head, attrib);
  o_delete_text(w_current,attrib);
  w_current->page_current->CHANGED=1;
  o_undo_savestate(w_current, UNDO_ALL);

	
  multi_attrib_edit_clear (NULL,GTK_WINDOW(w_current->mawindow));
  /* Tell System about change! */

}


@ %def multi_attrib_edit_delete


@section Function @code{multi_attrib_edit_close()}

@defun multi_attrib_edit_close w w_current
@end defun

<<x_multiattrib.c : multi_attrib_edit_close()>>=
void
multi_attrib_edit_close (GtkWidget *w, TOPLEVEL *w_current)
{
  w_current->event_state = SELECT;
  i_update_status(w_current, _("Select Mode"));
  i_update_toolbar(w_current);
  gtk_grab_remove(w_current->mawindow);
  gtk_widget_destroy(w_current->mawindow);
  w_current->mawindow = NULL;
}


@ %def multi_attrib_edit_close


@section Function @code{multi_attrib_edit()}

@defun multi_attrib_edit w_current list
@end defun

<<x_multiattrib.c : multi_attrib_edit()>>=
void
multi_attrib_edit (TOPLEVEL *w_current, SELECTION *list)
{

  char *text[3];
  char *string;
  int i;
  int row;
  OBJECT **attriblist=NULL;
  OBJECT *object=NULL;

  GtkWidget *window;
  GtkWidget *table;
  GtkWidget *vbox;
  GtkWidget *hbox2;
  GtkWidget *hbox4;
  GtkWidget *hbox5;
  GtkWidget *hbox6;
  GtkWidget *scrolledwindow1;
  GtkWidget *clist;
  GtkWidget *attribhead;
  GtkWidget *vishead;
  GtkWidget *valhead;

  GtkWidget *label10;
  GtkWidget *label11;

  GtkWidget *combo2;
  GList *combo2_items = NULL;
  GtkWidget *lab_entry;
  GtkWidget *visbutton;
  GtkWidget *val_entry;
  GSList *show_group = NULL;
  GtkWidget *namebutton;
  GtkWidget *valbutton;
  GtkWidget *bothbutton;

  GtkWidget *hbuttonbox1;
  GtkWidget *addbutton;
  GtkWidget *changebutton;
  GtkWidget *clearbutton;
  GtkWidget *delbutton;
  GtkWidget *closebutton;

  /* no longer used?*/
  /* gchar *titles[]= {"Attribute","Visibility","Value"}; */


  /* Do basic checks first */	
  if(!w_current) return;
  if(!w_current->page_current) return;
  if(!w_current->page_current->object_head) return;
  object = list->selected_object;
  if (!object) return;
	
  attriblist=o_attrib_return_attribs(w_current->page_current->object_head,
                                     object);	
  text[0] = malloc(sizeof(char)*512);
  text[1] = malloc(sizeof(char)*5);
  text[2] = malloc(sizeof(char)*512);
  text[1][1]=' ';
  text[1][3]='\0';

#if 0 /* this method cannot be used since it prevents this dialog box to be */
  /* opened if nothing is selected; the check needs to happen further */
  /* down */
  /* Make sure attriblist isn't NULL */
  if (attriblist == NULL) {
    free(text[0]);
    free(text[1]);
    free(text[2]);
    return;
  }
#endif
	
  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window), _("Edit Component"));
  gtk_widget_set_usize(window, 545, 200);
  
  gtk_window_position(GTK_WINDOW (window), GTK_WIN_POS_MOUSE);

  vbox = gtk_vbox_new (FALSE, 0);
  gtk_widget_show (vbox);
  gtk_container_add (GTK_CONTAINER (window), vbox);
	
  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
  gtk_widget_show (scrolledwindow1);
  gtk_box_pack_start (GTK_BOX (vbox), scrolledwindow1, TRUE, TRUE, 0);
  gtk_container_set_border_width (GTK_CONTAINER (scrolledwindow1), 3);
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow1),
                                  GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	
  clist = gtk_clist_new (3);
  gtk_object_set_data(GTK_OBJECT(window),"clist",clist);
  gtk_widget_show (clist);
  gtk_container_add (GTK_CONTAINER (scrolledwindow1), clist);
  gtk_clist_set_column_width (GTK_CLIST (clist), 0, 80);
  gtk_clist_set_column_width (GTK_CLIST (clist), 1, 80);
  gtk_clist_set_column_width (GTK_CLIST (clist), 2, 80);

  gtk_clist_column_titles_show (GTK_CLIST (clist));

  attribhead = gtk_label_new (_("Attribute"));
  gtk_widget_show (attribhead);
  gtk_clist_set_column_widget (GTK_CLIST (clist), 0, attribhead);
	
  vishead = gtk_label_new (_("Visibility"));
  gtk_widget_show (vishead);
  gtk_clist_set_column_widget (GTK_CLIST (clist), 1, vishead);
	
  valhead = gtk_label_new (_("Value"));
  gtk_widget_show (valhead);
  gtk_clist_set_column_widget (GTK_CLIST (clist), 2, valhead);
	
  table = gtk_table_new (2,2, FALSE);
  gtk_widget_show (table);
  gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, TRUE, 0);

  gtk_object_set_data(GTK_OBJECT(clist),"selected",(gpointer)-1);

  hbox2 = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (hbox2);

  gtk_table_attach (GTK_TABLE (table), hbox2,0,1,0,1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);

  gtk_container_set_border_width (GTK_CONTAINER (hbox2), 3);


  label10 = gtk_label_new (_("Attribute"));
  gtk_widget_show (label10);
  gtk_box_pack_start (GTK_BOX (hbox2), label10, TRUE, TRUE, 0);
	
  combo2 = gtk_combo_new ();
  gtk_widget_show (combo2);
  gtk_box_pack_start (GTK_BOX (hbox2), combo2, TRUE, TRUE, 0);
	
  lab_entry = GTK_COMBO (combo2)->entry;
  gtk_widget_show (lab_entry);
  gtk_object_set_data(GTK_OBJECT(window),"lab_entry",lab_entry);
	
  hbox5 = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (hbox5);
	
  visbutton = gtk_check_button_new_with_label (_("Visible"));
  gtk_object_set_data (GTK_OBJECT (window), "visbutton", visbutton);
  gtk_widget_show (visbutton);
  gtk_box_pack_start (GTK_BOX (hbox5), visbutton, FALSE, FALSE, 0);
	
  gtk_table_attach (GTK_TABLE (table), hbox5,1,2,0,1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) ( GTK_FILL), 0, 0);
	
  hbox4 = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (hbox4);
  gtk_container_set_border_width (GTK_CONTAINER (hbox4), 3);
  gtk_table_attach (GTK_TABLE (table), hbox4,0,1,1,2,
                    (GtkAttachOptions) ( GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);
	
  label11 = gtk_label_new (_("Value"));
  gtk_widget_show (label11);
  gtk_box_pack_start (GTK_BOX (hbox4), label11, TRUE, FALSE, 0);
	
  val_entry = gtk_entry_new ();
  gtk_widget_show (val_entry);
  gtk_box_pack_start (GTK_BOX (hbox4), val_entry, TRUE, TRUE, 0);
  gtk_object_set_data(GTK_OBJECT(window),"val_entry",val_entry);
  gtk_object_set_data(GTK_OBJECT(val_entry),"window",window);
  gtk_object_set_data(GTK_OBJECT(val_entry),"close",(void *)1);
	
  hbox6 = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (hbox6);
	
  gtk_table_attach (GTK_TABLE (table), hbox6,1,2,1,2,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);

  namebutton = gtk_radio_button_new_with_label (show_group, _("Name"));
  show_group = gtk_radio_button_group (GTK_RADIO_BUTTON (namebutton));
  gtk_widget_show (namebutton);
  gtk_box_pack_start (GTK_BOX (hbox6), namebutton, FALSE, FALSE, 0);
  gtk_object_set_data(GTK_OBJECT(window),"shownamebutton",namebutton);
	
  valbutton = gtk_radio_button_new_with_label (show_group, _("Value"));
  show_group = gtk_radio_button_group (GTK_RADIO_BUTTON (valbutton));
  gtk_widget_show (valbutton);
  gtk_box_pack_start (GTK_BOX (hbox6), valbutton, FALSE, FALSE, 0);
  gtk_object_set_data(GTK_OBJECT(window),"showvalbutton",valbutton);
	
  bothbutton = gtk_radio_button_new_with_label (show_group, _("Both"));
  show_group = gtk_radio_button_group (GTK_RADIO_BUTTON (bothbutton));
  gtk_widget_show (bothbutton);
  gtk_box_pack_start (GTK_BOX (hbox6), bothbutton, FALSE, FALSE, 0);
  gtk_object_set_data(GTK_OBJECT(window),"showbothbutton",bothbutton);
	
  hbuttonbox1 = gtk_hbutton_box_new ();
  gtk_widget_show (hbuttonbox1);
  gtk_box_pack_end (GTK_BOX (vbox), hbuttonbox1, FALSE, FALSE, 0);
	
  addbutton = gtk_button_new_with_label (_("Add"));
  gtk_widget_show (addbutton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), addbutton);
  GTK_WIDGET_SET_FLAGS (addbutton, GTK_CAN_DEFAULT);

  gtk_object_set_data(GTK_OBJECT(addbutton),"window",window);

  changebutton = gtk_button_new_with_label (_("Change"));
  gtk_widget_show (changebutton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), changebutton);
  GTK_WIDGET_SET_FLAGS (changebutton, GTK_CAN_DEFAULT);

  gtk_object_set_data(GTK_OBJECT(changebutton),"window",window);

  clearbutton = gtk_button_new_with_label (_("Clear"));
  gtk_widget_show (clearbutton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), clearbutton);
  GTK_WIDGET_SET_FLAGS (clearbutton, GTK_CAN_DEFAULT);
	
  delbutton = gtk_button_new_with_label (_("Delete"));
  gtk_widget_show (delbutton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), delbutton);
  GTK_WIDGET_SET_FLAGS (delbutton, GTK_CAN_DEFAULT);
	
  closebutton = gtk_button_new_with_label (_("Close"));
  gtk_widget_show (closebutton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), closebutton);
  GTK_WIDGET_SET_FLAGS (closebutton, GTK_CAN_DEFAULT);
	
  i=0;

  if (attriblist) {
    while(attriblist[i] != NULL)
    {
      o_attrib_get_name_value(attriblist[i]->text->string,
                              text[0],text[2]);
      if(attriblist[i]->visibility == VISIBLE)
        text[1][0]='V';
      else
        text[1][0]='I';

      if(attriblist[i]->show_name_value == SHOW_NAME)
        text[1][2]='N';
      else if(attriblist[i]->show_name_value == SHOW_VALUE)
        text[1][2]='V';
      else
        text[1][2]='B';
      row = gtk_clist_append(GTK_CLIST(clist),text);
      gtk_clist_set_row_data (GTK_CLIST(clist),row,attriblist[i]);
      i++;
    }
  }

  i = 0;
  string = (char *) s_attrib_get(i);
  while (string != NULL)
  {
    combo2_items = g_list_append (combo2_items, string);
    i++;
    string = (char *) s_attrib_get(i);
  }
  combo2_items = g_list_prepend (combo2_items, NULL);
  gtk_combo_set_popdown_strings (GTK_COMBO (combo2), combo2_items);
  g_list_free (combo2_items);

  gtk_widget_show (window);
  o_attrib_free_returned(attriblist);
  w_current->mawindow=window;

  gtk_window_position(GTK_WINDOW (window), GTK_WIN_POS_MOUSE);

  gtk_signal_connect(GTK_OBJECT (w_current->mawindow), "destroy",
                     GTK_SIGNAL_FUNC(destroy_window),
                     &w_current->mawindow);

  gtk_signal_connect(GTK_OBJECT(w_current->mawindow),
                     "key_press_event",
                     (GtkSignalFunc) multi_attrib_edit_keypress, w_current);

  gtk_signal_connect(GTK_OBJECT(val_entry), "activate",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_change),w_current);
  gtk_signal_connect(GTK_OBJECT(addbutton),"clicked",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_add),w_current);
  gtk_signal_connect(GTK_OBJECT(changebutton),"clicked",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_change),w_current);
  gtk_signal_connect(GTK_OBJECT(clearbutton),"clicked",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_clear),window);
  gtk_signal_connect(GTK_OBJECT(delbutton),"clicked",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_delete),w_current);
  gtk_signal_connect(GTK_OBJECT(closebutton),"clicked",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_close),w_current);

  gtk_signal_connect(GTK_OBJECT(clist),"select-row",
                     GTK_SIGNAL_FUNC(multi_attrib_edit_select_row),w_current);

  multi_attrib_edit_clear(NULL,GTK_WINDOW(window));
  gtk_grab_add(w_current->mawindow);

  free(text[0]);
  free(text[1]);
  free(text[2]);
}


@ %def multi_attrib_edit




