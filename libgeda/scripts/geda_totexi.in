#!/bin/sh
# Copyright 2001 by Patrick Bernaud. All rights reserved
# See file COPYRIGHT for more information.

# This program is inspired by the totex script from noweb
# Its copyright notice is :
#     Copyright 1991 by Norman Ramsey.  All rights reserved.
#

# Don't try to understand this file! Look at totexi.nw instead!
delay=0 noindex=0
for i do
  case $i in
    -delay)   delay=1   ;;
    -noindex) noindex=1 ;;
    *) echo "This can't happen -- $i passed to totexi" 1>&2 ; exit 1 ;;
  esac
done
@AWK@ 'BEGIN               { code=0 ; quoting=0 ; text=1; 
	                       defns[0] = 0;
	 		      lastref = ""; lastlabel = "";
	                       nlines = 0;
	                       currentchunk = ""; }


	 /^@file /           { filename = substr($0, 7);         }
	 /^@literal /        { lines[nlines++] = substr($0, 10); }

	 /^@header texinfo / { }
	 /^@trailer texinfo$/{ }


	 /^@begin code/      { code=1;
	                       lines[nlines++] = "@format\n"; 
	                     }
	 /^@defn /           { name = substr($0, 7); 
	 # user defined indexes not allowed with info output
	 # need further investigation
	 #  		      lines[nlines++] = "@cnindex " name "\n";
	 		      if(lastlabel != "") {
	 			  lines[nlines++] = "@clabel " lastlabel;
	 			  tmp = escape_anchor_char(name);
	 # used when splitting into multiple chunks but 
	 # using the same code chunk name
	 			  if(tmp in labeldefns) {
	 # in case it is a multipe chunk defined code chunk, it adds a number
	 # in parenthesis after the code chunk name
	 # this number must be incremented at each new definition
	 			      labels[lastlabel] = tmp " (" (++labeldefns[tmp]) ")";
	 			  } else {
	 			      labeldefns[tmp] = 1;
	 			      labels[lastlabel] = tmp;
	 			  }

	 # save the identifier of the chunk current chunk
	 # to avoid false detection of 'Use' or 'Define'
	                           currentchunk = lastlabel;

	 			  lastlabel = ""; 
	 		      }
	 		      lines[nlines++] = "@i{<<" escape_doc_char(name);
	 # that can lead to really long lines as chunk name
	 # more or less redundant with the name - in the way texinfo does it
	 #  		      if(lastref != "") {
	 #  			  lines[nlines++] = "\n@cref " lastref;
	                       lastref = "";
	 #  		      }
	 		      lines[nlines++] = ">>" defns[name] "=}@t{";
	                       defns[name] = "+";
	                     }
	 /^@use /            { name = substr($0, 6);
	                       lines[nlines++] = "@i{<<" escape_doc_char(name);
	 		      if(lastref != "") {
	 			  lines[nlines++] = "\n@cref " lastref;
	 			  lastref = "";
	 		      }
	 		      lines[nlines++] = ">>}"; 
	                     }
	 /^@end code/        { code=0 ; 
	                       lines[nlines++] = "}\n@end format\n"; 
	                       currentchunk = "";
	                     }

	 /^@begin docs/      { text = 0;
	                     }
	 /^@end docs/        { }

	 /^@quote$/          { quoting = 1;
	                       lines[nlines++] = "@code{";
	                     }
	 /^@endquote$/       { quoting = 0;
	                       lines[nlines++] = "}";
	                     }

	 /^@text /           { line = substr($0, 7); 
	                       text += length - 6;
	                       if(code)
	                         lines[nlines++] = escape_code_char(line);
	                       else if(quoting)  
	                         lines[nlines++] = escape_quote_char(line);
	 		      else
	                         lines[nlines++] = escape_doc_char(line);
	                     } 
	 /^@nl$/             { if (!code) { if(text==0) lines[nlines++] = "\n"
	 						   text = 1}
	                       if (quoting) lines[nlines++] = "\n";
	 		      lines[nlines++] = "\n";
	                     }

	 /^@xref label /     { lastlabel = substr($0, 13); }
	 /^@xref ref /       { lastref = substr($0, 11); }


	 # eviter repetitions de la ref courante
	 # fonctionnement de la table usedref a changer :
	 # - faire indice par ref (plus par entier)
	 # - permet de supprimer toutes les redondances de detection usage
	 # - necessite effacement efficace du tableau entre deux 
	 /^@index begindefs$/{ lines[nlines++] = "@display\n";
	                       lines[nlines++] = "@r{Defines :\n";
	 		      delete usedref; }
	 /^@index isused /   { ref = substr($0, 15);
	 # to prevent an item to be defined and used in the same chunk
	                       if(ref != currentchunk) {
	                           usedref[ref] = ref; 
	                     } }
	 /^@index defitem /  { lines[nlines++] = "@t{" substr($0, 16) "},\n";
	 #  		      lines[nlines++] = "@dfindex{" name "}\n";
	 # le plus simple est de poser flag sur used ou non
	 lines[nlines+1] = "never used.";
	 #lines[nlines++] = "used in ";
	 for(ref in usedref) {
	   lines[nlines++] = "\n@cref " usedref[ref];
	   lines[nlines++] = ",\n";
	 } 
	 # correct the last line written : change the ',' in '.'
	 lines[nlines-1] = ".\n";
	 delete usedref;
	 }
	   
	 #                        if(nusedref == 0) lines[nlines++] = "never used.\n";
	 #  		      else {
	 #  			  lines[nlines++] = "used in ";
	 #  			  for(i = 0; i < nusedref-1; i++) {
	 #  			      lines[nlines++] = "\n@cref " usedref[i];
	 #  			      lines[nlines++] = ", ";
	 #  			  }
	 #  			  lines[nlines++] = "\n@cref " usedref[nusedref-1];
	 #  			  lines[nlines++] = ".\n"; 
	 #  		      } }
	 /^@index enddefs$/  { lines[nlines++] = "}\n";
	                       lines[nlines++] = "@end display\n"; }

	 /^@index beginuses$/{ lines[nlines++] = "@display\n";
	 #                      lines[nlines++] = "@r{@exdent Uses :\n";
	                       lines[nlines++] = "@r{Uses :\n";
	 		      lastref = ""; }
	 /^@index isdefined /{ lastref = substr($0, 18); }
	 /^@index useitem /  { lines[nlines++] = "@t{" substr($0, 16) "}, ";
	                       if(lastref != "") {
	 			  lines[nlines++] = "\n@cref " lastref;
	 		      } 
	 		      lines[nlines++] = ".\n"; }
	 /^@index enduses$/  { lines[nlines++] = "}\n";
	                       lines[nlines++] = "@end display\n"; }



	 /^@index nl$/       { }

	 /^@xref begindefs$/ { }
	 /^@xref defitem /   { }
	 /^@xref enddefs$/   { }
	 /^@xref beginuses$/ { }
	 /^@xref useitem /   { }
	 /^@xref enduses$/   { }
	 /^@xref notused /   { }
	 /^@xref nextdef /   { } 
	 /^@xref prevdef /   { } 
	 /^@xref beginchunks$/{ }
	 /^@xref chunkbegin /{ }
	 /^@xref chunkuse /  { }
	 /^@xref chunkdefn / { }
	 /^@xref chunkend$/  { }
	 /^@xref endchunks$/ { }
	 /^@index defn /     { }
	 /^@index localdefn /{ }
	 /^@index use /      { }

	 /^@index beginindex$/{ }
	 /^@index entrybegin /{ }
	 /^@index entryuse /  { }
	 /^@index entrydefn / { }
	 /^@index entryend$/  { }
	 /^@index endindex$/  { }



	 # write down the Texinfo output
	 END { 
	     for(i = 0; i < nlines; i++) {

	 	if(lines[i] ~ /^@clabel /) {
	 	    label = substr(lines[i], 9);
	 	    lines[i] = "@anchor{" labels[label] "}\n";
	 	} else if(lines[i] ~ /^\n@cref /) {
	 	    ref = substr(lines[i], 8);
	 	    lines[i] = " -- @ref{" labels[ref] "}";
	 	}
	 	
	 	printf "%s", lines[i];
	     }

	 }



	 # functions to escape special characters in code, doc and anchor
	 function escape_code_char(line) {
	     gsub(/@/,  "@@", line);
	     gsub(/{/,  "@{", line);
	     gsub(/}/,  "@}", line);
	     gsub(/\n/, "\\", line);
	     return line;
	 }


	 function escape_anchor_char(line) {
	     gsub(/:/,  "-", line);
	     gsub(/\*/, "-root-", line);
	     return line;
	 }


	 function escape_quote_char(line) {
	     gsub(/@/, "@@", line);
	     gsub(/{/,  "@{", line);
	     gsub(/}/,  "@}", line);
	     return line;
	 }


	 function escape_doc_char(line) {
	     return line;
	 }

' delay=$delay noindex=$noindex
