@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File x_log.c,,,Top
@chapter File @file{x_log.c}

@section File header

<<x_log.c : *>>=
<<x_log.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/x_log.nw instead */

/* TODO: STILL NEED to clean up line lengths in aa and tr */

<<x_log.c : include directives>>
<<x_log.c : global variables>>
<<x_log.c : x_log_init()>>
<<x_log.c : x_log_read()>>
<<x_log.c : x_log_update()>>
<<x_log.c : x_log_close()>>
<<x_log.c : x_log_free()>>
<<x_log.c : x_log_keypress()>>
<<x_log.c : x_log_setup_win()>>

@


<<x_log.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<x_log.c : include directives>>=
#include <config.h>

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/globals.h"
#include "../include/prototype.h"

@


<<x_log.c : global variables>>=
GtkWidget *stwindow = NULL;

#ifdef HAS_GTK22
static GtkTextBuffer *sttextbuf = NULL;
static GtkTextView   *sttextview = NULL;
#else
static GtkWidget *sttext = NULL;
#endif

static char *logfilename;

@ %def stwindow sttextbuf sttextview logfilename


@section Function @code{x_log_init()}

@defun x_log_init cwd filename
@end defun

<<x_log.c : x_log_init()>>=
void 
x_log_init(char *cwd, char *filename) 
{
  logfilename = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, 
					filename, NULL); 
}


@ %def x_log_init


@section Function @code{x_log_read()}

@defun x_log_read 
@end defun

<<x_log.c : x_log_read()>>=
void
x_log_read(void)
{
  char buf[200]; /* increased size to make multibyte character sets happy */
  int tmp_fd;
  int len;

	
  if (do_logging == FALSE) {
    return;
  }

  tmp_fd = open(logfilename, O_RDONLY, 0600);

  if (tmp_fd == -1) {
    do_logging = FALSE;
    return;
  }

  while ((len = read(tmp_fd, &buf, 198)) != 0) {
    /* not sure if this nukes the last char or not... */
    buf[len] = '\0'; /* null terminate the buffer */
#ifdef HAS_GTK22
    gtk_text_buffer_insert_at_cursor(sttextbuf, buf, len);
#else
    gtk_text_insert (GTK_TEXT (sttext),
                     NULL, NULL, NULL,
                     buf, len);
#endif
  }

  close(tmp_fd);
}


@ %def x_log_read


@section Function @code{x_log_update()}

@defun x_log_update buf
@end defun

<<x_log.c : x_log_update()>>=
void
x_log_update(char *buf)
{
  int nchars;

  if (do_logging == FALSE) {
    return;
  }

  if (buf == NULL) {
    return;
  }

  switch(logging_dest) {
    case(LOG_WINDOW):
    if (!stwindow) {
      return;
    }

    nchars = strlen(buf);
#ifdef HAS_GTK22
    gtk_text_buffer_insert_at_cursor(sttextbuf, buf, nchars);
#else
    gtk_text_insert(GTK_TEXT (sttext),
                    NULL, NULL, NULL,
                    buf, nchars);
#endif
    break;

    case(STDOUT_TTY):
    fputs (buf, stdout);
    break;

    case(BOTH):
    fputs (buf, stdout);

    if (!stwindow) {
      break;
    }

    nchars = strlen(buf);
#if HAS_GTK22
    gtk_text_buffer_insert_at_cursor(sttextbuf, buf, nchars);
#else
    gtk_text_insert(GTK_TEXT (sttext),
                    NULL, NULL, NULL,
                    buf, nchars);
#endif
    break;
  }
}


@ %def x_log_update


@section Function @code{x_log_close()}

@defun x_log_close w w_current
@end defun

<<x_log.c : x_log_close()>>=
void
x_log_close(GtkWidget *w, TOPLEVEL *w_current)
{
  gtk_widget_destroy(stwindow);
  stwindow = NULL;


#if 0
  gtk_grab_remove(w_current->stwindow);
#endif
}


@ %def x_log_close


@section Function @code{x_log_free()}

@defun x_log_free 
@end defun

<<x_log.c : x_log_free()>>=
void
x_log_free(void)
{
  free(logfilename);
  logfilename = NULL;
}


@ %def x_log_free


@section Function @code{x_log_keypress()}
 
@defun x_log_keypress w event w_current
@end defun
 
<<x_log.c : x_log_keypress()>>=
int
x_log_keypress(GtkWidget * widget, GdkEventKey * event,
               TOPLEVEL * w_current)
{
  if (strcmp(gdk_keyval_name(event->keyval), "Escape") == 0) {
    x_log_close(NULL, w_current);
    return TRUE;
  }

  return FALSE;
}


@ %def x_log_keypress


@section Function @code{x_log_setup_win()}

@defun x_log_setup_win w_current
@end defun

<<x_log.c : x_log_setup_win()>>=
void
x_log_setup_win (TOPLEVEL *w_current)
{
  GtkWidget *buttoncancel = NULL;
#ifdef HAS_GTK12 
  GtkWidget *hscrollbar = NULL;
  GtkWidget *vscrollbar = NULL;
#endif
  GtkWidget *table = NULL;
  GtkWidget *vbox, *action_area;
#ifdef HAS_GTK22
  GtkScrolledWindow *swin;
#endif

  if (do_logging == FALSE) {
    return;
  }


  if (!stwindow) {

    stwindow = x_create_dialog_box(&vbox, &action_area); 

    /* comment this out if you want the log window to have
     * wm decorations */
    if (w_current->log_window_type == TRANSIENT) {
      gtk_window_set_transient_for(
                                   GTK_WINDOW (stwindow),
                                   GTK_WINDOW (w_current->main_window));
      gtk_window_position (GTK_WINDOW (stwindow),
                           GTK_WIN_POS_MOUSE);
    } else {
      gtk_window_position (GTK_WINDOW (stwindow),
                           GTK_WIN_POS_NONE);
    }

    gtk_widget_set_usize(stwindow, 600, 150);

    gtk_signal_connect(GTK_OBJECT (stwindow),
                       "destroy", GTK_SIGNAL_FUNC(destroy_window),
                       &stwindow);

#if 0 /* this was causing the dialog box to not die */
    gtk_signal_connect(GTK_OBJECT (stwindow),
                       "delete_event",
                       GTK_SIGNAL_FUNC(destroy_window),
                       &stwindow);
#endif

    gtk_window_set_title(GTK_WINDOW (stwindow),
                         _("Status"));
    gtk_container_border_width (GTK_CONTAINER (stwindow), 0);

    table = gtk_table_new (2, 2, FALSE);
    gtk_table_set_row_spacing (GTK_TABLE (table), 0, 2);
    gtk_table_set_col_spacing (GTK_TABLE (table), 0, 2);
    gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);
    gtk_widget_show (table);

#ifdef HAS_GTK22
    sttextbuf = gtk_text_buffer_new(gtk_text_tag_table_new());
    sttextview= gtk_text_view_new_with_buffer(sttextbuf);
    gtk_text_view_set_editable (sttextview, FALSE);

    swin=gtk_scrolled_window_new(sttextview->hadjustment,
                               sttextview->vadjustment);
    gtk_scrolled_window_set_policy(swin, GTK_POLICY_AUTOMATIC, 
                                       GTK_POLICY_AUTOMATIC);
#else
    sttext = gtk_text_new (NULL, NULL);
    gtk_text_set_editable (GTK_TEXT (sttext), FALSE);
#endif

#ifdef HAS_GTK22
    gtk_table_attach (GTK_TABLE (table), GTK_WIDGET(swin),
#else
    gtk_table_attach (GTK_TABLE (table), sttext,
#endif
                      0, 1, 0, 1,
                      GTK_EXPAND | GTK_SHRINK | GTK_FILL,
                      GTK_EXPAND | GTK_SHRINK | GTK_FILL, 0, 0);
#ifdef HAS_GTK22
    gtk_container_add(GTK_CONTAINER(swin), GTK_WIDGET(sttextview));
    gtk_widget_show (GTK_WIDGET(swin));
    gtk_widget_show (GTK_WIDGET(sttextview));
#else
    gtk_widget_show (sttext);
#endif

#ifdef HAS_GTK12 
    hscrollbar = gtk_hscrollbar_new (GTK_TEXT (sttext)->hadj);
    gtk_table_attach (GTK_TABLE (table), hscrollbar, 0, 1, 1, 2,
                      GTK_EXPAND | GTK_FILL | GTK_SHRINK, GTK_FILL, 0, 0);
    gtk_widget_show (hscrollbar);

    vscrollbar = gtk_vscrollbar_new (GTK_TEXT (sttext)->vadj);
    gtk_table_attach (GTK_TABLE (table), vscrollbar, 1, 2, 0, 1,
                      GTK_FILL, GTK_EXPAND | GTK_SHRINK | GTK_FILL, 0, 0);
    gtk_widget_show (vscrollbar);
#endif

    buttoncancel = gtk_button_new_with_label (_("Close"));
    GTK_WIDGET_SET_FLAGS (buttoncancel, GTK_CAN_DEFAULT);
    gtk_box_pack_start (GTK_BOX (action_area),
                        buttoncancel, TRUE, TRUE, 0);
    gtk_signal_connect (GTK_OBJECT (buttoncancel), "clicked",
                        GTK_SIGNAL_FUNC(x_log_close), NULL);
    gtk_widget_show (buttoncancel);

    gtk_signal_connect(GTK_OBJECT(stwindow), "key_press_event",
                     (GtkSignalFunc) x_log_keypress, w_current);
  }

  if (!GTK_WIDGET_VISIBLE (stwindow)) {
    gtk_widget_show (stwindow);
    x_log_read(); /* update the contents of the log */
  } else {
    gdk_window_raise(stwindow->window);
  }
}


@ %def x_log_setup_win

