@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File s_clib.c,,,Top
@chapter File @file{s_clib.c}

@section File header

<<s_clib.c : *>>=
<<s_clib.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/s_clib.nw instead */

<<s_clib.c : include directives>>
<<s_clib.c : global variables>>
<<s_clib.c : s_clib_return_num()>>
<<s_clib.c : s_clib_add_entry()>>
<<s_clib.c : s_clib_search_for_dirname()>>
<<s_clib.c : s_clib_cache_search()>>
<<s_clib.c : s_clib_cache_add()>>
<<s_clib.c : s_clib_search_dirs()>>
<<s_clib.c : s_clib_search()>>
<<s_clib.c : s_clib_print()>>
<<s_clib.c : s_clib_cache_free()>>
<<s_clib.c : s_clib_free()>>
<<s_clib.c : s_clib_init()>>
<<s_clib.c : s_clib_getdir()>>
<<s_clib.c : s_clib_getfiles()>>
<<s_clib.c : s_clib_uniq()>>

@


<<s_clib.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * libgeda - gEDA's library
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<s_clib.c : include directives>>=
#include <config.h>

#include <stdio.h>
#include <sys/types.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif

#include <gtk/gtk.h>
#include <guile/gh.h>

#include "defines.h"
#include "struct.h"
#include "globals.h"

#include "../include/prototype.h"

/* clib stands for component library */

/* currently everytime you access a component directory, you will search   */
/* the directory.  This might be slow, but perhaps the OS provided caching */
/* of directories is enough? */
/* eventually you will want to cache the directories which hold components */
/* and only search for the components if the date changes on the directory */
/* but I'll add that later... hack */

/* need to test everything at boundary conditions (exceed cache size etc...) */

/* memory is allocated here in these functions and sticks around */
/* ie if somebody returns a char * to the outside world then that memory */
/* is already allocated */
/* so all memory must be free in the calling routines */

@

 
<<s_clib.c : global variables>>=
struct st_clib {
	char *dir_name;
};

static int clib_index=0;

#define MAX_CLIBS	128

/* and eventually make this unlimited */
/* hack hack */
static struct st_clib clib[MAX_CLIBS];



/* Cache for caching (!) files in clib directories */
struct st_clib_cache {
	char *basename;
	char *clib;
}; 

static int clib_cache_index=0;

#define MAX_CLIBS_CACHE	64	

/* This cache is fixed, and acts like a ring buffer */
static struct st_clib_cache clib_cache[MAX_CLIBS_CACHE];

@ %def clib_index MAX_CLIBS clib clib_cache_index MAX_CLIBS_CACHE clib_cache


@section Function @code{s_clib_return_num()}

@defun s_clib_return_num 
@end defun

<<s_clib.c : s_clib_return_num()>>=
int 
s_clib_return_num(void) 
{
  return(clib_index);
}


@ %def s_clib_return_num


@section Function @code{s_clib_add_entry()}

@defun s_clib_add_entry new_path
@end defun

<<s_clib.c : s_clib_add_entry()>>=
int 
s_clib_add_entry(char *new_path) 
{
  if (new_path == NULL) {
    return(-1); 
  }

  if (clib_index >= MAX_CLIBS) {
    return(-1); 
  }

  clib[clib_index].dir_name = (char *) malloc(sizeof(char)*strlen(new_path)+1);

  strcpy(clib[clib_index].dir_name, new_path);

  clib_index++;
  return(clib_index);
}


@ %def s_clib_add_entry


@section Function @code{s_clib_search_for_dirname()}

@defun s_clib_search_for_dirname dir_name
@end defun

<<s_clib.c : s_clib_search_for_dirname()>>=
/* return true if it finds it else zero */
int
s_clib_search_for_dirname(char *dir_name)
{
  int i;

  for (i = 0; i < clib_index; i++) {
    if (strcmp(clib[i].dir_name, dir_name) == 0) {
      return(1);	
    }	
  }

  return(0);
}


@ %def s_clib_search_for_dirname


@section Function @code{s_clib_cache_search()}

@defun s_clib_cache_search basename
@end defun

<<s_clib.c : s_clib_cache_search()>>=
char *
s_clib_cache_search(char *basename) 
{
  char *clib_path=NULL;
  int i=0;

  /* can you have entries after the first null? hack */
  for (i = 0; i < clib_cache_index; i++) {
    if (strcmp(clib_cache[i].basename, basename) == 0) {
      clib_path = (char *) malloc(sizeof(char)*
                                  strlen(clib_cache[i].clib)+1);
      strcpy(clib_path, clib_cache[i].clib);
      return(clib_path);
    }
  }
  return(NULL);
}


@ %def s_clib_cache_search


@section Function @code{s_clib_cache_add()}

@defun s_clib_cache_add clib_path basename
@end defun

<<s_clib.c : s_clib_cache_add()>>=
int
s_clib_cache_add(char *clib_path, char *basename)
{
  int len;

  if (clib_path == NULL || basename == NULL) {
    return(-1); /* oops */
  }

  if (clib_cache[clib_cache_index].basename)
  free(clib_cache[clib_cache_index].basename);

  if (clib_cache[clib_cache_index].clib)
  free(clib_cache[clib_cache_index].clib);

  len = strlen(clib_path);
  clib_cache[clib_cache_index].clib = (char *) malloc(sizeof(char)*len+1);
  strcpy(clib_cache[clib_cache_index].clib, clib_path);

  len = strlen(basename);
  clib_cache[clib_cache_index].basename = (char *) malloc(sizeof(char)*len+1);
  strcpy(clib_cache[clib_cache_index].basename, basename);

  clib_cache_index = ( clib_cache_index + 1 ) % MAX_CLIBS_CACHE;

  return(0);	
}


@ %def s_clib_cache_add


@section Function @code{s_clib_search_dirs()}

@defun s_clib_search_dirs basename
@end defun

<<s_clib.c : s_clib_search_dirs()>>=
char *
s_clib_search_dirs(char *basename)
{
  int i;
  int len;
  DIR *ptr=NULL;
  struct dirent *dptr;
  char *clib_path=NULL;

  /* search the list backward */
  for (i = clib_index-1 ; i >= 0; i--) {
    /* for (i = 0 ; i < clib_index; i++) {*/

#if DEBUG
    printf("searching %d _%s_\n", i, clib[i].dir_name);
#endif
    ptr = opendir(clib[i].dir_name);

    if (ptr == NULL) {
      fprintf(stderr, "Oops got a null dir_name!\n");
      exit(-1);
    }

    dptr = readdir(ptr);

    while(dptr != NULL) {

      if (strcmp(dptr->d_name, basename) == 0)  {
        len = strlen(clib[i].dir_name);				
        clib_path = (char *) malloc(sizeof(char)*len+1);
        strcpy(clib_path, clib[i].dir_name);
	
        if (ptr) {
          closedir(ptr);
          ptr = NULL;
        }

        return(clib_path);
      }
      dptr = readdir(ptr);
    }

    if (ptr) {
      closedir(ptr);
      ptr = NULL;
    }

	
  }

  if (ptr) {
    closedir(ptr);
    ptr = NULL;
  }

  return(NULL);
}


@ %def s_clib_search_dirs


@section Function @code{s_clib_search()}

@defun s_clib_search basename
@end defun

<<s_clib.c : s_clib_search()>>=
char *
s_clib_search(char *basename) 
{
  char *clib_path=NULL;

  clib_path = s_clib_cache_search(basename);

  if (clib_path) {

#if DEBUG
    printf("Found [%s] in [%s] (cached)\n", basename, clib_path);
#endif
    return(clib_path);
  } else {
    /* not in cache so search for it in dirs */
    /* put it in the cache too */
    clib_path = s_clib_search_dirs(basename);

    if (clib_path) {
      /* return type */
#if DEBUG
      printf("Found [%s] in [%s]\n", basename, clib_path);
#endif
      s_clib_cache_add(clib_path, basename);
      return(clib_path);
    } else {
      fprintf(stderr, "Could not find [%s] in any ComponentLibrary\nSymbol will be removed from schematic\n", basename);
      return(NULL);
    }

  }
}


@ %def s_clib_search


@section Function @code{s_clib_print()}

@defun s_clib_print 
@end defun

<<s_clib.c : s_clib_print()>>=
void
s_clib_print()
{
  int i;

  for (i = 0; i < clib_index; i++) {
    printf("%s\n", clib[i].dir_name);
  }
}


@ %def s_clib_print


@section Function @code{s_clib_cache_free()}

@defun s_clib_cache_free 
@end defun

<<s_clib.c : s_clib_cache_free()>>=
void
s_clib_cache_free()
{
  int i=0;	

  /* this has to be MAX_CLIBS_CACHE since clib_cache_index can wrap */
  /* around */
  for (i = 0; i < MAX_CLIBS_CACHE; i++) {
    if (clib_cache[i].basename) {
      free(clib_cache[i].basename);
      clib_cache[i].basename = NULL;	
    }

    if (clib_cache[i].clib) {
      free(clib_cache[i].clib);
      clib_cache[i].clib = NULL;	
    }
  }

  clib_cache_index=0;
}


@ %def s_clib_cache_free


@section Function @code{s_clib_free()}

@defun s_clib_free 
@end defun

<<s_clib.c : s_clib_free()>>=
void
s_clib_free()
{
	int i;

	for (i = 0; i < clib_index; i++) {
		if (clib[i].dir_name) {
               		free(clib[i].dir_name);
			clib[i].dir_name = NULL;
		}		
	}

	clib_index=0;
}


@ %def s_clib_free


@section Function @code{s_clib_init()}

@defun s_clib_init
@end defun

<<s_clib.c : s_clib_init()>>=
void
s_clib_init()
{
  int i;
  for (i = 0; i < MAX_CLIBS; i++) {
    clib[i].dir_name = NULL;	
  } 

  for (i = 0; i < MAX_CLIBS_CACHE; i++) {
    clib_cache[i].basename = NULL;	
    clib_cache[i].clib = NULL;	
  } 
}


@ %def s_clib_init


@section Function @code{s_clib_getdir()}

@defun s_clib_getdir index
@end defun

<<s_clib.c : s_clib_getdir()>>=
/* returns clibs */
char *
s_clib_getdir(int index)
{
  if (index < 0 || index >= clib_index) 
    return(NULL);
   
  if (clib[index].dir_name != NULL)
    return(clib[index].dir_name);
  else 
    return(NULL);
}


@ %def s_clib_getdir


@section Function @code{s_clib_getfiles()}

@defun s_clib_getfiles directory filter
@end defun

<<s_clib.c : s_clib_getfiles()>>=
GSList*
s_clib_getfiles(const char *directory, const char *filter)
{
  DIR *dir;
  struct dirent *dirent;
  GSList *ret = NULL;
  
  g_assert (directory != NULL);

  /* open the directory */
  dir = opendir (directory);
  if (dir == NULL) {
    s_log_message ("Can not open directory [%s]\n", directory);
    return NULL;
  }

  /* now read the entire directory */
  /* and build a list of filenames in directory that match filter */
  while ((dirent = readdir (dir)) != NULL) {
    /* skip .'s */
    if (dirent->d_name[0] == '.') {
      continue;
    }

    /* identify filter-matching filenames */
    if (dirent->d_name != NULL &&
        strstr (dirent->d_name, filter)) {
      ret = g_slist_append (ret, (gpointer)u_basic_strdup (dirent->d_name));
    }
  }

  /* finished: close the directory stream */
  closedir(dir);

  /* sort the list alphabetically */
  ret = g_slist_sort (ret, (GCompareFunc)strcasecmp);
  
  /* and return the sorted list of filenames */
  return ret;
}


@ %def s_clib_getfiles


@section Function @code{s_clib_uniq()}

@defun s_clib_uniq path
@end defun

<<s_clib.c : s_clib_uniq()>>=
int
s_clib_uniq(char *path) 
{
  if (s_clib_search_for_dirname(path)) {
#if DEBUG 
    printf("found\n");
#endif
    return(0);
  } else {
#if DEBUG
    printf("NOT found\n");
#endif
    return(1);
  }
}


@ %def s_clib_uniq

