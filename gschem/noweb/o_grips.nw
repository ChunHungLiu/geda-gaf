@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_grips.c,,,Top
@chapter File @file{o_grips.c}

@section File header

<<o_grips.c : *>>=
<<o_grips.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_grips.nw instead */

<<o_grips.c : include directives>>
<<o_grips.c : macros>>
<<o_grips.c : global variables>>

<<o_grips.c : o_grips_search()>>
<<o_grips.c : o_grips_search_arc()>>
<<o_grips.c : o_grips_search_box()>>
<<o_grips.c : o_grips_search_circle()>>
<<o_grips.c : o_grips_search_line()>>

<<o_grips.c : o_grips_start()>>
<<o_grips.c : o_grips_start_arc()>>
<<o_grips.c : o_grips_start_box()>>
<<o_grips.c : o_grips_start_circle()>>
<<o_grips.c : o_grips_start_line()>>

<<o_grips.c : o_grips_motion()>>
<<o_grips.c : o_grips_motion_arc()>>
<<o_grips.c : o_grips_motion_box()>>
<<o_grips.c : o_grips_motion_circle()>>
<<o_grips.c : o_grips_motion_line()>>

<<o_grips.c : o_grips_end()>>
<<o_grips.c : o_grips_end_arc()>>
<<o_grips.c : o_grips_end_box()>>
<<o_grips.c : o_grips_end_circle()>>
<<o_grips.c : o_grips_end_line()>>

<<o_grips.c : o_grips_size()>>

<<o_grips.c : o_grips_draw()>>
<<o_grips.c : o_grips_erase()>>

@

<<o_grips.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<o_grips.c : include directives>>=
#include <config.h>
#include <stdio.h>
#include <math.h>

#include <libgeda/libgeda.h>

#include "../include/x_states.h"
#include "../include/prototype.h"

@


<<o_grips.c : macros>>=
/* Kazu on July 16, 1999 - Added these macros to simplify the code */
#define GET_BOX_WIDTH(w)                        \
        abs((w)->last_x - (w)->start_x)
#define GET_BOX_HEIGHT(w)                       \
	        abs((w)->last_y - (w)->start_y)
#define GET_BOX_LEFT(w)                         \
	        min((w)->start_x, (w)->last_x);
#define GET_BOX_TOP(w)                          \
	        min((w)->start_y, (w)->last_y);

@ %def GET_BOX_WIDTH GET_BOX_HEIGHT GET_BOX_LEFT GET_BOX_TOP


@section Global Variables [[whichone_changing]] and [[object_changing]]

@defvar whichone_changing
This variable holds the identifier of the grip currently under modification. Its range of values depends on the type of object.
@end defvar

@defvar object_changing
This variable holds a pointer on the object under modification.
@end defvar

<<o_grips.c : global variables>>=
static int whichone_changing = -1;
static OBJECT *object_changing;

@ %def whichone_changing object_changing


@section Function [[o_grips_search()]]

@defun o_grips_search w_current x y whichone
The [[o_grips_search()]] function is used to determine if the ([[x]],[[y]]) point is inside a grip of one of the selected object on the current sheet.
The selected object are in a list starting at [[w_current->page_current->selection2_head]].
The [[x]] and [[y]] parameters are in screen units.
If the point is inside one grip, a pointer on the object it belongs to is returned and [[*whichone]] is set according to the position of the grip on the object.
Else, [[*whichone]] is unchanged and the function returns [[NULL]].
@end defun

A specific search function is provided for every kind of graphical object. The list of selected object is covered : each object is tested with the appropriate function.

<<o_grips.c : o_grips_search()>>=
OBJECT *
o_grips_search(TOPLEVEL *w_current, int x, int y, int *whichone)
{
  OBJECT *object=NULL;
  OBJECT *found=NULL;
  SELECTION *s_current;
  int size, x2size;
	
  if (!whichone) {
    return(NULL);
  }

  /* get the size of the grip according to zoom level */
  size = o_grips_size(w_current);
  /* size is half the width of a grip, x2size is full width */
  x2size = size * 2;
	
  /* skip over head */
  s_current = w_current->page_current->selection2_head->next;
  while (s_current) {
    if (s_current->selected_object) {
      object = s_current->selected_object;
      switch(object->type) {
				
        case(OBJ_ARC):
          /* check the grips of the arc object */
          found = o_grips_search_arc(w_current, object,
                                     x, y, size, whichone);
          if(found != NULL) return found;
          break;
				
        case(OBJ_BOX):
          /* check the grips of the box object */
          found = o_grips_search_box(w_current, object,
                                     x, y, size, whichone);
          if(found != NULL) return found;
          break;
		  
        case(OBJ_CIRCLE):
          /* check the grips of the circle object */
          found = o_grips_search_circle(w_current, object,
                                        x, y, size, whichone);
          if(found != NULL) return found;
          break;
			
        case(OBJ_LINE):
        case(OBJ_PIN):
        case(OBJ_NET):
        case(OBJ_BUS):
          /* check the grips of the line object */
          /* the function is the same for line, pin, net, bus */
          found = o_grips_search_line(w_current, object,
                                      x, y, size, whichone);
          if(found != NULL) return found;
          break;

        default:
          /* object type is unknown : error condition */
          return NULL;
      }
    }
    s_current = s_current->next;	
  }
	
  return(NULL);
}

@  %def o_grips_search


@section Function [[o_grips_start()]]

@defun o_grips_start w_current x y
This function starts the process of modifying one grip of an object on the current sheet. The event occured in ([[x]],[[y]]) in screen unit.
If this position is related to a grip of an object, the function prepares the modification of this grip thanks to the user input.

The function returns [[FALSE]] if an error occured of if no grip have been found under ([[x]],[[y]]). It returns [[TRUE]] if a grip has been found and modification of the object has been started.
@end defun

If a grip has been found, this function modifies the global variables [[whichone_changing]] and [[object_changing]] with respectively the identifier of the grip and the object it belongs to.

<<o_grips.c : o_grips_start()>>=
int
o_grips_start(TOPLEVEL *w_current, int x, int y)
{
  OBJECT *object;
  int whichone;
	
  if (w_current->draw_grips == FALSE) {
    return(FALSE);
  }

  /* search if there is a grip on a selected object at (x,y) */
  object = o_grips_search(w_current, x, y, &whichone);
  if (object) {
    /* there is one */
    /* depending on its type, start the modification process */
    switch(object->type) {

      case(OBJ_ARC):
				/* start the modification of a grip on an arc */
        o_grips_start_arc(w_current, object, x, y, whichone);
				
        whichone_changing = whichone;
        object_changing = object;
        return(TRUE);
        break;

      case(OBJ_BOX):
				/* start the modification of a grip on a box */
        o_grips_start_box(w_current, object, x, y, whichone);
				
        whichone_changing = whichone;
        object_changing = object;
        return(TRUE);
        break;
				
      case(OBJ_CIRCLE):
				/* start the modification of a grip on a circle */
        o_grips_start_circle(w_current, object, x, y, whichone);
				
        whichone_changing = whichone;
        object_changing = object;
        return(TRUE);
        break;
			
      case(OBJ_LINE):
				/* start the modification of a grip on a line */
        o_grips_start_line(w_current, object, x, y, whichone);
				
        whichone_changing = whichone;
        object_changing = object;
        return(TRUE);
        break;

      case(OBJ_NET): 
        w_current->last_drawb_mode = -1;
        w_current->last_x = object->line->screen_x[whichone];
        w_current->last_y = object->line->screen_y[whichone];
        w_current->start_x = object->line->screen_x[!whichone];
        w_current->start_y = object->line->screen_y[!whichone];
				
        o_net_erase(w_current, object);
        gdk_gc_set_foreground(w_current->xor_gc, 
                              x_get_color(w_current->select_color) );
        gdk_draw_line(w_current->window, w_current->xor_gc, 
                      w_current->start_x, w_current->start_y, 
                      w_current->last_x, w_current->last_y);
        o_line_erase_grips(w_current, object);
				
        whichone_changing = whichone;
        object_changing = object;
        gdk_gc_set_foreground(w_current->gc, 
                              x_get_color(w_current->background_color)); 
        return(TRUE);
				
        break; 
				
      case(OBJ_PIN): 
				
        w_current->last_drawb_mode = -1;
        w_current->last_x = object->line->screen_x[whichone];
        w_current->last_y = object->line->screen_y[whichone];
        w_current->start_x = object->line->screen_x[!whichone];
        w_current->start_y = object->line->screen_y[!whichone];
				
        o_pin_erase(w_current, object);
        gdk_gc_set_foreground(w_current->xor_gc, 
                              x_get_color(w_current->select_color) );
        gdk_draw_line(w_current->window, w_current->xor_gc, 
                      w_current->start_x, w_current->start_y, 
                      w_current->last_x, w_current->last_y);
        o_line_erase_grips(w_current, object);
				
        whichone_changing = whichone;
        object_changing = object;
        return(TRUE);
				
        break; 
				
      case(OBJ_BUS): 
        w_current->last_drawb_mode = -1;
        w_current->last_x = object->line->screen_x[whichone];
        w_current->last_y = object->line->screen_y[whichone];
        w_current->start_x = object->line->screen_x[!whichone];
        w_current->start_y = object->line->screen_y[!whichone];
				
        o_bus_erase(w_current, object);
        gdk_gc_set_foreground(w_current->xor_gc, 
                              x_get_color(w_current->select_color) );
        gdk_draw_line(w_current->window, w_current->xor_gc, 
                      w_current->start_x, w_current->start_y, 
                      w_current->last_x, w_current->last_y);
        o_line_erase_grips(w_current, object);
				
        whichone_changing = whichone;
        object_changing = object;
        gdk_gc_set_foreground(w_current->gc, 
                              x_get_color(w_current->background_color)); 
        return(TRUE);
				
        break;

      default:
				/* object type unknown : error condition */
        return(FALSE);
				
    }
  }
	
  return(FALSE);
}

@ %def o_grips_start


@section Function [[o_grips_motion()]]

@defun o_grips_motion w_current x y
The [[o_grips_motion()]] function modify the previously selected object according to the mouse position in [[x]] and [[y]].
The grip under modification is updated and the temporary object displayed.
@end defun

The object under modification is [[object_changing]] and the grip concerned is [[whichone_changing]].

Depending on the object type, a specific function is used. It erases the temporary object, updates its internal representation, and draws it again.

<<o_grips.c : o_grips_motion()>>=
void
o_grips_motion(TOPLEVEL *w_current, int x, int y)
{
	
  if (w_current->inside_action == 0) {
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }

  /* no object changing */
  if (object_changing == NULL) {
    /* stop grip process */
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }
	
  switch(object_changing->type) {

    case(OBJ_ARC):
    /* erase, update and draw an arc */
    o_grips_motion_arc(w_current, x, y, whichone_changing);
    break;

    case(OBJ_BOX):
    /* erase, update and draw a box */
    o_grips_motion_box(w_current, x, y, whichone_changing);
    break;
		
    case(OBJ_CIRCLE):
    /* erase, update and draw a circle */
    o_grips_motion_circle(w_current, x, y, whichone_changing);
    break;
		
    case(OBJ_LINE):
    case(OBJ_NET):
    case(OBJ_PIN):
    case(OBJ_BUS):
    /* erase, update and draw a line */
    /* same for net, pin and bus as they share the same internal rep. */
    o_grips_motion_line(w_current, x, y, whichone_changing);
    break;

    default:
    return; /* error condition */
  }
	
}

@ %def o_grips_motion


@section Function [[o_grips_end()]]

@defun o_grips_end w_current
This function ends the process of modifying a parameter of an object with a grip.
The temporary representation of the object is erased, the object is modified and finally drawn.
@end defun

The object under modification is [[object_changing]] and the grip concerned is [[whichone_changing]].

Depending on the object type, a specific function is used. It erases the temporary object, updates the object and draws the modified object normally.

<<o_grips.c : o_grips_end()>>=
void
o_grips_end(TOPLEVEL *w_current)
{
  OBJECT *object=NULL;
  int x, y;
  GList *other_objects = NULL;
  GList *connected_objects = NULL;
	
  object = object_changing;

  if (!object) {
    /* actually this is an error condition hack */
    w_current->event_state = SELECT;
    i_update_status(w_current, "Select Mode");
    w_current->inside_action = 0;
    return;
  }

  switch(object->type) {

    case(OBJ_ARC):
    /* modify an arc object */
    o_grips_end_arc(w_current, object, whichone_changing);
    break;
	  
    case(OBJ_BOX):
    /* modify a box object */
    o_grips_end_box(w_current, object, whichone_changing);
    break;
	  
    case(OBJ_CIRCLE):
    /* modify a circle object */
    o_grips_end_circle(w_current, object, whichone_changing);
    break;
	  
    case(OBJ_LINE):
    /* modify a line object */
    o_grips_end_line(w_current, object, whichone_changing);
    break;

    case(OBJ_NET):
    /* don't allow zero length nets / lines / pins
     * this ends the net drawing behavior 
     * we want this? hack */
    if ((w_current->start_x == w_current->last_x) &&
        (w_current->start_y == w_current->last_y)) {
      w_current->start_x = (-1);
      w_current->start_y = (-1);
      w_current->last_x = (-1);
      w_current->last_y = (-1);
      w_current->inside_action=0;
      w_current->event_state = SELECT;
      i_update_status(w_current, 
                      "Select Mode");
      o_net_eraserubber(w_current);
      o_redraw_single(w_current, object);
      return;
    }
	  
	  
    SCREENtoWORLD(w_current, 
                  w_current->last_x, 
                  w_current->last_y, &x, &y);
	  
    x = snap_grid(w_current, x);
    y = snap_grid(w_current, y);
	  
    o_cue_undraw(w_current, object);
    o_net_erase(w_current, object);
    /* erase xor line */
    gdk_gc_set_foreground(w_current->xor_gc,
                          x_get_color(w_current->select_color));
    gdk_draw_line(w_current->window, w_current->xor_gc,
                  w_current->start_x, w_current->start_y,
                  w_current->last_x, w_current->last_y);
    o_line_erase_grips(w_current, object);
	  
    other_objects = s_conn_return_others(other_objects, object);
    s_conn_remove(w_current, object);
	  
    o_net_modify(w_current, object, x, y, 
                 whichone_changing);
    s_conn_update_object(w_current, object);
    o_redraw_single(w_current, object);
	  
    /* draw the object objects */
    o_cue_undraw_list(w_current, other_objects);
    o_cue_draw_list(w_current, other_objects);
	  
    /* get the other connected objects and redraw them */
    connected_objects = s_conn_return_others(connected_objects,
                                             object);
    o_cue_undraw_list(w_current, connected_objects);
    o_cue_draw_list(w_current, connected_objects);
	  
    /* finally draw this objects cues */
    o_cue_draw_single(w_current, object);
    break;

    case(OBJ_PIN):
    /* don't allow zero length nets / lines / pins
     * this ends the net drawing behavior 
     * we want this? hack */
    if ((w_current->start_x == w_current->last_x) &&
        (w_current->start_y == w_current->last_y)) {
      w_current->start_x = (-1);
      w_current->start_y = (-1);
      w_current->last_x = (-1);
      w_current->last_y = (-1);
      w_current->inside_action=0;
      w_current->event_state = SELECT;
      i_update_status(w_current, 
                      "Select Mode");
      o_redraw_single(w_current, object);
      return;
    }
	  
	  
    SCREENtoWORLD(w_current, 
                  w_current->last_x, 
                  w_current->last_y, &x, &y);
	  
    x = snap_grid(w_current, x);
    y = snap_grid(w_current, y);
	  
    o_cue_undraw(w_current, object);
    o_pin_erase(w_current, object);
    /* erase xor line */
    gdk_gc_set_foreground(w_current->xor_gc,
                          x_get_color(w_current->select_color));
    gdk_draw_line(w_current->window, w_current->xor_gc,
                  w_current->start_x, w_current->start_y,
                  w_current->last_x, w_current->last_y);
    o_line_erase_grips(w_current, object);
	  
    other_objects = s_conn_return_others(other_objects, object);
    s_conn_remove(w_current, object);
	  
    o_pin_modify(w_current, object, x, y, 
                 whichone_changing);
    s_conn_update_object(w_current, object);
    o_redraw_single(w_current, object);
	  
    /* draw the object objects */
    o_cue_undraw_list(w_current, other_objects);
    o_cue_draw_list(w_current, other_objects);
	  
    /* get the other connected objects and redraw them */
    connected_objects = s_conn_return_others(connected_objects,
                                             object);
    o_cue_undraw_list(w_current, connected_objects);
    o_cue_draw_list(w_current, connected_objects);
	  
    /* finally draw this objects cues */
    o_cue_draw_single(w_current, object);
    break;
	  
    case(OBJ_BUS):
    /* don't allow zero length nets / lines / pins
     * this ends the net drawing behavior 
     * we want this? hack */
    if ((w_current->start_x == w_current->last_x) &&
        (w_current->start_y == w_current->last_y)) {
      w_current->start_x = (-1);
      w_current->start_y = (-1);
      w_current->last_x = (-1);
      w_current->last_y = (-1);
      w_current->inside_action=0;
      w_current->event_state = SELECT;
      i_update_status(w_current, 
                      "Select Mode");
      o_net_eraserubber(w_current);
      o_redraw_single(w_current, object);
      return;
    }
	  
    SCREENtoWORLD(w_current, 
                  w_current->last_x, 
                  w_current->last_y, &x, &y);
	  
    x = snap_grid(w_current, x);
    y = snap_grid(w_current, y);
	  
    o_cue_undraw(w_current, object);
    o_bus_erase(w_current, object);
    /* erase xor line */
    gdk_gc_set_foreground(w_current->xor_gc,
                          x_get_color(w_current->select_color));
    gdk_draw_line(w_current->window, w_current->xor_gc,
                  w_current->start_x, w_current->start_y,
                  w_current->last_x, w_current->last_y);
    o_line_erase_grips(w_current, object);
	  
    other_objects = s_conn_return_others(other_objects, object);
    s_conn_remove(w_current, object);
	  
    o_bus_modify(w_current, object, x, y, 
                 whichone_changing);
    s_conn_update_object(w_current, object);
    o_redraw_single(w_current, object);
	  
    /* draw the object objects */
    o_cue_undraw_list(w_current, other_objects);
    o_cue_draw_list(w_current, other_objects);
	  
    /* get the other connected objects and redraw them */
    connected_objects = s_conn_return_others(connected_objects,
                                             object);
    o_cue_undraw_list(w_current, connected_objects);
    o_cue_draw_list(w_current, connected_objects);
	  
    /* finally draw this objects cues */
    o_cue_draw_single(w_current, object);
    break;
	  
    default:
    return;
  }

			
  w_current->page_current->CHANGED=1;
  
  g_list_free(other_objects);
  other_objects = NULL;
  g_list_free(connected_objects);
  connected_objects = NULL;

  /* reset global variables */
  whichone_changing = -1;
  object_changing = NULL;
  
  o_undo_savestate(w_current, UNDO_ALL);
}

@ %def o_grips_end


@section Function [[o_grips_search_arc()]]

@defun o_grips_search_arc w_current object x y whichone
This function checks if the pointer event occuring at ([[x]],[[y]]) is inside one of the grips of an [[o_current]] pointed arc object. If so the [[whichone]] pointed integer is set to the number of this grip and the return pointer is a pointer one this object. If the point is not inside a grip the function returns a NULL pointer and the [[whichone]] pointed integer is unset.
@end defun

An arc object has three grips :
@itemize @bullet
@item
one at the center of the arc. This grip is used to modify the radius of the arc. If this one is selected, the [[whichone]] pointed integer is set to [[ARC_RADIUS]] ;
@item
one at one end of the arc. It corresponds to the starting angle of the arc. If this one is selected, the [[whichone]] pointed integer is set to [[ARC_START_ANGLE]] ;
@item
one at the other end of the arc. It corresponds to the ending angle of the arc. If this one is selected, the [[whichone]] pointed integer is set to [[ARC_END_ANGLE]].
@end itemize

The [[x]] and [[y]] parameters are in screen units.

The [[size]] parameter is the width (and height) of the square representing a grip in screen unit.

<<o_grips.c : o_grips_search_arc()>>=
OBJECT *
o_grips_search_arc(TOPLEVEL *w_current, OBJECT *o_current,
				   int x, int y, int size, int *whichone)
{
  int centerx, centery, radius, start_angle, end_angle;
  int left, top, right, bottom;
  int x2size;
  double tmp;

  centerx     = o_current->arc->screen_x;
  centery     = o_current->arc->screen_y;
  radius      = o_current->arc->screen_width / 2;
  start_angle = o_current->arc->start_angle;
  end_angle   = o_current->arc->end_angle;

  /* width/height of the grip */
  x2size = 2 * size;

  /* check the grip on the center of the arc */
  left   = centerx - size;
  top    = centery - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = ARC_RADIUS;
    return(o_current);
  }

  /* check the grip at the start angle of the arc */
  tmp = ((double) start_angle) * M_PI / 180;
  left   = centerx + radius * cos(tmp) - size;
  top    = centery - radius * sin(tmp) - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = ARC_START_ANGLE;
    return(o_current);
  }

  /* check the grip at the end angle of the arc */
  tmp = ((double) start_angle + end_angle) * M_PI / 180;
  left   = centerx + radius * cos(tmp) - size;
  top    = centery - radius * sin(tmp) - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = ARC_END_ANGLE;
    return(o_current);
  }

  return NULL;
}

@ %def o_grips_search_arc


@section Function [[o_grips_start_arc()]]

@defun o_grips_start_arc w_current o_current x y whichone
This function initializes the grip motion process for an arc. From the [[o_current]] pointed object, it stores into the TOPLEVEL structure the coordinates of the center, the radius and the two angle that describes an arc. These variables are used in the grip process.
@end defun

The coordinates of the center of the arc on x- and y-axis are stored into the [[loc_x]] and [[loc_y]] fields of the TOPLEVEL structure in screen unit.

The radius of the center is stored into the [[distance]] field of the TOPLEVEL structure in screen unit.

The two angles describing the arc on a circle are stored into the [[start_x]] for the starting angle and [[start_y]] for the ending angle. These angles are expressed in degrees.

Depending on which grips has been selected on the arc, the corresponding variables in its original state is duplicated in [[last_x]] and/or [[last_y]] of the TOPLEVEL structure.

<<o_grips.c : o_grips_start_arc()>>=
void
o_grips_start_arc(TOPLEVEL *w_current, OBJECT *o_current,
				  int x, int y, int whichone)
{
  w_current->last_drawb_mode = -1;

  /* erase the arc before */
  o_arc_erase(w_current, o_current);

  /* describe the arc with TOPLEVEL variables */
  /* center */
  w_current->start_x = o_current->arc->screen_x;
  w_current->start_y = o_current->arc->screen_y;
  /* radius */
  w_current->distance = o_current->arc->screen_width / 2;
  /* angles */
  w_current->loc_x = o_current->arc->start_angle;
  w_current->loc_y = o_current->arc->end_angle;

  /* draw the first temporary arc */
  o_arc_rubberarc_xor(w_current);
	
}

@ %def o_grips_start_arc


@section Function [[o_grips_motion_arc()]]

@defun o_grips_motion_arc w_current o_current x y whichone
This function is the refreshing part of the grip motion process. It is called whenever the position of the pointer is changed, therefore requiring the TOPLEVEL variables to be updated.
Depending on the grip selected and moved, the temporary TOPLEVEL variables are changed according to the current position of the pointer.
@end defun

If the grip at the center of the arc has been moved - modifying the radius of the arc -, the [[w_current->distance]] field is updated. To increase the radius of the arc, the user must drag the grip to the right of the center. To decrease the radius of the arc, the user must drag the grip to the left of the center. Negative radius can not be obtained.

If one of the end of arc grip has been moved - modifying the arc describing the arc -, the [[w_current->start_x]] or [[w_current->start_y]] are updated according to which of the grip has been selected.

<<o_grips.c : o_grips_motion_arc()>>=
void
o_grips_motion_arc(TOPLEVEL *w_current, int x, int y, int whichone)
{
	o_arc_rubberarc(w_current, x, y, whichone);

}

@ %def o_grips_motion_arc


@section Function [[o_grips_end_arc()]]

@defun o_grips_end_arc w_current o_current whichone
This function ends the grips process specific to an arc object. It erases the old arc and write back to the object the new parameters of the arc. Depending on the grip selected and moved, the right fields are updated. The function handles the conversion from screen unit to world unit before updating and redrawing.
@end defun

If the grip at the center of the arc has been moved - modifying the radius of the arc -, the new radius is calculated expressed in world unit (the center is unchanged). It is updated with the function [[o_arc_modify()]].

If one of the end of arc grip has been moved - modifying one of the angles describing the arc -, this angle is updated with the [[o_arc_modify()]] function.

<<o_grips.c : o_grips_end_arc()>>=
void
o_grips_end_arc(TOPLEVEL *w_current, OBJECT *o_current, int whichone)
{
  int arg1, arg2;

  /* erase the temporary arc */
  o_arc_rubberarc_xor(w_current);

  /* determination of the parameters to give to o_arc_modify() */
  switch(whichone) {
    case ARC_RADIUS:
      /* convert the radius in world coords */
      arg1 = WORLDabs(w_current, w_current->distance);
      /* second parameter is not used */
      arg2 = -1;
      break;
		  
    case ARC_START_ANGLE:
      /* get the start angle from w_current */
      arg1 = w_current->loc_x;
      /* second parameter is not used */
      arg2 = -1;
      break;

    case ARC_END_ANGLE:
      /* get the end angle from w_current */
      arg1 = w_current->loc_y;
      /* second parameter is not used */
      arg2 = -1;
      break;

    default:
      return;
  }

  /* modify the arc with the parameters determined above */
  o_arc_modify(w_current, o_current, arg1, arg2, whichone);

  /* display the new arc */
  o_redraw_single(w_current, o_current);

}

@ %def o_grips_end_arc


@section Function [[o_grips_search_box()]]

@defun o_grips_search_box w_current o_current x y whichone
This function checks if the pointer event occuring at ([[x]],[[y]]) is inside one of the grips of the [[o_current]] pointed box object. 
If so, the [[whichone]] pointed integer is set to the identifier of this grip and the returned pointer is a pointer on this object. 
If the point is not inside a grip the function returns a NULL pointer and the [[whichone]] pointed integer is unset.
@end defun

A box object has four grips : one at each corner of the box. The identifiers of each corner are [[BOX_UPPER_LEFT]], [[BOX_UPPER_RIGHT]], [[BOX_LOWER_LEFT]] and [[BOX_LOWER_RIGHT]].

The [[x]] and [[y]] parameters are in screen units.

The [[size]] parameter is half the width (and half the height) of the square representing a grip in screen unit.

<<o_grips.c : o_grips_search_box()>>=
OBJECT *
o_grips_search_box(TOPLEVEL *w_current, OBJECT *o_current,
				   int x, int y, int size, int *whichone)
{
  int left, right, top, bottom;
  int x2size;

  /* width/height of the grip */
  x2size = 2 * size;

  /* inside upper left grip ? */
  left   = o_current->box->screen_upper_x - size;
  top    = o_current->box->screen_upper_y - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = BOX_UPPER_LEFT;
    return(o_current);
  }

  /* inside lower right grip ? */
  left   = o_current->box->screen_lower_x - size;
  top    = o_current->box->screen_lower_y - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = BOX_LOWER_RIGHT;
    return(o_current);
  }

  /* inside upper right grip ? */
  left   = o_current->box->screen_lower_x - size;
  top    = o_current->box->screen_upper_y - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = BOX_UPPER_RIGHT;
    return(o_current);
  }

  /* inside lower left grip ? */
  left   = o_current->box->screen_upper_x - size;
  top    = o_current->box->screen_lower_y - size;
  right  = left + x2size;
  bottom = top  + x2size;
  if (inside_region(left, top, right, bottom, x, y)) {
    *whichone = BOX_LOWER_LEFT;
    return(o_current);
  }

  return NULL;
}

@ %def o_grips_search_box


@section Function [[o_grips_start_box()]]

@defun o_grips_start_box w_current o_current x y whichone
This function initializes the grip motion process for a box. From the [[o_current]] pointed object, it stores into the TOPLEVEL structure the .... These variables are used in the grip process.
@end defun

The function first erases the grips.

The coordinates of the selected corner are put in ([[w_current->last_x]],[[w_current->last_y]]).

The coordinates of the opposite corner go in ([[w_current->start_x]],[[w_current->start_y]]). They are not suppose to change during the action.

<<o_grips.c : o_grips_start_box()>>=
void
o_grips_start_box(TOPLEVEL *w_current, OBJECT *o_current,
				  int x, int y, int whichone)
{
  w_current->last_drawb_mode = -1;
	
  /* erase the box before */
  o_box_erase(w_current, o_current);

  /* (last_x,last_y)    is the selected corner */
  /* (start_x, start_y) is the opposite corner */
  switch(whichone) {
    case BOX_UPPER_LEFT: 
      w_current->last_x  = o_current->box->screen_upper_x;
      w_current->last_y  = o_current->box->screen_upper_y;
      w_current->start_x = o_current->box->screen_lower_x;
      w_current->start_y = o_current->box->screen_lower_y;
      break;
    case BOX_LOWER_RIGHT: 
      w_current->last_x  = o_current->box->screen_lower_x;
      w_current->last_y  = o_current->box->screen_lower_y;
      w_current->start_x = o_current->box->screen_upper_x;
      w_current->start_y = o_current->box->screen_upper_y;
      break;
    case BOX_UPPER_RIGHT: 
      w_current->last_x  = o_current->box->screen_lower_x;
      w_current->last_y  = o_current->box->screen_upper_y;
      w_current->start_x = o_current->box->screen_upper_x;
      w_current->start_y = o_current->box->screen_lower_y;
      break;
    case BOX_LOWER_LEFT: 
      w_current->last_x  = o_current->box->screen_upper_x;
      w_current->last_y  = o_current->box->screen_lower_y;
      w_current->start_x = o_current->box->screen_lower_x;
      w_current->start_y = o_current->box->screen_upper_y;
      break;
    default:
      return; /* error */
  }

  /* draw the first temporary box */
  o_box_rubberbox_xor(w_current);

}

@ %def o_grips_start_box


@section Function [[o_grips_motion_box()]]

@defun o_grips_motion_box w_current x y whichone
This function is the refreshing part of the grip motion process. It is called whenever the position of the pointer is changed, therefore requiring the TOPLEVEL variables to be updated.
Depending on the grip selected and moved, the temporary TOPLEVEL variables are changed according to the current position of the pointer and the modifications temporary drawn.
@end defun

This function only makes a call to [[o_box_rubberbox()]] that updates the TOPLEVEL variables, erase the previous temporary box and draw the new temporary box.

<<o_grips.c : o_grips_motion_box()>>=
void
o_grips_motion_box(TOPLEVEL *w_current, int x, int y, int whichone)
{
	/* erase, update and draw the temporary box */
	o_box_rubberbox(w_current, x, y);

}

@ %def o_grips_motion_box


@section Function [[o_grips_end_box()]]

@defun o_grips_end_box w_current o_current whichone
@end defun

<<o_grips.c : o_grips_end_box()>>=
void
o_grips_end_box(TOPLEVEL *w_current, OBJECT *o_current, int whichone)
{
	int box_width, box_height;
	int x, y;

	<<o_grips_end_box() : get the new coordinates of the box>>
	
	<<o_grips_end_box() : check the new width and height>>

	<<o_grips_end_box() : modify the box object>>

	<<o_grips_end_box() : erase the temporary box and draw the modified box>>

}

@ %def o_grips_end_box



<<o_grips_end_box() : get the new coordinates of the box>>=
box_width  = GET_BOX_WIDTH (w_current);
box_height = GET_BOX_HEIGHT(w_current);

@ 


<<o_grips_end_box() : check the new width and height>>=
/* don't allow zero width/height boxes
 * this ends the box drawing behavior 
 * we want this? hack */
if ((box_width == 0) && (box_height == 0))
{
	w_current->start_x = (-1);
	w_current->start_y = (-1);
	w_current->last_x  = (-1);
	w_current->last_y  = (-1);
	
	w_current->inside_action=0;
	w_current->event_state = SELECT;
	
	i_update_status(w_current, "Select Mode");
	o_redraw_single(w_current, o_current);
	
	return;
}

@ 


<<o_grips_end_box() : modify the box object>>=
SCREENtoWORLD(w_current, 
			  w_current->last_x, w_current->last_y,
			  &x, &y);
x = snap_grid(w_current, x);
y = snap_grid(w_current, y);

o_box_modify(w_current, o_current, x, y, whichone);

@ 


<<o_grips_end_box() : erase the temporary box and draw the modified box>>=
/* erase the temporary box */
o_box_rubberbox_xor(w_current);

/* draw the modified box */
o_redraw_single(w_current, o_current);

@


@section Function [[o_grips_search_circle()]]

@defun o_grips_search_circle w_current o_current x y size whichone
This function determines if the ([[x]],[[y]]) point is inside one of the grip of the circle object [[o_current]].
It computes the area covered by each grip and check if ([[x]],[[y]]) is in one of these areas.
If the event occured in one of the grip, a pointer on the object is returned and [[*whichone]] is set to the identifier of the grip. If not, the function returns a [[NULL]] pointer and [[*whichone]] is unchanged.
@end defun

The parameter [[size]] is half the size of the grip in screen units.

A circle has only one grip on the lower right corner of the box it is inscribed in. Moving this grip change the radius of the circle. The identifier of this grip is [[CIRCLE_RADIUS]].

<<o_grips.c : o_grips_search_circle()>>=
OBJECT *
o_grips_search_circle(TOPLEVEL *w_current, OBJECT *o_current,
					  int x, int y, int size, int *whichone)
{
	int left, top, right, bottom;
	int x1, y1;
	int x2size;
	
	/* width/height of the grip */
	x2size = 2 * size;

        /* check the grip for radius */	
	x1 = o_current->circle->screen_x + o_current->circle->screen_radius;
	y1 = o_current->circle->screen_y + o_current->circle->screen_radius;
	left   = x1 - size;
	top    = y1 - size;
	right  = left + x2size;
	bottom = top  + x2size;
	if (inside_region(left, top, right, bottom, x, y)) {
		/* printf("found something 0!\n"); */
		*whichone = CIRCLE_RADIUS;
		return(o_current);
	}

	return NULL;
}
	
@ %def o_grips_search_circle
	

@section Function [[o_grips_start_circle()]]

@defun o_grips_start_box w_current o_current x y whichone
This function initializes the grip motion process for a circle. From the [[o_current]] pointed object, it stores into the TOPLEVEL structure the coordinate of the center and the radius. These variables are used in the grip process.
@end defun

The function first erases the grips.

The coordinates of the center are put in ([[w_current->start_x]],[[w_current->start_y]]). They are not suppose to change during the action.

The coordinates of the point on the circle to the right of the center go in ([[w_current->last_x]],[[w_current->last_y]]). 

<<o_grips.c : o_grips_start_circle()>>=
void
o_grips_start_circle(TOPLEVEL *w_current, OBJECT *o_current,
					 int x, int y, int whichone)
{
	w_current->last_drawb_mode = -1;

	/* erase the circle before */
	o_circle_erase(w_current, o_current);

	/* describe the circle with TOPLEVEL variables */
	/* (start_x, start_y) is the center of the circle */
	w_current->start_x  = o_current->circle->screen_x;
	w_current->start_y  = o_current->circle->screen_y;
	/* (last_x,last_y)    is the point on circle on the right of center */
	w_current->last_x   = o_current->circle->screen_x + o_current->circle->screen_radius;
	w_current->last_y   = o_current->circle->screen_y;
	/* distance           is the radius of the circle */
	w_current->distance = o_current->circle->screen_radius;

	/* draw the first temporary circle */
	o_circle_rubbercircle_xor(w_current);

}
	
@ %def o_grips_start_circle	

	
@section Function [[o_grips_motion_circle()]]

@defun o_grips_motion_circle w_current x y whichone
This function is the refreshing part of the grip motion process. It is called whenever the position of the pointer is changed, therefore requiring the TOPLEVEL variables to be updated.
Depending on the grip selected and moved, the temporary TOPLEVEL variables are changed according to the current position of the pointer and the modifications temporary drawn.
@end defun

This function only makes a call to [[o_circle_rubbercircle()]] that updates the TOPLEVEL variables, erase the previous temporary circle and draw the new temporary circle.

<<o_grips.c : o_grips_motion_circle()>>=
void
o_grips_motion_circle(TOPLEVEL *w_current, int x, int y, int whichone)
{
	/* erase, update and draw the temporary circle */
	o_circle_rubbercircle(w_current, x, y);

}

@ %def o_grips_motion_circle


@section Function [[o_grips_end_circle()]]

@defun o_grips_end_circle w_current o_current whichone
This function ends the process of modifying the radius of the circle object [[*o_current]].
The modified circle is finally normally drawn.
@end defun

A circle with a null radius is not allowed. In this case, the process is stopped and the circle is left unchanged.

The last value of the radius is in [[w_current->distance]] in screen units.

<<o_grips.c : o_grips_end_circle()>>=
void
o_grips_end_circle(TOPLEVEL *w_current, OBJECT *o_current, int whichone)
{
	int radius;

	/* erase the temporary circle */
	o_circle_rubbercircle_xor(w_current);

    /* don't allow zero radius circles
     * this ends the circle drawing behavior 
     * we want this? hack */
    if ((w_current->start_x == w_current->last_x) &&
        (w_current->start_y == w_current->last_y))
	{
		w_current->start_x = (-1);
		w_current->start_y = (-1);
		w_current->last_x  = (-1);
		w_current->last_y  = (-1);
		
		w_current->inside_action = 0;

		/* return to select mode */
		w_current->event_state = SELECT;
		i_update_status(w_current, "Select Mode");

		o_redraw_single(w_current, o_current);
		return;
	}

	/* convert the radius in world unit */
	radius = WORLDabs(w_current, w_current->distance);

	/* modify the radius of the circle */
	o_circle_modify(w_current, o_current, radius, -1, CIRCLE_RADIUS);

	/* display the new circle */
	o_redraw_single(w_current, o_current);
	
}

@ %def o_grips_end_circle


@section Function [[o_grips_search_line()]]

@defun o_grips_search_line w_current o_current x y size whichone
This function determines if the ([[x]],[[y]]) point is inside one of the grip of the line object [[o_current]].
It computes the area covered by each grip and check if ([[x]],[[y]]) is in one of these areas. 
If the event occured in one of its grip, a pointer on the object is returned and [[*whichone]] is set to the identifier of the grip. If not, the function returns [[NULL]] pointer and [[*whichone]] is unchanged.
@end defun

The parameter [[size]] is half the size of the grip in screen units.

<<o_grips.c : o_grips_search_line()>>=
OBJECT *
o_grips_search_line(TOPLEVEL *w_current, OBJECT *o_current,
					int x, int y, int size, int *whichone)
{
	int left, top, right, bottom;
	int x2size;

	/* width/height of the grip */
	x2size = 2 * size;

	/* check the grip on the end of line 1 */
	left = o_current->line->screen_x[LINE_END1] - size;
	top  = o_current->line->screen_y[LINE_END1] - size;
	right  = left + x2size;
	bottom = top  + x2size;
	if (inside_region(left, top, right, bottom, x, y)) {
		*whichone = LINE_END1;
		return(o_current);
	}

	/* check the grip on the end of line 2 */
	left = o_current->line->screen_x[LINE_END2] - size;
	top  = o_current->line->screen_y[LINE_END2] - size;
	right  = left + x2size;
	bottom = top  + x2size;
	if (inside_region(left, top, right, bottom, x, y)) {
		*whichone = LINE_END2;
		return(o_current);
	}

	return NULL;
}

@ %def o_grips_search_line


@section Function [[o_grips_start_line()]]

@defun o_grips_start_line w_current o_current x y whichone
This function starts the move of one of the two grips of the line object [[o_current]].
The line and its grips are first erased. The move of the grips is materializd with a temporary line in selection color drawn over the sheet with an xor-function.
@end defun

During the move of the grip, the line is described by ([[w_current->start_x]],[[w_current->start_y]]) and ([[w_current->last_x]],[[w_current->last_y]]).

The line end that corresponds to the moving grip is in ([[w_current->last_x]],[[w_current->last_y]]).

<<o_grips.c : o_grips_start_line()>>=
void
o_grips_start_line(TOPLEVEL *w_current, OBJECT *o_current,
				   int x, int y, int whichone)
{
	w_current->last_drawb_mode = -1;

	/* erase the line before */
	o_line_erase(w_current, o_current);

	/* describe the line with TOPLEVEL variables */
	w_current->last_x  = o_current->line->screen_x[whichone];
	w_current->last_y  = o_current->line->screen_y[whichone];
	w_current->start_x = o_current->line->screen_x[!whichone];
	w_current->start_y = o_current->line->screen_y[!whichone];
	
	/* draw the first temporary line */
	o_line_rubberline_xor(w_current);

}

@ %def o_grips_start_line


@section Function [[o_grips_motion_line()]]

@defun o_grips_motion_line w_current x y whichone
The [[o_grips_motion_line()]] function is called during the move of the grip to update the temporary line drawn under the mouse pointer.
The current position of the mouse is in [[x]] and [[y]] in screen coords.
@end defun

<<o_grips.c : o_grips_motion_line()>>=
void
o_grips_motion_line(TOPLEVEL *w_current, int x, int y, int whichone)
{
	/* erase, update and draw the temporary line */
	o_line_rubberline(w_current, x, y);
	
}

@ %def o_grips_motion_line


@section Function [[o_grips_end_line()]]

@defun o_grips_end_line w_current o_current whichone
This function ends the process of modifying one end of the line object [[*o_current]].
This end is identified by [[whichone]]. The line object is modified according to the [[whichone]] parameter and the last position of the line end.
The modified line is finally normally drawn.
@end defun

A line with a null width, i.e. when both ends are identical, is not allowed. In this case, the process is stopped and the line unchanged.

<<o_grips.c : o_grips_end_line()>>=
void
o_grips_end_line(TOPLEVEL *w_current, OBJECT *o_current, int whichone)
{
	int x, y;
	
	/* erase the temporary line */
	o_line_rubberline_xor(w_current);
	
    /* don't allow zero length nets / lines / pins
     * this ends the net drawing behavior 
     * we want this? hack */
    if ((w_current->start_x == w_current->last_x) &&
        (w_current->start_y == w_current->last_y)) {
          w_current->start_x = (-1);
          w_current->start_y = (-1);
          w_current->last_x  = (-1);
          w_current->last_y  = (-1);
		  
          w_current->inside_action=0;

		  /* return to select mode */
          w_current->event_state = SELECT;
          i_update_status(w_current, "Select Mode");
		  
          o_redraw_single(w_current, o_current);
          return;
        }

	/* convert the line end coords in world unit */
	SCREENtoWORLD(w_current, 
				  w_current->last_x, w_current->last_y,
				  &x, &y);
	x = snap_grid(w_current, x);
	y = snap_grid(w_current, y);

	/* modify the right line end according to whichone */
	o_line_modify(w_current, o_current, x, y, whichone);

	/* display the new line */
	o_redraw_single(w_current, o_current);

}
	
@ %def o_grips_end_line


@section Function [[o_grips_size()]]

@defun o_grips_size w_current
According to the current zoom level, the function returns half the width and height of a grip in screen units.
@end defun

[[GRIP_SIZE1]] and [[GRIP_SIZE2]] and [[GRIP_SIZE3]] are macros defined in libgeda [[defines.h]]. They are the half width/height of a grip in world unit for a determined range of zoom factors.

<<o_grips.c : o_grips_size()>>=
int
o_grips_size(TOPLEVEL *w_current)
{
	int factor, size;
	
	factor = (int) w_current->page_current->to_world_x_constant;
	if (factor > SMALL_ZOOMFACTOR1) {
		/* big zoom factor : small size converted to screen unit */
		size = SCREENabs(w_current, GRIP_SIZE1);
	} else if (factor > SMALL_ZOOMFACTOR2) {
		/* medium zoom factor : medium size converted to screen unit */
		size = SCREENabs(w_current, GRIP_SIZE2);
	} else {
		/* small zoom factor : big size converted to screen unit */
		size = SCREENabs(w_current, GRIP_SIZE3);
	}

	return size;
}

@ %def o_grips_size


@section Function [[o_grips_draw()]]

@defun o_grips_draw w_current o_current
This function draws a grip centered at ([[x]],[[y]]). Its color is either the selection color or the overriding color from [[w_current->override_color]].
@end defun

The size of the grip depends on the current zoom factor.

[[x]] and [[y]] are in screen unit.

<<o_grips.c : o_grips_draw()>>=
void
o_grips_draw(TOPLEVEL *w_current, int x, int y)
{
	GdkColor *color;
	int size, x2size;
	
	<<o_grips_draw() : select the size of the grip>>

	<<o_grips_draw() : select the color>>

	<<o_grips_draw() : draw the grip at (x,y)>>

}

@ %def o_grips_draw


Depending on the current zoom level, the size of the grip is determined. [[size]] is half the width and height of the grip and [[x2size]] is the full width and height of the grip.

<<o_grips_draw() : select the size of the grip>>=
/* size is half the width of grip */
size = o_grips_size(w_current);
/* x2size is full width */
x2size = 2 * size;

@ 


The grip can be displayed or erased : if [[w_current->override_color]] is not set the grip is drawn with the selection color ; if [[w_current->override_color]] is set then the color it refers it is used. This way the grip can be erased if this color is the background color.

<<o_grips_draw() : select the color>>=
if (w_current->override_color != -1 ) {
	/* override : use the override_color instead */
	color = x_get_color(w_current->override_color);
} else {
	/* use the normal selection color */
	color = x_get_color(w_current->select_color);
}
/* set the color for the grip */
gdk_gc_set_foreground(w_current->gc, color);

/* set the line options for grip : solid, 1 pix wide */
gdk_gc_set_line_attributes(w_current->gc, 0, GDK_LINE_SOLID,
						   GDK_CAP_BUTT, GDK_JOIN_MITER);

@ 

A grip is a hollow square centered at ([[x]],[[y]]) with a width/height of [[x2size]].

<<o_grips_draw() : draw the grip at (x,y)>>=
/* draw the grip in window */
gdk_draw_rectangle(w_current->window, w_current->gc, FALSE,
				   x - size, y - size, x2size, x2size);
/* draw the grip in backingstore */
gdk_draw_rectangle(w_current->backingstore, w_current->gc, FALSE,
				   x - size, y - size, x2size, x2size);

@ 


@section Function [[o_grips_erase()]]

@defun o_grips_erase w_current o_current
This function erases a grip centered at ([[x]],[[y]]). 
The size of the grip depends on the current zoom factor.
@end defun

The grip is erased by drawing with the background color over the visible grip.

[[x]] and [[y]] are in screen unit.

<<o_grips.c : o_grips_erase()>>=
void
o_grips_erase(TOPLEVEL *w_current, int x, int y)
{
	/* set overriding color */
    w_current->override_color = w_current->background_color;
	/* draw a grip with backgound color : erase grip */
    o_grips_draw(w_current, x, y);
	/* return to default */
    w_current->override_color = -1;
}

@ %def o_grips_erase



