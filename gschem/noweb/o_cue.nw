@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_cue.c,,,Top
@chapter File @file{o_cue.c}

@section File header

<<o_cue.c : *>>=
<<o_cue.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_cue.nw instead */

/* rename file to be o_cue.c TODO */

<<o_cue.c : include directives>>
<<o_cue.c : o_cue_redraw_all()>>
<<o_cue.c : o_cue_draw_lowlevel()>>
<<o_cue.c : o_cue_erase_lowlevel()>>
<<o_cue.c : o_cue_draw_lowlevel_midpoints()>>
<<o_cue.c : o_cue_draw_single()>>
<<o_cue.c : o_cue_erase_single()>>
<<o_cue.c : o_cue_undraw()>>
<<o_cue.c : o_cue_undraw_complex()>>
<<o_cue.c : o_cue_draw_list()>>
<<o_cue.c : o_cue_undraw_list()>>
<<o_cue.c : o_cue_undraw_objects()>>

@


<<o_cue.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<o_cue.c : include directives>>=
#include <config.h>
#include <stdio.h>
#include <string.h>

#include <libgeda/libgeda.h>

#include "../include/x_states.h"
#include "../include/prototype.h"
#include "../include/globals.h"

@


@section Function @code{o_cue_redraw_all()}

@defun o_cue_redraw_all w_current head
@end defun

<<o_cue.c : o_cue_redraw_all()>>=
void
o_cue_redraw_all(TOPLEVEL *w_current, OBJECT *head)
{
  OBJECT *o_current;

  o_current = head;
  while(o_current != NULL) {
    switch(o_current->type) {
      case(OBJ_NET):
      case(OBJ_BUS):
      case(OBJ_PIN):
        o_cue_draw_single(w_current, o_current);
        break;

      case(OBJ_COMPLEX):
        o_cue_redraw_all(w_current, o_current->complex->prim_objs);
	break;

    }
    
    o_current = o_current->next;
  }
}


@ %def o_cue_redraw_all


@section Function @code{o_cue_draw_lowlevel()}

@defun o_cue_draw_lowlevel w_current object whichone
@end defun

<<o_cue.c : o_cue_draw_lowlevel()>>=
void
o_cue_draw_lowlevel(TOPLEVEL *w_current, OBJECT *object, int whichone)
{
  int x, y, screen_x, screen_y;
  GList *cl_current;
  CONN *conn;
  int type, count = 0;
  int done = FALSE;
  int size, x2size;
  
  x = object->line->x[whichone];
  y = object->line->y[whichone];

  type = CONN_ENDPOINT;
  
  cl_current = object->conn_list;
  while(cl_current != NULL && !done) {
    conn = (CONN *) cl_current->data;
   
    if (conn->x == x && conn->y == y) {
#if 0
      printf("type: %d x: %d y: %d cx: %d cy: %d\n", conn->type, x, y, conn->x, conn->y);
#endif
      switch(conn->type) {
        
        case(CONN_ENDPOINT):
          count++;
          break;

        case(CONN_MIDPOINT):
          type = CONN_MIDPOINT;
          done = TRUE;
          count = 0;
          break;
      }
    }

    cl_current = cl_current->next;
  }

#if DEBUG
  printf("type: %d count: %d\n", type, count);
#endif
  
  size = SCREENabs(w_current, 30);
  x2size = 2 * size;


  if (w_current->override_color != -1 ) {
    gdk_gc_set_foreground(w_current->gc,
                          x_get_color(w_current->override_color));
  } else {
    gdk_gc_set_foreground(w_current->gc,
                          x_get_color(w_current->net_endpoint_color));
  }

  WORLDtoSCREEN(w_current, x, y, &screen_x, &screen_y);
  
  switch(type) {
    
    case(CONN_ENDPOINT):
      if (object->type == OBJ_NET) { /* only nets have these cues */
        if (count < 1) { /* Didn't find anything connected there */
          gdk_draw_rectangle(w_current->window,
                             w_current->gc, TRUE,
                             screen_x - size,
                             screen_y - size,
                             x2size,
                             x2size);
          gdk_draw_rectangle(w_current->backingstore,
                             w_current->gc, TRUE,
                             screen_x - size,
                             screen_y - size,
                             x2size,
                             x2size);
        
        } else if (count >= 2) {
          /* draw circle */
          size = SCREENabs(w_current, 60);
          gdk_draw_arc(w_current->window, w_current->gc,
                       TRUE,
                       screen_x - size / 2,
                       screen_y - size / 2,
                       size, size, 0, FULL_CIRCLE);
          gdk_draw_arc(w_current->backingstore,
                       w_current->gc, TRUE,
                       screen_x - size / 2,
                       screen_y - size / 2,
                       size, size, 0, FULL_CIRCLE);

        }
      }
      break;

    case(CONN_MIDPOINT):
  
      /* draw circle */
      size = SCREENabs(w_current, 60);
      gdk_draw_arc(w_current->window, w_current->gc,
                   TRUE,
                   screen_x - size / 2,
                   screen_y - size / 2,
                   size, size, 0, FULL_CIRCLE);
      gdk_draw_arc(w_current->backingstore,
                   w_current->gc, TRUE,
                   screen_x - size / 2,
                   screen_y - size / 2,
                   size, size, 0, FULL_CIRCLE);

      break;

      /* here is where you draw bus rippers */
      
  }
  
}


@ %def o_cue_draw_lowlevel



@section Function @code{o_cue_erase_lowlevel()}

@defun o_cue_erase_lowlevel w_current object whichone
@end defun

<<o_cue.c : o_cue_erase_lowlevel()>>=
/* This function erase the endpoints forcebly */
void
o_cue_erase_lowlevel(TOPLEVEL *w_current, OBJECT *object, int whichone)
{
  int x, y, screen_x, screen_y;
  int size, x2size;
  
  x = object->line->x[whichone];
  y = object->line->y[whichone];

  size = SCREENabs(w_current, 30);
  x2size = 2 * size;

  gdk_gc_set_foreground(w_current->gc,
                        x_get_color(w_current->background_color));
 
  WORLDtoSCREEN(w_current, x, y, &screen_x, &screen_y);
  
  gdk_draw_rectangle(w_current->window,
                     w_current->gc, TRUE,
                     screen_x - size,
                     screen_y - size,
                     x2size,
                     x2size);
  gdk_draw_rectangle(w_current->backingstore,
                     w_current->gc, TRUE,
                     screen_x - size,
                     screen_y - size,
                     x2size,
                     x2size);

}


@ %def o_cue_erase_lowlevel


@section Function @code{o_cue_draw_lowlevel_midpoints()}

@defun o_cue_draw_lowlevel_midpoints w_current object
@end defun

<<o_cue.c : o_cue_draw_lowlevel_midpoints()>>=
void
o_cue_draw_lowlevel_midpoints(TOPLEVEL *w_current, OBJECT *object)
{
  int x, y, screen_x, screen_y;
  GList *cl_current;
  CONN *conn;
  int size;

  if (w_current->override_color != -1 ) {
    gdk_gc_set_foreground(w_current->gc,
                          x_get_color(w_current->override_color));
  } else {
    gdk_gc_set_foreground(w_current->gc,
                          x_get_color(w_current->net_endpoint_color));
  }
  
  cl_current = object->conn_list;
  while(cl_current != NULL) {
    conn = (CONN *) cl_current->data;

    switch(conn->type) {        
      case(CONN_MIDPOINT):

        x = conn->x;
        y = conn->y;
          
        WORLDtoSCREEN(w_current, x, y, &screen_x, &screen_y);
 
        /* draw circle */
        size = SCREENabs(w_current, 60);
        gdk_draw_arc(w_current->window, w_current->gc,
                     TRUE,
                     screen_x - size / 2,
                     screen_y - size / 2,
                     size, size, 0, FULL_CIRCLE);
        gdk_draw_arc(w_current->backingstore,
                     w_current->gc, TRUE,
                     screen_x - size / 2,
                     screen_y - size / 2,
                     size, size, 0, FULL_CIRCLE);
        break;
    }
   

    cl_current = cl_current->next;
  }
}


@ %def o_cue_draw_lowlevel_midpoints


@section Function @code{o_cue_draw_single()}

@defun o_cue_draw_single w_current object
@end defun

<<o_cue.c : o_cue_draw_single()>>=
void
o_cue_draw_single(TOPLEVEL *w_current, OBJECT *object)
{
  if (!object) {
    return;
  }

  if (object->type != OBJ_NET && object->type != OBJ_PIN &&
      object->type != OBJ_BUS) {
        return;
      }

  o_cue_draw_lowlevel(w_current, object, 0);
  o_cue_draw_lowlevel(w_current, object, 1);
  o_cue_draw_lowlevel_midpoints(w_current, object);
}


@ %def o_cue_draw_single


@section Function @code{o_cue_erase_single()}

@defun o_cue_erase_single w_current object
@end defun

<<o_cue.c : o_cue_erase_single()>>=
void
o_cue_erase_single(TOPLEVEL *w_current, OBJECT *object)
{
  if (!object) {
    return;
  }

  if (object->type != OBJ_NET && object->type != OBJ_PIN &&
      object->type != OBJ_BUS) {
        return;
      }

  o_cue_erase_lowlevel(w_current, object, 0);
  o_cue_erase_lowlevel(w_current, object, 1);
  w_current->override_color = w_current->background_color;
  o_cue_draw_lowlevel_midpoints(w_current, object);
  w_current->override_color = -1;
}


@ %def o_cue_erase_single


@section Function @code{o_cue_undraw()}

@defun o_cue_undraw w_current object
@end defun

<<o_cue.c : o_cue_undraw()>>=
void
o_cue_undraw(TOPLEVEL *w_current, OBJECT *object)
{
  GList *cl_current;
  CONN *conn;

  o_cue_erase_single(w_current, object);

  cl_current = object->conn_list;
  while(cl_current != NULL) {
    conn = (CONN *) cl_current->data;

    if (conn->other_object) {
      o_redraw_single(w_current, conn->other_object);
    }

    cl_current = cl_current->next;
  }

  o_redraw_single(w_current, object);
}


@ %def o_cue_undraw


@section Function @code{o_cue_undraw_complex()}

@defun o_cue_undraw_complex w_current object
@end defun

<<o_cue.c : o_cue_undraw_complex()>>=
/* this function undraws complex objects (pass in the toplevel object) */
void
o_cue_undraw_complex(TOPLEVEL *w_current, OBJECT *object)
{
  GList *cl_current;
  CONN *conn;
  OBJECT *o_current;

  if (object->type != OBJ_COMPLEX) {
    return;
  }

  o_current = object->complex->prim_objs;
  while(o_current != NULL) {

    if (o_current->type == OBJ_PIN || o_current->type == OBJ_NET ||
        o_current->type == OBJ_BUS) {
      
      o_cue_erase_single(w_current, o_current);
      
      cl_current = o_current->conn_list;
      while(cl_current != NULL) {
        conn = (CONN *) cl_current->data;

        if (conn->other_object) {
          o_redraw_single(w_current, conn->other_object);
        }

        cl_current = cl_current->next;
      }
    }
    o_current = o_current->next;
  }

  o_redraw_single(w_current, object);
}


@ %def o_cue_undraw_complex


@section Function @code{o_cue_draw_list()}

@defun o_cue_draw_list w_current object_list
@end defun

<<o_cue.c : o_cue_draw_list()>>=
void
o_cue_draw_list(TOPLEVEL *w_current, GList *object_list)
{
  OBJECT *object;
  GList *ol_current;

  ol_current = object_list;
  while(ol_current != NULL) {
    object = (OBJECT *) ol_current->data;

    o_cue_draw_single(w_current, object);
    
    ol_current = ol_current->next;
  }
}


@ %def o_cue_draw_list


@section Function @code{o_cue_undraw_list()}

@defun o_cue_undraw_list w_current object_list
@end defun

<<o_cue.c : o_cue_undraw_list()>>=
void
o_cue_undraw_list(TOPLEVEL *w_current, GList *object_list)
{
  OBJECT *object;
  GList *ol_current;

  ol_current = object_list;
  while(ol_current != NULL) {
    object = (OBJECT *) ol_current->data;

    o_cue_undraw(w_current, object);
    
    ol_current = ol_current->next;
  }
}


@ %def o_cue_undraw_list


@section Function @code{o_cue_undraw_objects()}

@defun o_cue_undraw_objects w_current list
@end defun

<<o_cue.c : o_cue_undraw_objects()>>=
void
o_cue_undraw_objects(TOPLEVEL *w_current, OBJECT *list)
{
  OBJECT *o_current;

  o_current = list;
  while(o_current != NULL) {

    if (o_current->type == OBJ_PIN || o_current->type == OBJ_NET ||
        o_current->type == OBJ_BUS) {
      o_cue_undraw(w_current, o_current);
    }
    
    o_current = o_current->next;
  }

}


@ %def o_cue_undraw_objects
