@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File s_page.c,,,Top
@chapter File @file{s_page.c}

@section File header

<<s_page.c : *>>=
<<s_page.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/s_page.nw instead */

<<s_page.c : include directives>>
<<s_page.c : global variable>>
<<s_page.c : s_page_return_tail()>>
<<s_page.c : s_page_free()>>
<<s_page.c : s_page_free_all()>>
<<s_page.c : s_page_add()>>
<<s_page.c : s_page_print()>>
<<s_page.c : s_page_add_head()>>
<<s_page.c : s_page_free_head()>>
<<s_page.c : s_page_delete()>>
<<s_page.c : s_page_new_lowlevel()>>
<<s_page.c : s_page_new()>>
<<s_page.c : s_page_setup()>>
<<s_page.c : s_page_check_changed()>>
<<s_page.c : s_page_clear_changed()>>
<<s_page.c : s_page_goto()>>
<<s_page.c : s_page_search()>>
<<s_page.c : s_page_search_row()>>
<<s_page.c : s_page_print_all()>>
<<s_page.c : s_page_save_all()>>

@


<<s_page.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * libgeda - gEDA's library
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<s_page.c : include directives>>=
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_ASSERT_H
#include <assert.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <gtk/gtk.h>
#include <libguile.h>

#include "defines.h"
#include "struct.h"
#include "globals.h"
#include "o_types.h"

#include "../include/prototype.h"

#ifdef HAVE_LIBDMALLOC
#include <dmalloc.h>
#endif

@


<<s_page.c : global variable>>=
static int global_pid=0;

@ %def global_pid


@section Function @code{s_page_return_tail()}

@defun s_page_return_tail head
@end defun

<<s_page.c : s_page_return_tail()>>=
PAGE *
s_page_return_tail(PAGE *head)
{
  PAGE *p_current=NULL;
  PAGE *ret_struct=NULL;

  p_current = head;
  while ( p_current != NULL ) { /* goto end of list */
    ret_struct = p_current;
    p_current = p_current->next;
  }

  return(ret_struct);
}


@ %def s_page_return_tail


@section Function @code{s_page_free()}

@defun s_page_free w_current p_current
@end defun

<<s_page.c : s_page_free()>>=
/* this frees the pages associated with w_current and p_current */
/* need to change this... */
void 
s_page_free(TOPLEVEL *w_current, PAGE *p_current)
{
  /* printf("freeing\n");*/
  s_delete_list_fromstart(w_current, p_current->object_head);

  w_current->REMOVING_SEL = 1;
  s_delete_list_fromstart(w_current, p_current->complex_place_head);
  s_delete_list_fromstart(w_current, p_current->attrib_place_head);
  o_selection_destroy_all(p_current->selection2_head);
  w_current->REMOVING_SEL = 0;  

#if DEBUG
  printf("Freeing page: %s\n", p_current->page_filename);
  s_tile_print(w_current);
#endif
  s_tile_free_all(p_current);

  s_stretch_destroy_all(p_current->stretch_head);

  /* free current page undo structs */
  s_undo_free_all(w_current, p_current); 

  p_current->object_head = NULL;
  p_current->object_tail = NULL;
  p_current->object_parent = NULL;
  p_current->object_lastplace = NULL;
  p_current->selection2_head = NULL;
  p_current->selection2_tail = NULL;
  p_current->stretch_head = NULL;
  p_current->stretch_tail = NULL;

  p_current->complex_place_head = NULL;
  p_current->complex_place_tail = NULL;
  p_current->attrib_place_head = NULL;
  p_current->attrib_place_tail = NULL;

  /* ouch, deal with parents going away and the children still around */
  p_current->up = -2;
  /* p_current->down = NULL; not needed */

  if (p_current->page_filename) {
    free(p_current->page_filename);
  }

  if (p_current->next)
  p_current->next->prev = p_current->prev;

  if (p_current->prev)
  p_current->prev->next = p_current->next;


#if DEBUG
  s_tile_print(w_current);
#endif

  free(p_current);

  p_current=NULL;

  w_current->page_tail = s_page_return_tail(w_current->page_head);

#if 0 /* don't do this for now hack */ /* this is a per window free */
  o_attrib_free_current(w_current);
  o_complex_free_filename(w_current);
#endif
}


@ %def s_page_free


@section Function @code{s_page_free_all()}

@defun s_page_free_all w_current p_tail
@end defun

<<s_page.c : s_page_free_all()>>=
/* should only be called when you are finishing up */
void
s_page_free_all(TOPLEVEL *w_current, PAGE *p_tail)
{
  PAGE *p_current;
  PAGE *p_prev;

  p_current = p_tail;

  while (p_current != NULL && p_current->pid != -1) {
    p_prev = p_current->prev;
    w_current->page_current = p_current;
#if DEBUG
    printf("about to free %d\n", p_current->pid);
#endif
    s_page_free(w_current, p_current);
    p_current = p_prev;
  }	

  /* Now free the head */
  s_page_free_head(w_current, w_current->page_head);
  w_current->page_head = NULL;
  w_current->page_tail = NULL;
}


@ %def s_page_free_all


@section Function @code{s_page_add()}

@defun s_page_add w_current p_tail page_filename
@end defun

<<s_page.c : s_page_add()>>=
/* p_current is the current tail of pages */
PAGE *
s_page_add(TOPLEVEL *w_current, PAGE *p_tail, char *page_filename)
{
  PAGE *p_new;
  char *pwd;

  /* be sure to free this somewhere */
  p_new = (PAGE *) malloc(sizeof(PAGE)); 

  p_new->CHANGED = 0;
  pwd = getcwd(NULL, 1024);

  /* big assumption here that page_filename isn't null */
  if (g_path_is_absolute (page_filename)) {
    p_new->page_filename = g_strdup (page_filename);
  } else {
    p_new->page_filename = g_strconcat (pwd,
                                        G_DIR_SEPARATOR_S,
                                        page_filename,
                                        NULL);
  }

  free(pwd);
	
  p_new->coord_aspectratio = (float) w_current->init_right /
  (float) w_current->init_bottom;

  p_new->up = -2;
  /* p_new->down = NULL; not needed */
  p_new->page_control = 0;

  /* Init tile array, has to be here since we need w_current */
  /* cannot be in s_page_setup or s_page_new */
  s_tile_init(w_current, p_new);

  if (p_tail == NULL) {
    p_new->pid = -1; /* head node */
    p_new->prev = NULL;
    p_new->next = NULL;
    return(p_new);
  } else {
    p_new->pid = global_pid++;
    p_new->prev = p_tail;
    p_new->next = NULL;
    p_tail->next = p_new;
    return(p_tail->next);
  }
}


@ %def s_page_add


@section Function @code{s_page_print()}

@defun s_page_print p_list
@end defun

<<s_page.c : s_page_print()>>=
void
s_page_print(PAGE *p_list) 
{
  PAGE *p_current;

  p_current = p_list;

  while (p_current != NULL) {

    printf("pid: %d\n", p_current->pid);
    printf("page_filename: %s\n", p_current->page_filename);

    p_current = p_current->next;
  }
}


@ %def s_page_print


@section Function @code{s_page_add_head()}

@defun s_page_add_head w_current
@end defun

<<s_page.c : s_page_add_head()>>=
void
s_page_add_head(TOPLEVEL *w_current)
{
  w_current->page_head = w_current->page_tail = s_page_add(
                                                           w_current,
                                                           NULL, 
                                                           "page_head");

  /* this is important so that page_next and page_prev ignore the 
   * page head node 
   */
  w_current->page_head->page_control = -1; 
}


@ %def s_page_add_head


@section Function @code{s_page_free_head()}

@defun s_page_free_head w_current p_head
@end defun

<<s_page.c : s_page_free_head()>>=
void
s_page_free_head(TOPLEVEL *w_current, PAGE *p_head)
{
	if (p_head->page_filename) {
		free(p_head->page_filename);
	}
	
	free(p_head);
	p_head = NULL;
}


@ %def s_page_free_head


@section Function @code{s_page_delete()}

@defun s_page_delete 
@end defun

<<s_page.c : s_page_delete()>>=
/* needed ? */
void
s_page_delete()
{

}


@ %def s_page_delete


@section Function @code{s_page_new_lowlevel()}

@defun s_page_new_lowlevel w_current page_filename
@end defun

<<s_page.c : s_page_new_lowlevel()>>=
PAGE *
s_page_new_lowlevel(TOPLEVEL *w_current, char *page_filename)
{
  /* Now create a blank page */
  w_current->page_tail = s_page_add(w_current,
                                    w_current->page_tail, page_filename);

  /* setup page_current link */
  w_current->page_current = w_current->page_tail;

  s_page_setup(w_current->page_current);
  w_current->page_current->object_lastplace=NULL;
  w_current->page_current->object_selected=NULL;

  set_window(w_current, w_current->init_left, w_current->init_right,
             w_current->init_top, w_current->init_bottom);

  return(NULL);
}


@ %def s_page_new_lowlevel


@section Function @code{s_page_new()}

@defun s_page_new w_current page_filename
@end defun

<<s_page.c : s_page_new()>>=
PAGE *
s_page_new(TOPLEVEL *w_current, char *page_filename)
{
  PAGE *return_value;

  return_value = s_page_search(w_current, page_filename);

  if (return_value) {
    s_log_message("Schematic [%s] already loaded\n", page_filename);
    return(return_value);
  }

  return_value = s_page_new_lowlevel(w_current, page_filename);

  return(return_value);
}


@ %def s_page_new


@section Function @code{s_page_setup()}

@defun s_page_setup p_current
@end defun

<<s_page.c : s_page_setup()>>=
void
s_page_setup(PAGE *p_current)
{

  /* First one to setup head */
  p_current->object_head = s_basic_init_object("object_head");
  p_current->object_head->type = OBJ_HEAD;

  /* new selection mechanism */
  p_current->selection2_head = p_current->selection2_tail = 
  o_selection_new_head();

  /* net/pin/bus stretch when doing moves */
  p_current->stretch_head = p_current->stretch_tail = s_stretch_new_head();

  p_current->complex_place_tail = p_current->complex_place_head = 
  s_basic_init_object("complex_place_head");
  p_current->complex_place_tail->type = OBJ_HEAD;

  /* add p_attrib and p_attached_to */
  p_current->attrib_place_tail = p_current->attrib_place_head = 
  s_basic_init_object("attrib_place_head");
  p_current->attrib_place_tail->type = OBJ_HEAD;
	
  /* do this just to be sure that object tail is truely correct */
  p_current->object_tail = return_tail(p_current->object_head);

  /* setup parent to point to list */
  /* this is used for attributes so */
  /* that we know which list to search */
  p_current->object_parent = p_current->object_head; 

  /* Init undo struct pointers */
  s_undo_init(p_current);

}


@ %def s_page_setup


@section Function @code{s_page_check_changed()}

@defun s_page_check_changed p_head
@end defun

<<s_page.c : s_page_check_changed()>>=
int
s_page_check_changed(PAGE *p_head)
{
  PAGE *p_current;

  p_current = p_head;
	
  while(p_current != NULL) {
    if (p_current->CHANGED) {
      return(1);
    }

    p_current = p_current->next;
  }
  return(0);
}


@ %def s_page_check_changed


@section Function @code{s_page_clear_changed()}

@defun s_page_clear_changed p_head
@end defun

<<s_page.c : s_page_clear_changed()>>=
void
s_page_clear_changed(PAGE *p_head)
{
  PAGE *p_current;

  p_current = p_head;
	
  while(p_current != NULL) {
    p_current->CHANGED = 0;
    p_current = p_current->next;
  }

}


@ %def s_page_clear_changed


@section Function @code{s_page_goto()}

@defun s_page_goto w_current p_new
@end defun

<<s_page.c : s_page_goto()>>=
void
s_page_goto(TOPLEVEL *w_current, PAGE *p_new) 
{
  w_current->page_current = p_new;

  if (w_current->page_current->page_filename) { /* sanity check */
    gchar *dirname = g_dirname (w_current->page_current->page_filename);
    chdir (dirname);
    g_free (dirname);
  }
}


@ %def s_page_goto


@section Function @code{s_page_search()}

@defun s_page_search w_current filename
@end defun

<<s_page.c : s_page_search()>>=
PAGE *
s_page_search(TOPLEVEL *w_current, char *filename)
{
  PAGE *p_current;

  p_current = w_current->page_head;

  while(p_current != NULL) {
		
    if (strcmp(p_current->page_filename, filename) == 0) {
      return(p_current);	
    }

    p_current = p_current->next;
  }

  return(NULL);
}


@ %def s_page_search


@section Function @code{s_page_search_row()}

@defun s_page_search_row w_current p_findme
@end defun

<<s_page.c : s_page_search_row()>>=
int
s_page_search_row(TOPLEVEL *w_current, PAGE *p_findme)
{
  PAGE *p_current;

  p_current = w_current->page_head;

  while(p_current != NULL) {
    if (p_current->clist_row == p_findme->clist_row) {
      return(p_current->clist_row);
    }
	
    p_current = p_current->next;
  }

  return(0); /* can't find page... well just select row 0 */
}


@ %def s_page_search_row


@section Function @code{s_page_print_all()}

@defun s_page_print_all w_current
@end defun

<<s_page.c : s_page_print_all()>>=
void
s_page_print_all(TOPLEVEL *w_current)
{
  PAGE *p_current;

  p_current = w_current->page_head;

  while(p_current != NULL) {

    if (p_current->pid != -1) {
      printf("FILENAME: %s\n", p_current->page_filename);
      print_struct_forw(p_current->object_head);
    }

    p_current = p_current->next;
  }
}


@ %def s_page_print_all


@section Function @code{s_page_save_all()}

@defun s_page_save_all w_current
@end defun

<<s_page.c : s_page_save_all()>>=
int
s_page_save_all(TOPLEVEL *w_current)
{
  PAGE *p_current;
  PAGE *p_save;
  int status = 0;

  p_save = w_current->page_current;
  p_current = w_current->page_head;

  while(p_current != NULL) {

    if (p_current->pid != -1) {
      w_current->page_current = p_current;

      if (f_save(w_current, p_current->page_filename)) {
      	s_log_message("Saved [%s]\n", w_current->page_current->page_filename);
        p_current->CHANGED = 0;
      } else {
	status++;
      	s_log_message("Could NOT save [%s]\n", 
                       w_current->page_current->page_filename);
      }
    }

    p_current = p_current->next;
  }

  w_current->page_current = p_save;
  return status;
}


@ %def s_page_save_all

