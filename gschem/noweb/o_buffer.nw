@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_buffer.c,,,Top
@chapter File @file{o_buffer.c}

@section File header

<<o_buffer.c : *>>=
<<o_buffer.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_buffer.nw instead */

<<o_buffer.c : include directives>>
<<o_buffer.c : o_buffer_copy()>>
<<o_buffer.c : o_buffer_cut()>>
<<o_buffer.c : o_buffer_paste_start()>>
<<o_buffer.c : o_buffer_paste_end()>>
<<o_buffer.c : o_buffer_paste_rubberpaste()>>
<<o_buffer.c : o_buffer_init()>>
<<o_buffer.c : o_buffer_free()>>

@


<<o_buffer.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<o_buffer.c : include directives>>=
#include <config.h>
#include <stdio.h>

#include <libgeda/libgeda.h>

#include "../include/globals.h"
#include "../include/prototype.h"

@


@section Function @code{o_buffer_copy()}

@defun o_buffer_copy w_current buf_num
@end defun

<<o_buffer.c : o_buffer_copy()>>=
void
o_buffer_copy(TOPLEVEL *w_current, int buf_num)
{
  SELECTION *s_current = NULL;

  if (buf_num < 0 || buf_num > MAX_BUFFERS) {
    fprintf(stderr, _("Got an invalid buffer_number [o_buffer_copy]\n"));
    return;
  }

  s_current = w_current->page_current->selection2_head->next;

  if (object_buffer[buf_num] == NULL) {
    object_buffer[buf_num] = s_basic_init_object("buffer0_head");
    object_buffer[buf_num]->type = OBJ_HEAD;
  } else {
    o_list_delete_rest(w_current, object_buffer[buf_num]);
    object_buffer[buf_num]->next = NULL;
  }

  w_current->ADDING_SEL = 1;
  o_list_copy_all_selection2(w_current, s_current, 
                             object_buffer[buf_num], SELECTION_FLAG);
  w_current->ADDING_SEL = 0;
        
#if DEBUG
  o_current = object_buffer[buf_num];
  while(o_current != NULL) {
    printf("- %s\n", o_current->name);
    o_current = o_current->next;
  }
#endif
}


@ %def o_buffer_copy


@section Function @code{o_buffer_cut()}

@defun o_buffer_cut w_current buf_num
@end defun

<<o_buffer.c : o_buffer_cut()>>=
void
o_buffer_cut(TOPLEVEL *w_current, int buf_num)
{
  SELECTION *s_current = NULL;

  if (buf_num < 0 || buf_num > MAX_BUFFERS) {
    fprintf(stderr, _("Got an invalid buffer_number [o_buffer_cut]\n"));
    return;
  }

  s_current = w_current->page_current->selection2_head->next;

  if (object_buffer[buf_num] == NULL) {
    object_buffer[buf_num] = s_basic_init_object("buffer0_head");
    object_buffer[buf_num]->type = OBJ_HEAD;
  } else {
    o_list_delete_rest(w_current, object_buffer[buf_num]);
    object_buffer[buf_num]->next = NULL;
  }
        
  w_current->ADDING_SEL = 1;
  o_list_copy_all_selection2(w_current, s_current, 
                             object_buffer[buf_num], SELECTION_FLAG);
  w_current->ADDING_SEL = 0;
  o_delete(w_current);

#if DEBUG
  o_current = object_buffer[buf_num];
  while(o_current != NULL) {
    printf("- %s\n", o_current->name);
    o_current = o_current->next;
  }
#endif
}


@ %def o_buffer_cut


@section Function @code{o_buffer_paste_start()}

@defun o_buffer_paste_start w_current screen_x screen_y buf_num
@end defun

<<o_buffer.c : o_buffer_paste_start()>>=
void
o_buffer_paste_start(TOPLEVEL *w_current, int screen_x, int screen_y, 
		     int buf_num)
{
  int rleft, rtop, rbottom, rright;
  int x, y;

  if (buf_num < 0 || buf_num > MAX_BUFFERS) {
    fprintf(stderr, _("Got an invalid buffer_number [o_buffer_paste_start]\n"));
    return;
  }

  world_get_complex_bounds(w_current, object_buffer[buf_num], 
                           &rleft, &rtop, 
                           &rright, &rbottom);

  /* snap x and y to the grid, pointed out by Martin Benes */
  x = snap_grid(w_current, rleft);
  y = snap_grid(w_current, rtop);

  w_current->ADDING_SEL = 1;
  o_complex_world_translate(w_current, -x, -y, object_buffer[buf_num]);
  w_current->ADDING_SEL = 0;

  /* now translate selection to current position */
  SCREENtoWORLD(w_current, screen_x, screen_y, &x, &y);
  w_current->ADDING_SEL = 1;
  o_complex_world_translate(w_current, x, y, object_buffer[buf_num]);
  w_current->ADDING_SEL = 0;

  w_current->last_x = w_current->start_x = fix_x(w_current, screen_x);
  w_current->last_y = w_current->start_y = fix_y(w_current, screen_y);
  w_current->event_state = ENDPASTE;

  /* store the buffer number for future use */
  w_current->buffer_number = buf_num;

  o_drawbounding(w_current,
                 object_buffer[buf_num]->next,
                 NULL,
                 x_get_darkcolor(w_current->bb_color), TRUE);
}


@ %def o_buffer_paste_start


@section Function @code{o_buffer_paste_end()}

@defun o_buffer_paste_end w_current screen_x screen_y buf_num
@end defun

<<o_buffer.c : o_buffer_paste_end()>>=
void
o_buffer_paste_end(TOPLEVEL *w_current, int screen_x, int screen_y, 
		   int buf_num)
{
  int w_x, w_y;
  int w_start_x, w_start_y;
  int w_diff_x, w_diff_y;
  OBJECT *o_current;
  OBJECT *o_saved;
  SELECTION *temp_list;
  PAGE *p_current;
  GList *connected_objects = NULL;

  if (buf_num < 0 || buf_num > MAX_BUFFERS) {
    fprintf(stderr, _("Got an invalid buffer_number [o_buffer_paste_end]\n"));
    return;
  }

  /* erase old image */
  o_drawbounding(w_current,
                 object_buffer[buf_num]->next,
                 NULL,
                 x_get_darkcolor(w_current->bb_color), FALSE);

  /* get the location where we ended */
  SCREENtoWORLD(w_current, screen_x, screen_y, &w_x, &w_y);
  SCREENtoWORLD(w_current, w_current->start_x, w_current->start_y, 
                &w_start_x, &w_start_y);

#if DEBUG 
  printf("%d %d\n", w_x - w_start_x,  w_y - w_start_y);
#endif
  /* calc and translate objects to their final position */
  w_diff_x = w_x - w_start_x;
  w_diff_y = w_y - w_start_y;
  w_current->ADDING_SEL = 1;
  o_complex_world_translate(w_current, w_diff_x, w_diff_y, 
                            object_buffer[buf_num]);
  w_current->ADDING_SEL = 0;

  o_current = object_buffer[buf_num]->next;
  p_current = w_current->page_current;

  o_saved = p_current->object_tail;	
  o_list_copy_all(w_current, o_current, p_current->object_tail, 
                  NORMAL_FLAG);

  p_current->object_tail = return_tail(p_current->object_head);
  o_current = o_saved->next;
  temp_list = o_selection_new_head();

  /* now add new objects to the selection list */
  while (o_current != NULL) {
    o_selection_add(temp_list, o_current);
    s_conn_update_object(w_current, o_current);
    if (o_current->type == OBJ_COMPLEX || o_current->type == OBJ_PLACEHOLDER) {
      connected_objects = s_conn_return_complex_others(
                                                       connected_objects,
                                                       o_current);
    } else {
      connected_objects = s_conn_return_others(connected_objects,
                                               o_current);
    }
    o_current = o_current->next;
  }

  o_cue_redraw_all(w_current, o_saved->next);
  o_cue_undraw_list(w_current, connected_objects);
  o_cue_draw_list(w_current, connected_objects);
  g_list_free(connected_objects);
  connected_objects = NULL;
        
  o_selection_remove_most(w_current,
                          w_current->page_current->selection2_head);
  o_selection_destroy_head(w_current->page_current->selection2_head);
  w_current->page_current->selection2_head = temp_list;
  w_current->page_current->selection2_tail = o_selection_return_tail(
                                                                     temp_list);

  w_current->page_current->CHANGED = 1;
  o_redraw(w_current, o_saved->next); /* only redraw new objects */
  o_undo_savestate(w_current, UNDO_ALL);
  i_update_menus(w_current);
}


@ %def o_buffer_paste_end


@section Function @code{o_buffer_paste_rubberpaste()}

@defun o_buffer_paste_rubberpaste w_current buf_num
@end defun

<<o_buffer.c : o_buffer_paste_rubberpaste()>>=
void
o_buffer_paste_rubberpaste(TOPLEVEL *w_current, int buf_num)
{
  o_drawbounding(w_current,
                 object_buffer[buf_num]->next,
                 NULL,
                 x_get_darkcolor(w_current->bb_color), FALSE);
}


@ %def o_buffer_paste_rubberpaste


@section Function @code{o_buffer_init()}

@defun o_buffer_init 
@end defun

<<o_buffer.c : o_buffer_init()>>=
void
o_buffer_init(void)
{
	int i;

	for (i = 0 ; i < MAX_BUFFERS; i++) {
		object_buffer[i] = NULL;
	}
}


@ %def o_buffer_init


@section Function @code{o_buffer_free()}

@defun o_buffer_free w_current
@end defun

<<o_buffer.c : o_buffer_free()>>=
void
o_buffer_free(TOPLEVEL *w_current)
{
  int i;

  for (i = 0 ; i < MAX_BUFFERS; i++) {
    if (object_buffer[i]) {
      s_delete_list_fromstart(w_current, 
                              object_buffer[i]);
      object_buffer[i] = NULL;
    }
  }
}


@ %def o_buffer_free
