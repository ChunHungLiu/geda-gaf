@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_circle_basic.c,,,Top
@chapter File @file{o_circle_basic.c}

@section File header

<<o_circle_basic.c : *>>=
<<o_circle_basic.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_circle_basic.nw instead */

<<o_circle_basic.c : include directives>>
<<o_circle_basic.c : macros>>
<<o_circle_basic.c : dist()>>
<<o_circle_basic.c : get_circle_bounds()>>
<<o_circle_basic.c : world_get_circle_bounds()>>
<<o_circle_basic.c : o_circle_add()>>
<<o_circle_basic.c : o_circle_recalc()>>
<<o_circle_basic.c : o_circle_read()>>
<<o_circle_basic.c : o_circle_save()>>
<<o_circle_basic.c : o_circle_copy()>>
<<o_circle_basic.c : o_circle_print()>>         /* done */
<<o_circle_basic.c : o_circle_print_solid()>>   /* done */
<<o_circle_basic.c : o_circle_print_dotted()>>  /* done */
<<o_circle_basic.c : o_circle_print_dashed()>>  /* done */
<<o_circle_basic.c : o_circle_print_center()>>  /* done */
<<o_circle_basic.c : o_circle_print_phantom()>> /* done */
<<o_circle_basic.c : o_circle_print_filled()>>  /* done */
<<o_circle_basic.c : o_circle_print_mesh()>>    /* done */
<<o_circle_basic.c : o_circle_print_hatch()>>   /* done */

#if 0 /* original way of printing circle, no longer used */
<<o_circle_basic.c : o_circle_print_old()>>
#endif

<<o_circle_basic.c : o_circle_image_write()>>
<<o_circle_basic.c : o_circle_translate()>>
<<o_circle_basic.c : o_circle_translate_world()>>
<<o_circle_basic.c : o_circle_rotate()>>
<<o_circle_basic.c : o_circle_rotate_world()>>
<<o_circle_basic.c : o_circle_mirror()>>
<<o_circle_basic.c : o_circle_mirror_world()>>
<<o_circle_basic.c : o_circle_modify()>>

@

<<o_circle_basic.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * libgeda - gEDA's library
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 

<<o_circle_basic.c : include directives>>=
#include <config.h>
#include <stdio.h>
#include <math.h>

#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <gdk/gdkx.h>

#include <guile/gh.h>

#ifdef HAS_LIBGDGEDA
#include <gdgeda/gd.h>
#endif

#include "defines.h"
#include "struct.h"
#include "globals.h"
#include "o_types.h"

#include "colors.h"
#include "funcs.h"

#include "../include/prototype.h"

@ 

<<o_circle_basic.c : macros>>=
#define VERSION_20000704 20000704

@ %def VERSION_20000704


@section Function @code{dist()}

@defun dist x1 y1 x2 y2
@end defun

<<o_circle_basic.c : dist()>>=
int 
dist(int x1, int y1, int x2, int y2)
{
  int dx1, dy1;
  int dx2, dy2;
  int ret;

  dx1 = x1;
  dy1 = y1;
  dx2 = x2;
  dy2 = y2;

  ret =  sqrt(pow(dx1-dx2,2)+pow(dy1-dy2,2)) ;
  return( ret );
}

@ %def dist


@section Function @code{get_circle_bounds()}

@defun get_circle_bounds w_current circle left top right bottom
@end defun

<<o_circle_basic.c : get_circle_bounds()>>=
void
get_circle_bounds(TOPLEVEL *w_current, CIRCLE *circle, int *left, int *top,
                  int *right, int *bottom)
{

  *left = w_current->width;
  *top = w_current->height;
  *right = 0;
  *bottom = 0;

  /* left, top actually represent lower left corner, not upper left */
  *left = circle->screen_left;
  *top = circle->screen_top;

  *right = *left + circle->screen_radius*2;
  *bottom = circle->screen_top+circle->screen_radius*2;

  /* PB : need to take into account the width of the line in the bounding box */
	
  /* out temp  
   *left = *left - 4;
   *top = *top - 4;

   *right = *right + 4;
   *bottom = *bottom + 4;
   */

}

@ %def get_circle_bounds


@section Function @code{world_get_circle_bounds()}

@defun o_world_get_circle_bounds w_current circle left top right bottom
@end defun

<<o_circle_basic.c : world_get_circle_bounds()>>=
void
world_get_circle_bounds(TOPLEVEL *w_current, CIRCLE *circle, int *left,
                        int *top, int *right, int *bottom)
{

  *left = w_current->init_right;
  *top = w_current->init_bottom;
  *right = 0;
  *bottom = 0;


  *left = circle->center_x - circle->radius;
  *top = circle->center_y - circle->radius;

  *right = circle->center_x + circle->radius;
  *bottom = circle->center_y + circle->radius;

  /*
   *left = points->x1;
   *top = points->y1;
   *right = points->x1+(temp);
   *bottom = points->y1-(temp); 
   */

  /* 
   *left = min(circle->x1, circle->x1+temp);
   *top = min(circle->y1, circle->y1-temp);
   *right = max(circle->x1, circle->x1+temp);
   *bottom = max(circle->y1, circle->y1-temp);*/

#if DEBUG 
  printf("circle: %d %d %d %d\n", *left, *top, *right, *bottom);
#endif

}

@ %def world_get_circle_bounds


@section Function @code{o_circle_add()}

@defun o_circle_add w_current object_list type color x y radius
@end defun

<<o_circle_basic.c : o_circle_add()>>=
OBJECT *
o_circle_add(TOPLEVEL *w_current, OBJECT *object_list,
             char type, int color,
             int x, int y, int radius)
{
  OBJECT *new_node;	

  new_node = s_basic_init_object("circle");
  new_node->type = type;
  new_node->color = color;

  new_node->circle = (CIRCLE *) malloc(sizeof(CIRCLE));

  /* check for null */	

  new_node->circle->center_x = x;
  new_node->circle->center_y = y;
  new_node->circle->radius = radius;

  /* Init */
  o_set_line_options(w_current, new_node,
                     END_NONE, TYPE_SOLID, 0, -1, -1);
  o_set_fill_options(w_current, new_node,
                     FILLING_HOLLOW, -1, -1, -1, -1, -1);

  o_circle_recalc(w_current, new_node);

  /* TODO: questionable cast */
  new_node->draw_func = (void *) circle_draw_func;  
  /* TODO: questionable cast */
  new_node->sel_func = (void *) select_func;  

  object_list = (OBJECT *) s_basic_link_object(new_node, object_list);
  return(object_list);
}

@ %def o_circle_add


@section Function @code{o_circle_recalc()}

@defun o_circle_recalc w_current o_current
@end defun

<<o_circle_basic.c : o_circle_recalc()>>=
void
o_circle_recalc(TOPLEVEL *w_current, OBJECT *o_current)
{
  int screen_x1, screen_y1;
  int left, right, top, bottom;


  if (o_current->circle == NULL) {
    return;
  }

#if DEBUG
  printf("drawing circle\n");
#endif

  WORLDtoSCREEN(w_current, o_current->circle->center_x, 
                o_current->circle->center_y, 
                &screen_x1,
                &screen_y1);  

  o_current->circle->screen_x = screen_x1;
  o_current->circle->screen_y = screen_y1;

  o_current->circle->screen_radius = SCREENabs(w_current, 
                                               o_current->circle->radius);

  o_current->circle->screen_left = o_current->circle->screen_x - 
  o_current->circle->screen_radius;
  o_current->circle->screen_top = o_current->circle->screen_y - 
  o_current->circle->screen_radius;

  get_circle_bounds(w_current, o_current->circle, &left, &top, &right, &bottom);

  o_current->left = left;
  o_current->top = top;
  o_current->right = right;
  o_current->bottom = bottom;

  o_object_recalc(w_current, o_current);
}

@ %def o_circle_recalc


@section Function @code{o_circle_read()}

@defun o_circle_read w_current object_list buf version
@end defun

<<o_circle_basic.c : o_circle_read()>>=
OBJECT * 
o_circle_read(TOPLEVEL *w_current, OBJECT *object_list, char buf[], char *version)
{
  char type; 
  int x1, y1;
  int radius;
  int color;
  int circle_width, circle_space, circle_length;
  int fill_width, angle1, pitch1, angle2, pitch2;
  OBJECT_END circle_end;
  OBJECT_TYPE circle_type;
  OBJECT_FILLING circle_fill;
  long int ver;

  ver = strtol(version, NULL, 10);
  if(ver <= VERSION_20000704) {
    sscanf(buf, "%c %d %d %d %d\n", &type, &x1, &y1, &radius, &color);

    circle_width = 0;
    circle_end   = END_NONE;
    circle_type  = TYPE_SOLID;
    circle_length= -1;
    circle_space = -1;

    circle_fill  = FILLING_HOLLOW;
    fill_width  = 0;
    angle1      = -1;
    pitch1      = -1;
    angle2      = -1;
    pitch2      = -1;
  } else {
    sscanf(buf, "%c %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
           &type, &x1, &y1, &radius, &color,
           &circle_width, &circle_end, &circle_type,
           &circle_length, &circle_space, &circle_fill,
           &fill_width, &angle1, &pitch1, &angle2, &pitch2);
  }

  if (radius == 0) {
    fprintf(stderr, "Found a zero radius circle [ %c %d %d %d %d ]\n",
            type, x1, y1, radius, color);
    s_log_message("Found a zero radius circle [ %c %d %d %d %d ]\n",
                  type, x1, y1, radius, color);
		
  }
	
  if (color < 0 || color > MAX_COLORS) {
    fprintf(stderr, "Found an invalid color [ %s ]\n", buf);
    s_log_message("Found an invalid color [ %s ]\n", buf);
    s_log_message("Setting color to WHITE\n");
    color = WHITE;
  }
	
  object_list = (OBJECT *) o_circle_add(w_current, object_list,
                                        type, color, x1, y1, radius);
  o_set_line_options(w_current, object_list,
                     circle_end, circle_type, circle_width, 
                     circle_length, circle_space);
  o_set_fill_options(w_current, object_list,
                     circle_fill, fill_width, pitch1, angle1, pitch2, angle2);
	
  return(object_list);
}

@ %def o_circle_read


@section Function @code{o_circle_save()}

@defun o_circle_save buf object
@end defun

<<o_circle_basic.c : o_circle_save()>>=
char *
o_circle_save(char *buf, OBJECT *object)
{
  int x,y;
  int radius;
  int color;
  int circle_width, circle_space, circle_length;
  int fill_width, angle1, pitch1, angle2, pitch2;
  OBJECT_END circle_end;
  OBJECT_TYPE circle_type;
  OBJECT_FILLING circle_fill;

  x = object->circle->center_x;
  y = object->circle->center_y;
  radius = object->circle->radius;

  circle_width = object->line_width;
  circle_end   = object->line_end;
  circle_type  = object->line_type;
  circle_length= object->line_length;
  circle_space = object->line_space;

  circle_fill  = object->fill_type;
  fill_width   = object->fill_width;
  angle1       = object->fill_angle1;
  pitch1       = object->fill_pitch1;
  angle2       = object->fill_angle2;
  pitch2       = object->fill_pitch2;

#if 0 /* old system */
  radius = abs(x2 - x1)/2;
  if (radius == 0) {
    radius = abs(y2 - y1)/2;
  }

  x = x1 + radius; 
  y = y1 - radius; /* careful */
#endif

  /* Use the right color */
  if (object->saved_color == -1) {
    color = object->color;
  } else {
    color = object->saved_color;
  }

  sprintf(buf, "%c %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", 
          object->type, x, y, radius, color,
          circle_width, circle_end, circle_type, circle_length, 
          circle_space, circle_fill,
          fill_width, angle1, pitch1, angle2, pitch2);

  return(buf);
}
           
@ %def o_circle_save


@section Function @code{o_circle_translate()}

@defun o_circle_translate w_current dx dy object
@end defun

<<o_circle_basic.c : o_circle_translate()>>=
void
o_circle_translate(TOPLEVEL *w_current, int dx, int dy, OBJECT *object)
{
  int x, y;

  if (object == NULL) printf("ct NO!\n");

  /* Do screen coords */
  object->circle->screen_x = object->circle->screen_x + dx;
  object->circle->screen_y = object->circle->screen_y + dy;
  object->circle->screen_left = object->circle->screen_left + dx;
  object->circle->screen_top = object->circle->screen_top + dy;


  /* I don't think we need snap grid here hack */
  SCREENtoWORLD(w_current, 
                object->circle->screen_x, 
                object->circle->screen_y,
                &x,
                &y);
	
  object->circle->center_x = snap_grid(w_current, x);
  object->circle->center_y = snap_grid(w_current, y);

  /* PB : is it needed here ? translation should not change radius,
     am I wrong? */
  object->circle->screen_radius = SCREENabs(w_current, 
                                            object->circle->radius);
	
  object->circle->screen_left = object->circle->screen_x - 
  object->circle->screen_radius;
  object->circle->screen_top = object->circle->screen_y - 
  object->circle->screen_radius;
}

@ %def o_circle_translate


@section Function @code{o_circle_translate_world()}

@defun o_circle_translate_world w_current x1 y1 object
@end defun

<<o_circle_basic.c : o_circle_translate_world()>>=
void
o_circle_translate_world(TOPLEVEL *w_current, int x1, int y1, OBJECT *object)
{
  int screen_x1, screen_y1;
  int left, right, top, bottom;

  if (object == NULL) printf("ctw NO!\n");

  /* Do world coords */
  object->circle->center_x = object->circle->center_x + x1;
  object->circle->center_y = object->circle->center_y + y1;
	
  WORLDtoSCREEN(w_current, 
                object->circle->center_x, 
                object->circle->center_y, 
                &screen_x1,
                &screen_y1);  
	
  object->circle->screen_x = screen_x1;
  object->circle->screen_y = screen_y1;

  /* PB : same comments as above in o_circle_translate() */
  object->circle->screen_radius = SCREENabs(w_current, 
                                            object->circle->radius);
	
  object->circle->screen_left = object->circle->screen_x - 
  object->circle->screen_radius;
  object->circle->screen_top = object->circle->screen_y - 
  object->circle->screen_radius;

  get_circle_bounds(w_current, object->circle, &left, &top, &right, &bottom);

  object->left = left;
  object->top = top;
  object->right = right;
  object->bottom = bottom;
}

@ %def o_circle_translate_world


@section Function @code{o_circle_copy()}

@defun o_circle_copy w_current list_tail o_current
@end defun

<<o_circle_basic.c : o_circle_copy()>>=
OBJECT *
o_circle_copy(TOPLEVEL *w_current, OBJECT *list_tail, OBJECT *o_current)
{
  OBJECT *new_obj;
  ATTRIB *a_current;
  int color;

  if (o_current->saved_color == -1) {
    color = o_current->color;
  } else {
    color = o_current->saved_color;
  }

  new_obj = o_circle_add(w_current, list_tail, OBJ_CIRCLE, 
                         color, 
                         o_current->circle->center_x, 
                         o_current->circle->center_y, 
                         o_current->circle->radius);
	
  new_obj->circle->screen_x = o_current->circle->screen_x;
  new_obj->circle->screen_y = o_current->circle->screen_y;
  new_obj->circle->screen_left = o_current->circle->screen_left;
  new_obj->circle->screen_top = o_current->circle->screen_top;
  new_obj->circle->screen_radius = o_current->circle->screen_radius;

  o_set_line_options(w_current, new_obj, o_current->line_end,
                     o_current->line_type, o_current->line_width,
                     o_current->line_length, o_current->line_space);
  o_set_fill_options(w_current, new_obj,
                     o_current->fill_type, o_current->fill_width,
                     o_current->fill_pitch1, o_current->fill_angle1,
                     o_current->fill_pitch2, o_current->fill_angle2);
	
  /*	new_obj->attribute = 0;*/
  a_current = o_current->attribs;
  if (a_current) {
    while ( a_current ) {
			
      /* head attrib node has prev = NULL */
      if (a_current->prev != NULL) {
        a_current->copied_to = new_obj;
      }
      a_current = a_current->next;
    }
  }

  return(new_obj);
}

@ %def o_circle_copy


@section Function @code{o_circle_print()}

@defun o_circle_print w_current fp o_current origin_x origin_y
This function write in a postscript file the circle described by the [[o_current]] pointed object. It takes into account its line type and fill type.
The postscript resulting files is descibed by the file pointer [[fp]].
@end defun

The validity of the [[o_current]] pointer is checked : a null pointer causes an error message and a return.

The description of the circle is extracted from the [[o_current]] pointed object : the coordinates of the center of the circle, its radius, its line type, its fill type.

The outline and the inside of the circle are successively handled by two differend sets of functions.

<<o_circle_basic.c : o_circle_print()>>=
void
o_circle_print(TOPLEVEL *w_current, FILE *fp, OBJECT *o_current, 
               int origin_x, int origin_y)
{
  int x, y, radius;
  int color;
  int circle_width, length, space;
  int fill_width, angle1, pitch1, angle2, pitch2;
  void (*outl_func)() = NULL;
  void (*fill_func)() = NULL;

  if (o_current == NULL) {
    printf("got null in o_circle_print\n");
    return;
  }

  x      = o_current->circle->center_x; 
  y      = o_current->circle->center_y;
  radius = o_current->circle->radius;

  color  = o_current->color;

  <<o_circle_print() : printing outline>>
  <<o_circle_print() : printing the filling>>
	
}

@ %def o_circle_print


Depending on the type of the line for this particular circle, the appropriate function is chosen among [[o_circle_print_solid()]], [[o_circle_print_dotted()]], [[o_circle_print_dashed()]], [[o_circle_print_center]] and [[o_circle_print_phantom()]].

The needed parameters for each of these type is extracted from the [[o_current]] object. Depending on the type, unused parameters are set to -1.

In the eventuality of a length and/or space null, the line is printed solid to avoid and endless loop produced by other functions in such a case.

<<o_circle_print() : printing outline>>=

  circle_width = o_current->line_width;
  length       = o_current->line_length;
  space        = o_current->line_space;

  switch(o_current->line_type) {
    case(TYPE_SOLID):
      length = -1; space  = -1;
      outl_func = (void *) o_circle_print_solid;
      break;

    case(TYPE_DOTTED):
      length = -1;
      outl_func = (void *) o_circle_print_dotted;
      break;

    case(TYPE_DASHED):
      outl_func = (void *) o_circle_print_dashed;
      break;

    case(TYPE_CENTER):
      outl_func = (void *) o_circle_print_center;
      break;

    case(TYPE_PHANTOM):
      outl_func = (void *) o_circle_print_phantom;
      break;

    case(TYPE_ERASE):
      /* Unused for now print it solid */
      length = -1; space  = -1;
      outl_func = (void *) o_circle_print_solid;
      break;
  }

  if((length == 0) || (space == 0)) {
    length = -1; space  = -1;
    outl_func = (void *) o_circle_print_solid;
  }

  (*outl_func)(w_current, fp,
               x - origin_x, y - origin_y,
               radius,
               color,
               circle_width, length, space,
               origin_x, origin_y);

@ 	


If the filling type of the circle is not [[HOLLOW]], the appropriate function is chosen among [[o_circle_print_filled()]], [[o_circle_print_mesh()]] and [[o_circle_print_hatch()]]. The corresponding parameters are extracted from the [[o_current]] object and corrected afterward.

The case where [[pitch1]] and [[pitch2]] are null or negative is avoided as it leads to an endless loop in most of the called functions. In such a case, the circle is printed filled. Unused parameters for each of these functions are set to -1 or any passive value.

<<o_circle_print() : printing the filling>>=
  if(o_current->fill_type != FILLING_HOLLOW) {
    fill_width = o_current->fill_width;
    angle1     = o_current->fill_angle1;
    pitch1     = o_current->fill_pitch1;
    angle2     = o_current->fill_angle2;
    pitch2     = o_current->fill_pitch2;
		
    switch(o_current->fill_type) {
      case(FILLING_FILL):
        angle1 = -1; pitch1 = 1;
        angle2 = -1; pitch2 = 1;
        fill_width = -1;
        fill_func = (void *) o_circle_print_filled;
        break;
			
      case(FILLING_MESH):
        fill_func = (void *) o_circle_print_mesh;
        break;
				
      case(FILLING_HATCH):
        angle2 = -1; pitch2 = 1;
        fill_func = (void *) o_circle_print_hatch;
        break;
				
      case(FILLING_VOID):
				/* Unused for now, print it filled */
        angle1 = -1; pitch1 = 1;
        angle2 = -1; pitch2 = 1;
        fill_width = -1;
        fill_func = (void *) o_circle_print_filled;
        break;
    }

    if((pitch1 <= 0) || (pitch2 <= 0)) {
      angle1 = -1; pitch1 = 1;
      angle2 = -1; pitch2 = 1;
      fill_func = (void *) o_circle_print_filled;
    }
		
    (*fill_func)(w_current, fp,
                 x, y, radius,
                 color,
                 fill_width,
                 angle1, pitch1, angle2, pitch2,
                 origin_x, origin_y);
  }

@ 


@section Function @code{o_circle_print_solid()}

@defun o_circle_print_solid w_current fp x y radius color circle_width length space origin_x origin_y
This function prints the outline of a circle when a solid line type is required. The circle is defined by its center in ([[x]], [[y]]) and its radius in [[radius]]. It is printed with the color given in [[color]].
The parameters [[length]] and [[space]] are ignored.
@end defun

It uses the function [[o_arc_print_solid()]] to print the outline. Therefore it acts as an interface between the way a circle is defined and the way an arc is defined.

All dimensions are in mils.

<<o_circle_basic.c : o_circle_print_solid()>>=
void
o_circle_print_solid(TOPLEVEL *w_current, FILE *fp,
                     int x, int y, int radius,
                     int color,
                     int circle_width, int length, int space,
                     int origin_x, int origin_y)
{

  o_arc_print_solid(w_current, fp,
                    x, y, radius,
                    0, FULL_CIRCLE / 64,
                    color,
                    circle_width, -1, -1,
                    origin_x, origin_y);

}

@ %def o_circle_print_solid


@section Function @code{o_circle_print_dotted()}

@defun o_circle_print_dotted w_current fp x y radius color circle_width length space origin_x origin_y
This function prints the outline of a circle when a dotted line type is required. The circle is defined by its center in ([[x]], [[y]]) and its radius in [[radius]]. It is printed with the color given in [[color]].
The parameter [[length]] is ignored.
@end defun

It uses the function [[o_arc_print_dotted()]] to print the outline. Therefore it acts as an interface between the way a circle is defined and the way an arc is defined.

All dimensions are in mils.

<<o_circle_basic.c : o_circle_print_dotted()>>=
void
o_circle_print_dotted(TOPLEVEL *w_current, FILE *fp,
                      int x, int y, int radius,
                      int color,
                      int circle_width, int length, int space,
                      int origin_x, int origin_y)
{

  o_arc_print_dotted(w_current, fp,
                     x, y, radius,
                     0, FULL_CIRCLE / 64,
                     color,
                     circle_width, -1, space,
                     origin_x, origin_y);

}

@ %def o_circle_print_dotted


@section Function @code{o_circle_print_dashed()}

@defun o_circle_print_dashed w_current fp x y radius color circle_width length space origin_x origin_y
This function prints the outline of a circle when a dashed line type is required. The circle is defined by its center in ([[x]], [[y]]) and its radius in [[radius]]. It is printed with the color given in [[color]].
@end defun

It uses the function [[o_arc_print_dashed()]] to print the outline. Therefore it acts as an interface between the way a circle is defined and the way an arc is defined.

All dimensions are in mils.

<<o_circle_basic.c : o_circle_print_dashed()>>=
void
o_circle_print_dashed(TOPLEVEL *w_current, FILE *fp,
                      int x, int y,
                      int radius,
                      int color,
                      int circle_width, int length, int space,
                      int origin_x, int origin_y)
{

  o_arc_print_dashed(w_current, fp,
                     x, y, radius,
                     0, FULL_CIRCLE / 64,
                     color,
                     circle_width, length, space,
                     origin_x, origin_y);

}

@ %def o_circle_print_dashed


@section Function @code{o_circle_print_center()}

@defun o_circle_print_center w_current fp x y radius color circle_width length space origin_x origin_y
This function prints the outline of a circle when a centered line type is required. The circle is defined by its center in ([[x]], [[y]]) and its radius in [[radius]]. It is printed with the color given in [[color]].
@end defun

It uses the function [[o_arc_print_center()]] to print the outline. Therefore it acts as an interface between the way a circle is defined and the way an arc is defined.

All dimensions are in mils.

<<o_circle_basic.c : o_circle_print_center()>>=
void
o_circle_print_center(TOPLEVEL *w_current, FILE *fp,
                      int x, int y,
                      int radius,
                      int color,
                      int circle_width, int length, int space,
                      int origin_x, int origin_y)
{
	
  o_arc_print_center(w_current, fp,
                     x, y, radius,
                     0, FULL_CIRCLE / 64,
                     color,
                     circle_width, length, space,
                     origin_x, origin_y);

}

@ %def o_circle_print_center


@section Function @code{o_circle_print_phantom()}

@defun o_circle_print_phantom w_current fp x y radius color circle_width length space origin_x origin_y
This function prints the outline of a circle when a phantom line type is required. The circle is defined by its center in ([[x]], [[y]]) and its radius in [[radius]]. It is printed with the color given in [[color]].
@end defun

It uses the function [[o_arc_print_phantom()]] to print the outline. Therefore it acts as an interface between the way a circle is defined and the way an arc is defined.

All dimensions are in mils.

<<o_circle_basic.c : o_circle_print_phantom()>>=
void
o_circle_print_phantom(TOPLEVEL *w_current, FILE *fp,
                       int x, int y,
                       int radius,
                       int color,
                       int circle_width, int length, int space,
                       int origin_x, int origin_y)
{

  o_arc_print_phantom(w_current, fp,
                      x, y, radius,
                      0, FULL_CIRCLE / 64,
                      color,
                      circle_width, length, space,
                      origin_x, origin_y);

}

@ %def o_circle_print_phantom


@section Function @code{o_circle_print_filled()}

@defun o_circle_print_filled w_current fp x y radius color circle_width length space origin_x origin_y
The function prints a filled circle with a solid pattern. No outline is printed. 
The circle is defined by the coordinates of its center in ([[x]],[[y]]) and its radius given by the [[radius]] parameter. 
The postscript file is defined by the file pointer [[fp]].
[[fill_width]], [[angle1]] and [[pitch1]], [[angle2]] and [[pitch2]] parameters are ignored in this functions but kept for compatibility with other fill functions.
@end defun

All dimensions are in mils (except [[angle1]] and [[angle2]] in degree).

<<o_circle_basic.c : o_circle_print_filled()>>=
void
o_circle_print_filled(TOPLEVEL *w_current, FILE *fp,
                      int x, int y, int radius,
                      int color,
                      int fill_width,
                      int angle1, int pitch1,
                      int angle2, int pitch2,
                      int origin_x, int origin_y)
{
  fprintf(fp, "gsave\n");
  if (w_current->print_color) {
    f_print_set_color(fp, color);
  }

  f_print_set_line_width(fp, 1);

  fprintf(fp, "newpath\n");
  fprintf(fp, "%d mils %d mils\n", x-origin_x, y-origin_y);
  fprintf(fp, "%d mils\n", radius);
  fprintf(fp, "0 360 arc\n");
  fprintf(fp, "fill\n");
  fprintf(fp, "grestore\n");
	
}

@


@section Function @code{o_circle_print_mesh()}

@defun o_circle_print_mesh w_current fp x y radius color fill_width angle1 pitch1 angle2 pitch2 origin_x origin_y
The function prints a meshed circle. No outline is printed. 
The circle is defined by the coordinates of its center in ([[x]],[[y]]) and its radius by the [[radius]] parameter. 
The postscript file is defined by the file pointer [[fp]]. 
@end defun

The inside mesh is achieved by two successive call to the [[o_circle_print_hatch()]] function, given [[angle1]] and [[pitch1]] the first time and [[angle2]] and [[pitch2]] the second time.

Negative or null values for [[pitch1]] and/or [[pitch2]] are not allowed as it leads to an endless loop in [[o_circle_print_hatch]].

All dimensions are in mils (except [[angle1]] and [[angle2]] in degree).

<<o_circle_basic.c : o_circle_print_mesh()>>=
void
o_circle_print_mesh(TOPLEVEL *w_current, FILE *fp,
                    int x, int y, int radius,
                    int color,
                    int fill_width,
                    int angle1, int pitch1,
                    int angle2, int pitch2,
                    int origin_x, int origin_y)
{
  o_circle_print_hatch(w_current, fp,
                       x, y, radius,
                       color,
                       fill_width,
                       angle1, pitch1,
                       -1, -1,
                       origin_x, origin_y);
  o_circle_print_hatch(w_current, fp,
                       x, y, radius,
                       color,
                       fill_width,
                       angle2, pitch2,
                       -1, -1,
                       origin_x, origin_y);
	
}

@


@section Function @code{o_circle_print_hatch()}

@defun o_circle_print_hatch w_current fp x y radius color fill_width angle1 pitch1 angle2 pitch2 origin_x origin_y
The function prints a hatched circle. No outline is printed. 
The circle is defined by the coordinates of its center in ([[x]],[[y]]) and its radius by the [[radius]] parameter. 
The postscript file is defined by the file pointer [[fp]]. 
[[angle2]] and [[pitch2]] parameters are ignored in this functions but kept for compatibility with other fill functions.
@end defun

The only attribute of line here is its width from the parameter @code{width}.

Negative or null values for @code{pitch1} are not allowed as it leads to an endless loop.

All dimensions are in mils (except [[angle1]] and [[angle2]] in degree).

<<o_circle_basic.c : o_circle_print_hatch()>>=
void
o_circle_print_hatch(TOPLEVEL *w_current, FILE *fp,
                     int x, int y, int radius,
                     int color,
                     int fill_width,
                     int angle1, int pitch1,
                     int angle2, int pitch2,
                     int origin_x, int origin_y)
{
  double x0, y0, x1, y1, x2, y2;
  double cos_a_, sin_a_;

  fprintf(fp, "gsave\n");
  if (w_current->print_color) {
    f_print_set_color(fp, color);
  }

  f_print_set_line_width(fp, fill_width);	

@ %def o_circle_print_hatch


The values of the cosinus and sinus of the angle [[angle1]] are calculated for future usage (repetitive).

<<o_circle_basic.c : o_circle_print_hatch()>>=	
  cos_a_ = cos(((double) angle1) * M_PI/180);
  sin_a_ = sin(((double) angle1) * M_PI/180);

  <<o_circle_print_hatch() : calculating and printing the lines>>

  fprintf(fp, "grestore\n");
	
}
@ 

When printing a line in a circle there is two intersections. It looks for the coordinates of one of these points when the line is horizontal. The second one can be easily obtained by symmetry in relation to the vertical axis going through the centre of the circle.

These two points are therefore rotated of angle @code{angle1} using the elements previously computed.

The corresponding line can be printed providing that the coordinates are rounded.

These operations are repeated for every horizontal line that can fit in the upper half of the circle (using and incrementing the variable @var{y0}).

<<o_circle_print_hatch() : calculating and printing the lines>>=
  y0 = 0;
  while(y0 < (double) radius) {
    x0 = pow((double) radius, 2) - pow(y0, 2);
    x0 = sqrt(x0);

    x1 = (x0*cos_a_ - y0*sin_a_) + x;
    y1 = y + (x0*sin_a_ + y0*cos_a_);
    x2 = ((-x0)*cos_a_ - y0*sin_a_) + x;
    y2 = y + ((-x0)*sin_a_ + y0*cos_a_);

    fprintf(fp, "newpath\n");
    fprintf(fp, "%d mils %d mils moveto\n", (int) x1, (int) y1);
    fprintf(fp, "%d mils %d mils lineto\n", (int) x2, (int) y2);
    fprintf(fp, "stroke\n");


@ 

The function uses the symetry in relation to the centre of the circle. It avoid repetitive computation for the second half of the surface of the circle.

<<o_circle_print_hatch() : calculating and printing the lines>>=		

		x1 = x + (x0*cos_a_ - (-y0)*sin_a_);
		y1 = y + (x0*sin_a_ + (-y0)*cos_a_);
		x2 = x + ((-x0)*cos_a_ - (-y0)*sin_a_);
		y2 = y + ((-x0)*sin_a_ + (-y0)*cos_a_);

		fprintf(fp, "newpath\n");
		fprintf(fp, "%d mils %d mils moveto\n", (int) x1, (int) y1);
		fprintf(fp, "%d mils %d mils lineto\n", (int) x2, (int) y2);
		fprintf(fp, "stroke\n");

		
		y0 = y0 + pitch1;
	}
@


@section Function @code{o_circle_print_old()}

@defun o_circle_print_old w_current fp o_current origin_x origin_y
@end defun

<<o_circle_basic.c : o_circle_print_old()>>=
void
o_circle_print_old(TOPLEVEL *w_current, FILE *fp, OBJECT *o_current,
	int origin_x, int origin_y)
{
  if (o_current == NULL) {
    printf("got null in o_circle_print\n");
    return;
  }

  fprintf(fp, "gsave\n");
  if (w_current->print_color) {
    f_print_set_color(fp, o_current->color);
  }

  f_print_set_line_width(fp, o_current->line_width);

  fprintf(fp, "newpath\n");
  fprintf(fp, "%d mils %d mils\n", o_current->circle->center_x-origin_x, 
          o_current->circle->center_y-origin_y);
  fprintf(fp, "%d mils\n", o_current->circle->radius);
  fprintf(fp, "0 360 arc\n");
  fprintf(fp, "stroke\n");
  fprintf(fp, "grestore\n");
}

@ %def o_circle_print_old


@section Function @code{o_circle_image_write()}

@defun o_circle_image_write w_current o_current origin_x origin_y color_mode
@end defun

<<o_circle_basic.c : o_circle_image_write()>>=
void
o_circle_image_write(TOPLEVEL *w_current, OBJECT *o_current,
                     int origin_x, int origin_y, int color_mode)
{
  int color;

  if (o_current == NULL) {
    printf("got null in o_circle_image_write\n");
    return;
  }

  if (color_mode == TRUE) {
    color = o_image_geda2gd_color(o_current->color);
  } else {
    color = image_black;
  }

#ifdef HAS_LIBGDGEDA
  gdImageArc(current_im_ptr, 
             o_current->circle->screen_x, 
             o_current->circle->screen_y,
             SCREENabs(w_current, o_current->circle->radius)*2,
             SCREENabs(w_current, o_current->circle->radius)*2,
             0, 360, 
             color);
#endif
	
}

@ %def o_circle_image_write


@section Function @code{o_circle_rotate()}

@defun o_circle_rotate w_current centerx centery angle object
@end defun

<<o_circle_basic.c : o_circle_rotate()>>=
/* takes in screen coordinates for the centerx,y, and then does the rotate 
 * in world space */
/* also ignores angle argument... for now, rotate only in 90 degree 
 * increments */
void
o_circle_rotate(TOPLEVEL *w_current, int centerx, int centery, int angle,
                OBJECT *object)
{
  int world_centerx, world_centery;
  int newx, newy;
  int radius;
  int x, y;

  SCREENtoWORLD(w_current, centerx, centery, 
                &world_centerx,
                &world_centery);  
	
  radius = object->circle->radius;
	
  /* translate object to origin */
  o_circle_translate_world(w_current, -world_centerx, -world_centery, object);

  /* translate radius point */
  x = object->circle->center_x;
  y = object->circle->center_y;

  rotate_point_90(x, y, angle, &newx, &newy);

  /* fix up other points... */
  object->circle->center_x = newx;
  object->circle->center_y = newy;

  o_circle_translate_world(w_current, world_centerx, world_centery, object);

}

@ %def o_circle_rotate


@section Function @code{o_circle_rotate_world()}

@defun o_circle_rotate_world w_current world_centerx world_centery angle object
@end defun

<<o_circle_basic.c : o_circle_rotate_world()>>=
void
o_circle_rotate_world(TOPLEVEL *w_current, 
                      int world_centerx, int world_centery, int angle,
                      OBJECT *object)
{
  int newx, newy;
  int radius;
  int x, y;

  if (angle == 0)
  return;

  radius = object->circle->radius;

  /* translate object to origin */
  o_circle_translate_world(w_current, -world_centerx, -world_centery, object);

  /* translate radius point */
  x = object->circle->center_x;
  y = object->circle->center_y; /* careful */

  rotate_point_90(x, y, angle, &newx, &newy);

  /* fix up other points... */
  object->circle->center_x = newx;
  object->circle->center_y = newy;

  o_circle_translate_world(w_current, world_centerx, world_centery, object);

}

@ %def o_circle_rotate_world


@section Function @code{o_circle_mirror()}

@defun o_circle_mirror w_current centerx centery object
@end defun

<<o_circle_basic.c : o_circle_mirror()>>=
void
o_circle_mirror(TOPLEVEL *w_current, int centerx, int centery, OBJECT *object)
{
  int world_centerx, world_centery;
  int newx, newy;
  int radius;
  int x, y;

  SCREENtoWORLD(w_current, centerx, centery, 
                &world_centerx,
                &world_centery);  

  radius = object->circle->radius; 

  /* translate object to origin */
  o_circle_translate_world(w_current, -world_centerx, -world_centery, object);

  /* translate radius point */
  x = object->circle->center_x;
  y = object->circle->center_y; /* careful */

  /* mirror it */
  newx = object->circle->center_x = -x;	
  newy = object->circle->center_y = y; 

  o_circle_translate_world(w_current, world_centerx, world_centery, object);

}

@ %def o_circle_mirror


@section Function @code{o_circle_mirror_world()}

@defun o_circle_mirror_world w_current world_centerx world_centery object
@end defun

<<o_circle_basic.c : o_circle_mirror_world()>>=
void
o_circle_mirror_world(TOPLEVEL *w_current, int world_centerx,
                      int world_centery, OBJECT *object)
{
  int newx, newy;
  int radius;
  int x, y;

  radius = object->circle->radius;

  /* translate object to origin */
  o_circle_translate_world(w_current, -world_centerx, -world_centery, object);

  /* translate radius point */
  x = object->circle->center_x;
  y = object->circle->center_y; /* careful */

  /* mirror it */
  newx = object->circle->center_x = -x;	
  newy = object->circle->center_y = y; 

  o_circle_translate_world(w_current, world_centerx, world_centery, object);

}

@ %def o_circle_mirror_world


@section Function @code{o_circle_modify()}

@defun o_circle_modify w_current object x y whichone
@end defun

<<o_circle_basic.c : o_circle_modify()>>=
void
o_circle_modify(TOPLEVEL *w_current, OBJECT *object, 
                int x, int y, int whichone)
{
  int left, right, top, bottom;
  int radius;

  radius = snap_grid(w_current, WORLDabs(w_current, w_current->distance));

  if (radius == 0) {
    s_log_message("Request radius is too small for current grid snap\n"); 
    s_log_message("Please change the Snap Grid Spacing...\n"); 
    s_log_message("Circle might not be snapped on the grid\n");
    radius = WORLDabs(w_current, w_current->distance);
  }

  object->circle->radius = radius;

  get_circle_bounds(w_current, object->circle, &left, &top, &right, &bottom);
	
  object->left = left;
  object->top = top;
  object->right = right;
  object->bottom = bottom;	
}

@ %def o_circle_modify
