@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File g_rc.c,,,Top
@chapter File @file{g_rc.c}

@section File header

<<g_rc.c : *>>=
<<g_rc.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/g_rc.nw instead */

<<g_rc.c : include directives>>

<<g_rc.c : g_rc_parse_general()>>
<<g_rc.c : g_rc_parse_path()>>
<<g_rc.c : g_rc_parse_system_rc()>>
<<g_rc.c : g_rc_parse_home_rc()>>
<<g_rc.c : g_rc_parse_local_rc()>>
<<g_rc.c : g_rc_parse_specified_rc()>>
<<g_rc.c : g_rc_parse()>>

<<g_rc.c : g_rc_component_library()>>
<<g_rc.c : g_rc_component_library_search()>>
<<g_rc.c : g_rc_source_library()>>
<<g_rc.c : g_rc_source_library_search()>>
<<g_rc.c : g_rc_world_size()>>

<<g_rc.c : g_rc_default_series_name()>>
<<g_rc.c : g_rc_untitled_name()>>
<<g_rc.c : g_rc_font_directory()>>
<<g_rc.c : g_rc_scheme_directory()>>
<<g_rc.c : g_rc_bitmap_directory()>>
<<g_rc.c : g_rc_bus_ripper_symname()>>

<<g_rc.c : g_rc_reset_component_library()>>
<<g_rc.c : g_rc_reset_source_library()>>


@


<<g_rc.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * libgeda - gEDA's Library
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<g_rc.c : include directives>>=
#include <config.h>

#include <stdio.h>
#include <sys/stat.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <gtk/gtk.h>
#include <guile/gh.h>

#include "defines.h"
#include "struct.h"
#include "globals.h"
#include "o_types.h"
#include "colors.h"

#include "../include/i_vars.h"
#include "../include/papersizes.h"
#include "../include/prototype.h"

@

/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_general()}

@defun g_rc_parse_general w_current fname ok_msg err_msg
@end defun

/* 
 * This is the fcn which actually reads in the RC file.  First, it looks in
 * a list of previously read RC files.  If the file has already been read,
 * it just says OK.  After reading the file, it places the filename in 
 * the list of read files.
 */
<<g_rc.c : g_rc_parse_general()>>=
int
g_rc_parse_general(TOPLEVEL *w_current, const char *fname, 
                   const char *ok_msg, const char *err_msg)
{
  int found_rc = 0;
  char *tmp;
  GList *found_rc_filename_element;
  char *rc_file_directory;
  char *msg;

  if (w_current->wid == -1) {
    /* This is a preview window. Don't do any RC file processing */
    return;
  }


  /* First see if fname is in list of previously read files. */
  found_rc_filename_element = (GList *) g_list_find_custom(w_current->RC_list, 
                                                           (gconstpointer) fname,
                                                           (GCompareFunc) strcmp);
  if (found_rc_filename_element != NULL) {
    /* We've already read this one in. */
    found_rc = 1;
    msg = u_basic_strdup("RC file [%s] already read in.\n");
    s_log_message(msg, fname);
    return found_rc;
  }

  /* This is a new RC file.  First change directory to its directory. */
  rc_file_directory = f_get_directory_from_path(fname);
  if (rc_file_directory) { 
    chdir(rc_file_directory);  
    /* Probably should do some checking of chdir return values */
  }

  /* Now try to read in contents of RC file.  */
  if (access(fname, R_OK) == 0) {
    /* TODO: fix g_read_file to accept "const char *" */
    tmp = u_basic_strdup(fname);
    g_read_file(tmp);
    free(tmp);
    found_rc = 1;
    s_log_message(ok_msg, fname);

    /* Everything was OK.  Now add this file to list of read RC files. */
    w_current->RC_list = g_list_append(w_current->RC_list, u_basic_strdup(fname) );

  } else {
    s_log_message(err_msg, fname);
  }

  return found_rc;
}


@ %def g_rc_parse_general

/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_path()}

@defun g_rc_parse_path 
You should not free the returned character string.
@end defun
<<g_rc.c : g_rc_parse_path()>>=
char *
g_rc_parse_path()
{
  char *rc_path = NULL;
  
  if (strcmp(GEDARCDIR, "none") == 0) {
    /* rc dir not specified at configure time, so search for config in */
    /* the normal GEDADATA directory */
    rc_path = getenv("GEDADATA");
  } else {
    /* rc path specified at configure time, always return specified path */
    rc_path = GEDARCDIR;
  }

  return(rc_path);
}

@ %def g_rc_parse_path


/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_system_rc()}

@defun g_rc_parse_system_rc w_current rcname
@end defun

<<g_rc.c : g_rc_parse_system_rc()>>=
static int
g_rc_parse_system_rc(TOPLEVEL *w_current, char* rcname)
{
  int found_rc;
  char *filename;
  char *geda_data = getenv("GEDADATA");
  char *path_to_rc;
  char *ok_msg;
  char *err_msg;

  if (geda_data == NULL) {
    fprintf(stderr, "You must set the GEDADATA environment variable!\n");
    exit(-1);
  }

  path_to_rc = g_rc_parse_path(); /* do not free path_to_rc */

  filename = f_normalize_filename(u_basic_strdup_multiple(path_to_rc,
				                          PATH_SEPARATER_STRING, 
                                                          "system-", rcname,
                                                          NULL)
                                  );
  
  
  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read system-", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find required system-",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(w_current, filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);  
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_system_rc

/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_home_rc()}

@defun g_rc_parse_home_rc w_current rcname
@end defun

<<g_rc.c : g_rc_parse_home_rc()>>=
static int
g_rc_parse_home_rc(TOPLEVEL *w_current, char* rcname)
{
  int found_rc;
  char *filename;
  char *HOME;
  char *ok_msg;
  char *err_msg;

  HOME = (char *) getenv("HOME");
  if (HOME == NULL) {
    return 0;
  }

  filename = f_normalize_filename(u_basic_strdup_multiple(HOME,
				                          PATH_SEPARATER_STRING,
                                                          ".gEDA",
				                          PATH_SEPARATER_STRING, 
				                          rcname,
                                                          NULL)
                                  );
  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read ~/.gEDA/", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find optional ~/.gEDA/",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(w_current, filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_home_rc

/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_local_rc()}

@defun g_rc_parse_local_rc w_current rcname
@end defun

<<g_rc.c : g_rc_parse_local_rc()>>=
static int
g_rc_parse_local_rc(TOPLEVEL *w_current, char* rcname)
{
  int found_rc;
  char *filename;
  char *ok_msg;
  char *err_msg;

  filename = f_normalize_filename( u_basic_strdup_multiple(".", PATH_SEPARATER_STRING, 
                                                            rcname, 
				                            NULL)
                                 );

  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read local ", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find optional local ",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(w_current, filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_local_rc




/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse_specified_rc()}

@defun g_rc_parse_specified_rc w_current rcname
@end defun

/*  This fcn tries to open & read the specified rc file.  */
<<g_rc.c : g_rc_parse_specified_rc()>>=
int g_rc_parse_specified_rc(TOPLEVEL *w_current, char *rcname)
{
  int found_rc = 0;
  char *filename;
  char *ok_msg;
  char *err_msg;

  if (rcname == NULL) {
    return 0;
  }

  filename = f_normalize_filename(rcname);

  ok_msg = u_basic_strdup_multiple("Read specified ", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find specified ",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(w_current, filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);
  free(filename);

  return found_rc;
}

@ %def g_rc_parse_specified_rc



/* ----------------------------------------------------------- */
@section Function @code{g_rc_parse()}

@defun g_rc_parse w_current rcname specified_rc_filename
@end defun

<<g_rc.c : g_rc_parse()>>=
void
g_rc_parse(TOPLEVEL *w_current, char* rcname, char* specified_rc_filename)
{
  int found_rc = 0;
  char *rc_path;
  char *geda_rcdata;

  rc_path = f_normalize_filename(g_rc_parse_path()); /* do not free rc_path */

  /* set the GEDADATARC environment variable so that the rc files */
  /* know where to look for others */

  geda_rcdata = u_basic_strdup_multiple("GEDADATARC=", rc_path, NULL);
  putenv(geda_rcdata);
  
  /* visit rc files in order */
  /* Changed by SDB 1.2.2005 in response to Peter Kaiser's bug report.
   * Read gafrc files first */
  found_rc |= g_rc_parse_system_rc(w_current, "gafrc");
  found_rc |= g_rc_parse_home_rc(w_current, "gafrc");
  found_rc |= g_rc_parse_local_rc(w_current, "gafrc");
  /* continue support for individual rc files for each program.  */
  found_rc |= g_rc_parse_system_rc(w_current, rcname);
  found_rc |= g_rc_parse_home_rc(w_current, rcname);
  found_rc |= g_rc_parse_local_rc(w_current, rcname);

  /* New fcn introduced by SDB to consolidate this & make it available 
   * for other programs */
  found_rc |= g_rc_parse_specified_rc(w_current, specified_rc_filename);


  /* Oh well, I couldn't find any rcfile, exit! */
  if (!found_rc) {
    /* TODO: these two are basically the
     * same. Inefficient! */
    s_log_message("Could not find any %s file!\n", rcname);
    fprintf(stderr, "Could not find a %s file\n", rcname);
    exit(-1);
  }
}


@ %def g_rc_parse


/* ----------------------------------------------------------- */
@section Function @code{g_rc_component_library()}

@defun g_rc_component_library path
@end defun

<<g_rc.c : g_rc_component_library()>>=
SCM
g_rc_component_library(SCM path)
{
  int ret;
  struct stat buf;
  char *cwd;
  char *string = gh_scm2newstr(path, NULL);
  char *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not an unique path? */
  if (!s_clib_uniq(string)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

#ifdef __MINGW32__
  if (string[1] == ':' && (string[2] == PATH_SEPARATER_CHAR ||
 			   string[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
  if (string[0] == PATH_SEPARATER_CHAR) {
#endif
    s_clib_add_entry(string);
  } else {
    cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
    u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
    temp = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, string, NULL);
    s_clib_add_entry(temp);
    free(temp);
    free(cwd);
  }

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_component_library

/* ----------------------------------------------------------- */
@section Function @code{g_rc_component_library_search()}

@defun g_rc_component_library_search path
@end defun

<<g_rc.c : g_rc_component_library_search()>>=
SCM
g_rc_component_library_search(SCM path)
{
  int ret;
  struct stat buf;
  DIR *top_ptr;
  struct dirent *dptr;
  char *string = gh_scm2newstr(path, NULL);
  char *fullpath;
  char *cwd, *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  top_ptr = opendir(string);

  if (top_ptr == NULL) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  while((dptr = readdir(top_ptr))) {

    /* don't do . and .. and special case font */
    if ((strcmp(dptr->d_name, ".") != 0) && 
        (strcmp(dptr->d_name, "..") != 0) &&
        (strcmp(dptr->d_name, "font") != 0)) {

          fullpath=(char *)malloc(sizeof(char)*(strlen(string)+
                                                strlen(dptr->d_name)+2));
          sprintf(fullpath, "%s%c%s", string, PATH_SEPARATER_CHAR, 
	          dptr->d_name);
          stat(fullpath, &buf);
          if (S_ISDIR(buf.st_mode)) { 
            if (s_clib_uniq(fullpath)) {

#ifdef __MINGW32__
              if (fullpath[1] == ':' &&
                  (fullpath[2] == PATH_SEPARATER_CHAR ||
                   fullpath[2] == OTHER_PATH_SEPARATER_CHAR))  {
#else
              if (fullpath[0] == PATH_SEPARATER_CHAR) {
#endif
                s_clib_add_entry(fullpath);
#if DEBUG
                printf("absolute: %s\n", fullpath);
#endif
              } else {
                cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
		u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
                temp = u_basic_strdup_multiple(cwd, 
                                               PATH_SEPARATER_STRING, 
					       fullpath, NULL);
#if DEBUG
                printf("relative: %s\n", temp);
#endif
                s_clib_add_entry(temp);
                free(temp);
                free(cwd);
              }
            } 
          }
          free(fullpath);
        }
  }       

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_component_library_search

/* ----------------------------------------------------------- */
@section Function @code{g_rc_source_library()}

@defun g_rc_source_library path
@end defun

<<g_rc.c : g_rc_source_library()>>=
SCM
g_rc_source_library(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);
  char *temp, *cwd;

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "source-library"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to %s\n",
            string,
            "source-library");
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a unique path? */
  if (!s_slib_uniq(string)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }


#ifdef __MINGW32__
  if (string[1] == ':' && (string[2] == PATH_SEPARATER_CHAR ||
		           string[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
  if (string[0] == PATH_SEPARATER_CHAR) {
#endif
    s_slib_add_entry(string);
  } else {
    cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
    u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
    temp = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, string, NULL);
    s_slib_add_entry(temp);
    free(temp);
    free(cwd);
  }

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_source_library

/* ----------------------------------------------------------- */
@section Function @code{g_rc_source_library_search()}

@defun g_rc_source_library_search path
@end defun

<<g_rc.c : g_rc_source_library_search()>>=
SCM
g_rc_source_library_search(SCM path)
{
  int ret;
  struct stat buf;
  DIR *top_ptr;
  struct dirent *dptr;
  char *string = gh_scm2newstr(path, NULL);
  char *fullpath;
  char *cwd, *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to source-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  top_ptr = opendir(string);

  if (top_ptr == NULL) {
    fprintf(stderr,
            "Invalid path [%s] passed to source-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  while((dptr = readdir(top_ptr))) {

    /* don't do . and .. and special case font */
    if ((strcmp(dptr->d_name, ".") != 0) && 
        (strcmp(dptr->d_name, "..") != 0) &&
        (strcmp(dptr->d_name, "font") != 0)) {

          fullpath=(char *)malloc(sizeof(char)*(strlen(string)+
                                                strlen(dptr->d_name)+2));
          sprintf(fullpath, "%s%c%s", string, PATH_SEPARATER_CHAR, 
		  dptr->d_name);
          stat(fullpath, &buf);
          if (S_ISDIR(buf.st_mode)) { 
            if (s_slib_uniq(fullpath)) {

#ifdef __MINGW32__
              if (fullpath[1] == ':' &&
                  (fullpath[2] == PATH_SEPARATER_CHAR ||
                   fullpath[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
              if (fullpath[0] == PATH_SEPARATER_CHAR) {
#endif
                s_slib_add_entry(fullpath);
#if DEBUG
                printf("absolute: %s\n", fullpath);
#endif
              } else {
                cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
		u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
                temp = u_basic_strdup_multiple(cwd, 
                                               PATH_SEPARATER_STRING, 
					       fullpath, NULL);
#if DEBUG
                printf("relative: %s\n", temp);
#endif
                s_slib_add_entry(temp);
                free(temp);
                free(cwd);
              }
            } 
          }
          free(fullpath);
        }
  }       

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_source_library_search


/* ----------------------------------------------------------- */
@section Function @code{g_rc_world_size()}

@defun g_rc_world_size width height border
@end defun

<<g_rc.c : g_rc_world_size()>>=
SCM
g_rc_world_size(SCM width, SCM height, SCM border)
{
  int i_width, i_height, i_border;
  int init_right, init_bottom;

  /* yes this is legit, we are casing the resulting double to an int */
  i_width  = (int) (gh_scm2double(width ) * MILS_PER_INCH);
  i_height = (int) (gh_scm2double(height) * MILS_PER_INCH);
  i_border = (int) (gh_scm2double(border) * MILS_PER_INCH);

  PAPERSIZEtoWORLD(i_width, i_height, i_border,
                   &init_right, &init_bottom);

#if DEBUG
  printf("%d %d\n", i_width, i_height);
  printf("%d %d\n", init_right, init_bottom);
#endif

  default_init_right  = init_right;
  default_init_bottom = init_bottom;

  return SCM_BOOL_T;
}


@ %def g_rc_world_size

/* ----------------------------------------------------------- */
@section Function @code{g_rc_default_series_name()}

@defun g_rc_default_series_name name
@end defun

<<g_rc.c : g_rc_default_series_name()>>=
SCM
g_rc_default_series_name(SCM name)
{
  char *string = gh_scm2newstr(name, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "series-name"
            );
    return SCM_BOOL_F;
  }

  if (default_series_name) {
    free(default_series_name);
  }

  default_series_name = u_basic_strdup(string);

  free(string);
  return SCM_BOOL_T;
}


@ %def g_rc_default_series_name

/* ----------------------------------------------------------- */
@section Function @code{g_rc_untitled_name()}

@defun g_rc_untitled_name name
@end defun

<<g_rc.c : g_rc_untitled_name()>>=
SCM
g_rc_untitled_name(SCM name)
{
  char *string = gh_scm2newstr(name, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "untitled-name"
            );
    return SCM_BOOL_F;
  }

  if (default_untitled_name) {
    free(default_untitled_name);
  }

  default_untitled_name = u_basic_strdup(string);

  free(string);
  return SCM_BOOL_T;
}


@ %def g_rc_untitled_name


/* ----------------------------------------------------------- */
@section Function @code{g_rc_font_directory()}

@defun g_rc_font_directory path
@end defun

<<g_rc.c : g_rc_font_directory()>>=
SCM
g_rc_font_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "font-direcoty"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to font-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_font_directory) {
    free(default_font_directory);
  }
  default_font_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}

@
@ %def g_rc_font_directory

/* ----------------------------------------------------------- */
@section Function @code{g_rc_scheme_directory()}

@defun g_rc_scheme_directory path
@end defun

<<g_rc.c : g_rc_scheme_directory()>>=
SCM
g_rc_scheme_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "scheme-directory"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to scheme-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_scheme_directory) {
    free(default_scheme_directory);
  }
  default_scheme_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_scheme_directory

/* ----------------------------------------------------------- */
@section Function @code{g_rc_bitmap_directory()}

@defun g_rc_scheme_directory path
@end defun

<<g_rc.c : g_rc_bitmap_directory()>>=
SCM
g_rc_bitmap_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "bitmap-directory"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to bitmap-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_bitmap_directory) {
    free(default_bitmap_directory);
  }
  default_bitmap_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_bitmap_directory

/* ----------------------------------------------------------- */
@section Function @code{g_rc_bus_ripper_symname()}

@defun g_rc_bus_ripper_symname mode
@end defun

<<g_rc.c : g_rc_bus_ripper_symname()>>=
SCM
g_rc_bus_ripper_symname(SCM scmsymname)
{
  char *symname = gh_scm2newstr(scmsymname, NULL);

  if (symname == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "bus-ripper-symname"
            );
    return SCM_BOOL_F;
  }

  if (default_bus_ripper_symname) {
    free(default_bus_ripper_symname);
  }
  default_bus_ripper_symname = u_basic_strdup(symname);

  if (symname) {
    free(symname);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_bus_ripper_symname



/* ----------------------------------------------------------- */
@section Function @code{g_rc_reset_component_library()}

@defun g_rc_reset_component_library 
@end defun

<<g_rc.c : g_rc_reset_component_library()>>=
SCM
g_rc_reset_component_library(void)
{
  s_clib_cache_free();
  s_clib_free();
  s_clib_init();
  
  return SCM_BOOL_T;
}


@ %def g_rc_reset_component_library


/* ----------------------------------------------------------- */
@section Function @code{g_rc_reset_source_library()}

@defun g_rc_reset_source_library 
@end defun

<<g_rc.c : g_rc_reset_source_library()>>=
SCM
g_rc_reset_source_library(void)
{
  s_slib_free();
  s_slib_init();
  
  return SCM_BOOL_T;
}


@ %def g_rc_reset_source_library




