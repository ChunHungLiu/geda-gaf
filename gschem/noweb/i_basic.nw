@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File i_basic.c,,,Top
@chapter File @file{i_basic.c}

@section File header

<<i_basic.c : *>>=
<<i_basic.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/i_basic.nw instead */

<<i_basic.c : include directives>>
<<i_basic.c : i_update_status()>>
<<i_basic.c : i_update_status2()>>
<<i_basic.c : i_update_left_button()>>
<<i_basic.c : i_update_middle_button()>>
<<i_basic.c : i_update_right_button()>>
<<i_basic.c : i_update_toolbar()>>
<<i_basic.c : i_update_cursor()>>
<<i_basic.c : i_set_filename()>>

@


<<i_basic.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<i_basic.c : include directives>>=
#include <config.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/x_states.h"
#include "../include/prototype.h"
#include "../include/globals.h"
@


@section Function @code{i_update_status()}

@defun i_update_status w_current string
@end defun

<<i_basic.c : i_update_status()>>=
void
i_update_status(TOPLEVEL *w_current, const char *string)
{
  if (!w_current->status_label) {
    return;
  }

  if (string) {
    w_current->DONT_RESIZE=1;
    gtk_label_set(GTK_LABEL(w_current->status_label),
                  (char *) string);
  }
}


@ %def i_update_status


@section Function @code{i_update_status2()}

@defun i_update_status2 w_current string
@end defun

<<i_basic.c : i_update_status2()>>=
/* HACK: This one allows the expose events to happen. Probably should
 * create one function for both...  Now it's exactly the same as above
 * */
void
i_update_status2(TOPLEVEL *w_current, const char *string)
{
  if (string) {
    w_current->DONT_RESIZE = 1;
#if 0
    w_current->DONT_EXPOSE = 1;
#endif
    gtk_label_set(GTK_LABEL(w_current->status_label),
                  (char *) string);
  }
}


@ %def i_update_status2


@section Function @code{i_update_left_button()}

@defun i_update_left_button string
@end defun

<<i_basic.c : i_update_left_button()>>=
void
i_update_left_button(const char *string)
{
}


@ %def i_update_left_button


@section Function @code{i_update_middle_button()}

@defun i_update_middle_button w_current func_ptr string
@end defun

<<i_basic.c : i_update_middle_button()>>=
void
i_update_middle_button(TOPLEVEL *w_current, void *func_ptr, const char *string)
{
  char *temp_string;

  if (func_ptr == NULL) {
    return;
  }

  if (string == NULL) {
    return;
  }	

  if (!w_current->middle_label) {
    return;
  }

  switch(w_current->middle_button) {

    /* remove this case eventually and make it a null case */
    case(ACTION):
    w_current->DONT_RESIZE = 1;
    gtk_label_set(GTK_LABEL(w_current->middle_label),
                  _("Action"));
    break;

#ifdef HAS_LIBSTROKE
    case(STROKE):
    w_current->DONT_RESIZE = 1;

    gtk_label_set(GTK_LABEL(w_current->middle_label),
                  _("Stroke"));
    break;
#else 
    /* remove this case eventually and make it a null case */
    case(STROKE):
    w_current->DONT_RESIZE = 1;
    gtk_label_set(GTK_LABEL(w_current->middle_label),
                  _("none"));
    break;
#endif
		
    case(REPEAT):
    w_current->DONT_RESIZE = 1;

    temp_string = u_basic_strdup_multiple(
                                          _("Repeat/"), string, NULL);

    gtk_label_set(GTK_LABEL(w_current->middle_label),
                  temp_string);
    w_current->last_callback = func_ptr;
    free(temp_string);
    break;

  }

}


@ %def i_update_middle_button


@section Function @code{i_update_right_button()}

@defun i_update_right_button string
@end defun

<<i_basic.c : i_update_right_button()>>=
void
i_update_right_button(const char *string)
{
}


@ %def i_update_right_button


@section Function @code{i_update_toolbar()}

@defun i_update_toolbar w_current
@end defun

<<i_basic.c : i_update_toolbar()>>=
void
i_update_toolbar(TOPLEVEL *w_current)
{
  if (!w_current->toolbars) 
	return;

  switch(w_current->event_state) {
 	case(NONE):
 	case(SELECT):
 	case(STARTSELECT): 
 	case(TEXTENTRY): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_select), TRUE);
	break;

 	case(DRAWNET): 
 	case(STARTDRAWNET): 
 	case(NETCONT): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_net), TRUE);
	break;

 	case(DRAWBUS): 
 	case(STARTDRAWBUS): 
 	case(BUSCONT): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_bus), TRUE);
	break;

 	case(DRAWCOMP): /* TODO */
 	case(DRAWLINE): /* TODO */
 	case(DRAWBOX): /* TODO */
 	case(DRAWPIN): /* TODO */
 	case(DRAWCIRCLE): /* TODO */
 	case(DRAWARC): /* TODO */
 	case(MOVE): /* TODO */
 	case(COPY): /* TODO */
 	case(ZOOM): /* TODO */
 	case(PAN): /* TODO */
 	case(STARTPAN): /* TODO */
 	case(STARTCOPY): /* TODO */
 	case(STARTMOVE): /* TODO */
 	case(ENDCOPY): /* TODO */
 	case(ENDMOVE): /* TODO */
 	case(ENDLINE): /* TODO */
 	case(ENDBOX): /* TODO */
 	case(ENDCIRCLE): /* TODO */
 	case(ENDARC): /* TODO */
 	case(ENDPIN): /* TODO */
 	case(ENDCOMP): /* TODO */
 	case(DRAWATTRIB): /* TODO */
 	case(ENDATTRIB): /* TODO */
 	case(DRAWTEXT): /* TODO */
 	case(ENDTEXT): /* TODO */
 	case(ENDROTATEP): /* TODO */
 	case(ENDMIRROR): /* TODO */
 	case(ZOOMBOXSTART): /* TODO */
 	case(ZOOMBOXEND): /* TODO */
 	case(STARTROUTENET): /* TODO */
 	case(ENDROUTENET): /* TODO */
 	case(MOUSEPAN): /* TODO */
 	case(STARTPASTE): /* TODO */
 	case(ENDPASTE): /* TODO */
 	case(GRIPS): /* TODO */
	default:
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_select), TRUE);
        break;
  }
}


@ %def i_update_toolbar


@section Function @code{i_set_filename()}

@defun i_set_filename w_current string
@end defun

<<i_basic.c : i_set_filename()>>=
void
i_set_filename(TOPLEVEL *w_current, const char *string)
{
  char trunc_string[41];
  int len;
  int i;

  if (!w_current->filename_label) {
    return;
  }

  if (string) {
    len = strlen(string);
    w_current->DONT_RESIZE = 1;

    if (w_current->filename_label) {
      if (len > 40) {

        trunc_string[0] = '.';
        trunc_string[1] = '.';
        trunc_string[2] = '.';

        trunc_string[40] = '\0';
        for (i = 39 ; i > 2; i--) {
          if (len >= 0) {
            trunc_string[i] = string[len];
          } else {
            break;
          }
          len--;
        }

        gtk_label_set(GTK_LABEL(w_current->
                                filename_label),
                      trunc_string);

      } else {

        gtk_label_set(GTK_LABEL(w_current->
                                filename_label),
                      (char *) string);
      }
    }
  }
}


@ %def i_set_filename


@section Function @code{i_update_cursor()}

@defun i_update_cursor w_current
@end defun

<<i_basic.c : i_update_cursor()>>=

#if 0
/* This data is in X bitmap format, and can be created with the 'bitmap'
     utility. */
  #define cursor1_width 16
  #define cursor1_height 16
  static unsigned char cursor1_bits[] = {
   0x00, 0x00, 0x08, 0x38, 0x18, 0x08, 0x38, 0x18, 0x78, 0x08, 0xf8, 0x38,
   0xf8, 0x01, 0xf8, 0x03, 0xf8, 0x07, 0xf8, 0x00, 0xd8, 0x00, 0x88, 0x01,
   0x80, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00};

  static unsigned char cursor1mask_bits[] = {
   0x0c, 0x7c, 0x1c, 0x7c, 0x3c, 0x7c, 0x7c, 0x3c, 0xfc, 0x7c, 0xfc, 0x7d,
   0xfc, 0x7f, 0xfc, 0x07, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x01, 0xdc, 0x03,
   0xcc, 0x03, 0x80, 0x07, 0x80, 0x07, 0x00, 0x03};
#endif

void
i_update_cursor(TOPLEVEL *w_current)
{
#if 0
  if (!w_current->cursors) 
	return;
#endif

#if 0
GdkCursor *cursor;

    GdkPixmap *source, *mask;
    GdkColor fg = { 0, 0, 0, 0 }; /* Red. */
    GdkColor bg = { 0, 65535, 65535, 65535 }; /* Blue. */


    source = gdk_bitmap_create_from_data (NULL, cursor1_bits,
                                          cursor1_width, cursor1_height);
    mask = gdk_bitmap_create_from_data (NULL, cursor1mask_bits,
                                        cursor1_width, cursor1_height);
    cursor = gdk_cursor_new_from_pixmap (source, mask, &fg, &bg, 3, 1);
    gdk_pixmap_unref (source);
    gdk_pixmap_unref (mask);

    gdk_window_set_cursor (w_current->window, cursor);
#endif


   GdkCursor* cursor;
   cursor = gdk_cursor_new(GDK_ARROW);
   gdk_window_set_cursor(w_current->window, cursor);
   gdk_cursor_destroy(cursor);


#if 0
  switch(w_current->event_state) {
 	case(NONE):
 	case(SELECT):
 	case(STARTSELECT): 
 	case(TEXTENTRY): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_select), TRUE);
	break;

 	case(DRAWNET): 
 	case(STARTDRAWNET): 
 	case(NETCONT): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_net), TRUE);
	break;

 	case(DRAWBUS): 
 	case(STARTDRAWBUS): 
 	case(BUSCONT): 
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_bus), TRUE);
	break;

 	case(DRAWCOMP): /* TODO */
 	case(DRAWLINE): /* TODO */
 	case(DRAWBOX): /* TODO */
 	case(DRAWPIN): /* TODO */
 	case(DRAWCIRCLE): /* TODO */
 	case(DRAWARC): /* TODO */
 	case(MOVE): /* TODO */
 	case(COPY): /* TODO */
 	case(ZOOM): /* TODO */
 	case(PAN): /* TODO */
 	case(STARTPAN): /* TODO */
 	case(STARTCOPY): /* TODO */
 	case(STARTMOVE): /* TODO */
 	case(ENDCOPY): /* TODO */
 	case(ENDMOVE): /* TODO */
 	case(ENDLINE): /* TODO */
 	case(ENDBOX): /* TODO */
 	case(ENDCIRCLE): /* TODO */
 	case(ENDARC): /* TODO */
 	case(ENDPIN): /* TODO */
 	case(ENDCOMP): /* TODO */
 	case(DRAWATTRIB): /* TODO */
 	case(ENDATTRIB): /* TODO */
 	case(DRAWTEXT): /* TODO */
 	case(ENDTEXT): /* TODO */
 	case(ENDROTATEP): /* TODO */
 	case(ENDMIRROR): /* TODO */
 	case(ZOOMBOXSTART): /* TODO */
 	case(ZOOMBOXEND): /* TODO */
 	case(STARTROUTENET): /* TODO */
 	case(ENDROUTENET): /* TODO */
 	case(MOUSEPAN): /* TODO */
 	case(STARTPASTE): /* TODO */
 	case(ENDPASTE): /* TODO */
 	case(GRIPS): /* TODO */
	default:
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
					 w_current->toolbar_select), TRUE);
        break;
  }
#endif

}


@ %def i_update_cursor
