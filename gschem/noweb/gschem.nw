@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File gschem.c,,,Top
@chapter File @file{gschem.c}

@section File header

<<gschem.c : *>>=
<<gschem.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/gschem.nw instead */

<<gschem.c : include directives>>
<<gschem.c : gschem_quit()>>
<<gschem.c : main_func()>>
<<gschem.c : main()>>

@


<<gschem.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<gschem.c : include directives>>=
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/globals.h"
#include "../include/i_vars.h"
#include "../include/prototype.h"

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#ifdef HAS_LIBSTROKE
/* libstroke prototype */
void stroke_init(void);
#endif

@


@section Function @code{gschem_quit()}

@defun gschem_quit 
@end defun

<<gschem.c : gschem_quit()>>=
void
gschem_quit(void)
{
  s_clib_free();
  s_slib_free();
  s_menu_free();
  /* o_text_freeallfonts();*/
  s_attrib_free();
  s_papersizes_free();
  x_stroke_free_all();
  x_dialog_hotkeys_free_all();
  s_color_destroy_all();
  o_undo_cleanup();
  /* s_stroke_free(); no longer needed */

  i_vars_freenames();

  /* x_window_free_head(); can't do this since it causes a
   * condition in which window_head->... is still being refered
   * after this */

  /* enable this to get more memory usage from glib */
  /* You also have to enable something in glib I think */
  /* g_mem_profile();*/
	 

  x_log_free();
  gtk_main_quit();
}


@ %def gschem_quit


@section Function @code{main_func()}

@defun main_func argc argv
@end defun

<<gschem.c : main_func()>>=
void
main_prog(int argc, char *argv[])
{
  int i;
  char *cwd = NULL;
  TOPLEVEL *w_current = NULL;
  char *input_str = NULL;
  int argv_index;
  int first_page = 1;
  char *geda_data = NULL;
  char *filename;

#if ENABLE_NLS
  /* this should be equivalent to setlocale (LC_ALL, "") */
  const char *locale = gtk_set_locale();

  /* This must be the same for all locales */
  setlocale(LC_NUMERIC, "POSIX");

  /* Disable gtk's ability to set the locale. */ 
  /* If gtk is allowed to set the locale, then it will override the     */
  /* setlocale for LC_NUMERIC (which is important for proper PS output. */
  /* This may look funny here, given we make a call to gtk_set_locale() */
  /* above.  I don't know yet, if this is really the right thing to do. */
#ifdef HAS_GTK22
  gtk_disable_setlocale(); 
#endif

#endif


  gtk_init(&argc, &argv);
  visual = gdk_visual_get_system();

  argv_index = parse_commandline(argc, argv);
  cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
    u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif

  libgeda_init();
  
  /* TODO: Probably the file name shuold be defined elsewhere */
  /* create log file right away even if logging is enabled */
  x_log_init(cwd, "gschem.log");
  s_log_init(cwd, "gschem.log");

#ifdef HAS_LIBSTROKE
  stroke_init(); /* libstroke function */
  /* s_stroke_init(); no longer needed libgeda function */
#endif
	
  s_log_message(
                _("gEDA/gschem version %s\n"), VERSION);
  s_log_message(
                _("gEDA/gschem comes with ABSOLUTELY NO WARRANTY; see COPYING for more details.\n"));
  s_log_message(
                _("This is free software, and you are welcome to redistribute it under certain\n"));
  s_log_message(
                _("conditions; please see the COPYING file for more details.\n\n")); 

  if (!quiet_mode) {
    fprintf(stderr, 
            _("gEDA/gschem version %s\n"), VERSION);
    fprintf(stderr, 
            _("gEDA/gschem comes with ABSOLUTELY NO WARRANTY; see COPYING for more details.\n"));
    fprintf(stderr, 
            _("This is free software, and you are welcome to redistribute it under certain\n"));
    fprintf(stderr, 
            _("conditions; please see the COPYING file for more details.\n\n")); 
  }

#ifdef __MINGW32__
  fprintf(stderr, _("This is the MINGW32 port.\n"));
#endif  

#if DEBUG
  fprintf(stderr, _("Current locale settings: %s\n"), setlocale(LC_ALL, NULL));
#endif

  /* init global buffers */
  o_buffer_init();

  /* register guile (scheme) functions */
  g_register_funcs();

  o_undo_init(); 

  geda_data = getenv("GEDADATA");
  if (geda_data == NULL) {
    fprintf(stderr, _("You must set the GEDADATA environment variable!\n"));
    exit(-1);
  }

  /* Allocate w_current.   */
  w_current = x_window_alloc();
  global_window_current = w_current;

  /* Now read in RC files. */
  g_rc_parse_gtkrc();
  g_rc_parse(w_current, "gschemrc", rc_filename);
  
  input_str = g_strdup_printf("%s%cgschem.scm", default_scheme_directory, 
			      PATH_SEPARATER_CHAR);
  if (g_read_file(input_str) != -1) {
    s_log_message(_("Read init scm file [%s]\n"), input_str);
  } else {
    /* TODO: These two messages are the same. Should be
     * integrated. */
    s_log_message(_("Failed to read init scm file [%s]\n"),
                  input_str);
    fprintf(stderr,
            _("Failed to read init scm file [%s]\n"), input_str);
  }
  free(input_str);

  /* At end, complete set up of window. */
  colormap = gdk_colormap_get_system ();
  x_window_setup_colors();

  x_window_add_head();

  /* w_current was malloced previously.  Here we just fill it out. */
  x_window_fill_out(w_current);
  global_window_current = w_current;
  

  /* so we can call key funcs from guile */
  set_window_current_key(w_current);

  /* o_text_init(); goes away */
  o_text_init();

  x_repaint_background(w_current);

  i = argv_index;
  while (argv[i] != NULL) {
    filename = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING,
                                         argv[i],
                                         NULL);
    if (first_page) {
      if (w_current->page_current->page_filename) {
        free(w_current->page_current->page_filename);
      }

      /* Page structure has already been created...
       * so, just set the filename and open the
       * schematic for the first page */

#if 0
        /* SDB Notes: This is what it used to be.  I have probably broken the MINGW32 stuff */
#ifdef __MINGW32__
      if (argv[i][1] == ':' && (argv[i][2] == PATH_SEPARATER_CHAR ||
			        argv[i][2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
      if (argv[i][0] == PATH_SEPARATER_CHAR) {
#endif
        w_current->page_current->page_filename = 
          u_basic_strdup_multiple(argv[i], NULL);
      } else {
        w_current->page_current->page_filename = 
          u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, argv[i], 
                                  NULL);
      }
#endif

      /* SDB says: always use absolute file names to eliminate confusion */
      w_current->page_current->page_filename = filename;

      /* 
       * SDB notes:  at this point the filename might be unnormalized, like
       * /path/to/foo/../bar/baz.sch.  Bad filenames will be normalized
       * in f_open.  This works for Linux.  Will this work for the MINGW32 port?
       */

      if (!quiet_mode) {
        printf(_("Loading schematic [%s]\n"), filename);
      }

      (void)f_open(w_current,
                   w_current->page_current->page_filename);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);

      a_zoom_extents(w_current,
                     w_current->page_current->object_head,
                     A_PAN_DONT_REDRAW);
      o_undo_savestate(w_current, UNDO_ALL);

      first_page = 0;
    } else {
      /* Much simpler	*/

      /* create new page, and only load if page not loaded */
      if (!s_page_new(w_current, filename)) {
        if (!quiet_mode) {
          printf(_("Loading schematic [%s]\n"), 
                 filename);
        }
        (void)f_open(w_current,
                     w_current->page_current->page_filename);
        i_set_filename(w_current,
                       w_current->page_current->page_filename);
        a_zoom_extents(w_current,
                       w_current->page_current->object_head,
                       A_PAN_DONT_REDRAW);
        o_undo_savestate(w_current, UNDO_ALL);
      }
    }
    i++;
  }

  free(cwd);	

  if (argv[argv_index] == NULL) {
    if (w_current->page_current->page_filename) {
      free(w_current->page_current->page_filename);
    }

    getcwd(w_current->cwd, 256);
#ifdef __MINGW32__
    u_basic_strip_trailing(w_current->cwd, PATH_SEPARATER_CHAR);
#endif

    w_current->page_current->page_filename =
      malloc(sizeof(char) * (
                             strlen(w_current->cwd) +
                             strlen(w_current->untitled_name) +
                             strlen("/_##########.sch") +
                             1));

    w_current->num_untitled++;
    sprintf(w_current->page_current->page_filename,
            "%s%c%s_%d.sch",
            w_current->cwd, PATH_SEPARATER_CHAR,
            w_current->untitled_name,
            w_current->num_untitled);

    i_set_filename(w_current,
                   w_current->page_current->page_filename);
  }

  x_scrollbars_update(w_current);
  o_redraw_all_fast(w_current);

#if DEBUG
  gh_eval_str ("(display \"hello guile\n\")");
#endif

  if (w_current->scheme_directory == NULL) {
    fprintf(stderr, _("Scheme directory NOT set!\n"));
    exit(-1);
  }


  /* Execute a script if it exists */
  if (script_filename) {
    s_log_message(_("Executing guile script [%s]\n"),
                  script_filename);
    g_read_file(script_filename);
  }

  /* open up log window on startup */
  if (w_current->log_window == MAP_ON_STARTUP) {
    x_log_setup_win(w_current);
  }

  /* if there were any symbols which had major changes, put up an error */
  /* dialog box */
  major_changed_dialog(w_current);
    
  /* enter main loop */
  gtk_main();
}


@ %def main_func


@section Function @code{main()}

@defun main argc argv
@end defun

<<gschem.c : main()>>=
int
main (int argc, char *argv[])
{

#if ENABLE_NLS
  setlocale(LC_ALL, "");
  setlocale(LC_NUMERIC, "POSIX");
  bindtextdomain(PACKAGE, LOCALEDIR);
  textdomain(PACKAGE);
#ifdef HAS_GTK22
  bind_textdomain_codeset(PACKAGE, "UTF-8");
#endif
#endif

  /* disable the deprecated warnings in guile 1.6.3 */
  /* Eventually the warnings will need to be fixed */
  if(getenv("GUILE_WARN_DEPRECATED") == NULL)
    putenv("GUILE_WARN_DEPRECATED=no");

  gh_enter(argc, argv, main_prog);
  return 0;
}


@ %def main

