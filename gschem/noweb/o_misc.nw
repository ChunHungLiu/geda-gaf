@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_misc.c,,,Top
@chapter File @file{o_misc.c}

@section File header

<<o_misc.c : *>>=
<<o_misc.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_misc.nw instead */

<<o_misc.c : include directives>>
<<o_misc.c : o_edit()>>
<<o_misc.c : o_lock()>>
<<o_misc.c : o_unlock()>>
<<o_misc.c : o_rotate_90()>>
<<o_misc.c : o_embed()>>
<<o_misc.c : o_unembed()>>
<<o_misc.c : o_mirror()>>
<<o_misc.c : o_edit_show_hidden_lowlevel()>>
<<o_misc.c : o_edit_show_hidden()>>
<<o_misc.c : o_edit_make_visible()>>
<<o_misc.c : o_edit_find_text()>>
<<o_misc.c : find_max()>>
<<o_misc.c : autonumber_text()>>
<<o_misc.c : o_edit_autonumber_text()>>
<<o_misc.c : o_edit_hide_specific_text()>>
<<o_misc.c : o_edit_show_specific_text()>>

@


<<o_misc.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<o_misc.c : include directives>>=
#include <config.h>

#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/x_states.h"
#include "../include/prototype.h"

@


@section Function @code{o_edit()}

@defun o_edit w_current list
@end defun

<<o_misc.c : o_edit()>>=
/* break with the tradition here and input a list */
/* TODO: probably should go back and do the same for o_copy o_move
   o_delete... */
void
o_edit(TOPLEVEL *w_current, SELECTION *list)
{
  char *equal_ptr;
  OBJECT *o_current;
#ifdef HAS_LIBGTKEXTRA
  SELECTION *s_current;
  int object_count=0;
#endif

  if (list == NULL) {
    w_current->event_state = SELECT;
    i_update_status(w_current, "Select Mode");
    w_current->inside_action = 0;
    return;
  }

  o_current = list->selected_object;	
  if (o_current == NULL) {
    fprintf(stderr, "Got an unexpected NULL in o_edit\n");
    exit(-1);
  }

#ifdef HAS_LIBGTKEXTRA
  /* count up how many non-text objects exist in the selection */
  /* list.  Why?  Because if there are multiple objects, invoke the */
  /* multi_multi_edit dialog box */
  s_current = list;
  while (s_current != NULL) {
    if (s_current->selected_object) {
      if (s_current->selected_object->type != OBJ_TEXT) {
        object_count++;	
      }				
    }
    s_current=s_current->next;
  }

  /* now decide what we want to do, either single edit or */
  /* multi multi edit */
  if (object_count == 1 && o_current->type != OBJ_TEXT) {
    multi_attrib_edit(w_current, list);
    return;
  } else if ( object_count > 1 ) {
    multi_multi_edit(w_current, list);
    return;
  }
#endif


  /* for now deal with only the first item */
  switch(o_current->type) {

    /* also add the ability to multi attrib edit: nets, busses, pins */
    case(OBJ_COMPLEX):
    case(OBJ_NET):
    case(OBJ_PIN):
    case(OBJ_BUS):
    multi_attrib_edit(w_current, list);
    break;

    case(OBJ_TEXT):
    if(strchr(o_current->text->string,'=')) {

      /* now really make sure it's an attribute by 
       * checking that there are NO spaces around the ='s 
       */
      equal_ptr = strchr(o_current->text->string, '=');

      /* there is a possiblity for core dump yes? */
      /* by exceeding the size of the text_string? */
      /* or maybe not, since if the ='s is at the end of */
      /* the string, there better be a null after it! */
      if ( (*(equal_ptr + 1) != ' ') &&
           (*(equal_ptr - 1) != ' ') ) {
        attrib_edit_dialog(w_current,o_current, 
                           FROM_MENU);
      } else {
        o_text_edit(w_current, o_current);
      } 
    } else {
      o_text_edit(w_current, o_current);
    }
    break;
  }

  /* has to be more extensive in the future */
  /* some sort of redrawing? */
}


@ %def o_edit


@section Function @code{o_lock()}

@defun o_lock w_current
@end defun

<<o_misc.c : o_lock()>>=
/* This locks the entire selected list.  It does lock components, but does NOT
 * change the color (of primatives of the components) though 
 * this cannot be called recursively */
void
o_lock(TOPLEVEL *w_current)
{
  OBJECT *object = NULL;
  SELECTION *s_current = NULL;

  /* skip over head */
  s_current = w_current->page_current->selection2_head->next;

  while(s_current != NULL) {
    object = s_current->selected_object;
    if (object) {
      /* check to see if locked_color is already being used */
      if (object->locked_color == -1) {
        object->sel_func = NULL;
        object->locked_color = object->color;
        object->color = w_current->lock_color;
        w_current->page_current->CHANGED=1;
      } else {
        s_log_message("Object alreadly locked\n");
      }
    }

    s_current=s_current->next;
  }

  o_unselect_all(w_current);
  o_undo_savestate(w_current, UNDO_ALL);
}

@ %def o_lock



@section Function @code{o_unlock()}

@defun o_unlock w_current
@end defun

<<o_misc.c : o_unlock()>>=
/* You can unlock something by selecting it with a bounding box... */
/* this will probably change in the future, but for now it's a
   something.. :-) */
/* this cannot be called recursively */
void
o_unlock(TOPLEVEL *w_current)
{
  OBJECT *object = NULL;
  SELECTION *s_current = NULL;

  s_current = w_current->page_current->selection2_head->next;

  while(s_current != NULL) {
    object = s_current->selected_object;
    if (object) {
      /* only unlock if sel_func is not set to something */
      if (object->sel_func == NULL) {
        object->sel_func = select_func;
        object->color = object->locked_color;
        object->locked_color = -1;
        w_current->page_current->CHANGED = 1;
      } else {
        s_log_message("Object alreadly unlocked\n");
      }
    }

    s_current=s_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def o_unlock


@section Function @code{o_rotate_90()}

@defun o_rotate_90 w_current list centerx centery
@end defun

<<o_misc.c : o_rotate_90()>>=
void
o_rotate_90(TOPLEVEL *w_current, SELECTION *list, int centerx, int centery)
{
  OBJECT *object;
  SELECTION *s_current;
  int new_angle;
  GList *other_objects=NULL;
  GList *connected_objects=NULL;
  OBJECT *o_current;
        
  /* this is okay if you just hit rotate and have nothing selected */
  if (list == NULL) {
    w_current->event_state = SELECT;
    i_update_status(w_current, "Select Mode");
    w_current->inside_action = 0;
    return;
  }

  s_current = list;

  while (s_current != NULL) {
    object = s_current->selected_object;

    if (!object) {
      fprintf(stderr, "ERROR: NULL object in o_rotate_90!\n");
      return;
    }

    g_list_free(other_objects);
    other_objects = NULL;
    g_list_free(connected_objects);
    connected_objects = NULL;

    switch(object->type) {


      case(OBJ_NET):
        o_cue_undraw(w_current, object);
        o_net_erase(w_current, object);
        o_line_erase_grips(w_current, object);
                                
        /* save the other objects */
        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);
                                
        o_net_rotate(w_current, centerx, centery, 90, object);
        s_conn_update_object(w_current, object);
        o_net_draw(w_current, object);
                                
        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;

      case(OBJ_BUS):
        o_cue_undraw(w_current, object);
        o_bus_erase(w_current, object);
        o_line_erase_grips(w_current, object);
        
        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);
        
        o_bus_rotate(w_current, centerx, centery, 90, object);
        s_conn_update_object(w_current, object);
        o_bus_draw(w_current, object);
        
        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;

      case(OBJ_PIN):
        o_cue_undraw(w_current, object);
        o_pin_erase(w_current, object);
        o_line_erase_grips(w_current, object);
        
        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);
        
        o_pin_rotate(w_current, centerx, centery, 
                     90, object);
        s_conn_update_object(w_current, object);
        o_pin_draw(w_current, object);
        
        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;

      case(OBJ_COMPLEX):
        o_cue_undraw_objects(w_current, object->complex->prim_objs);
	/* erase the current selection */
        o_complex_erase(w_current, object);

        other_objects = s_conn_return_complex_others(other_objects, object);
        
        /* remove all conn references */
        o_current = object->complex->prim_objs;
        while(o_current != NULL) {
          s_conn_remove(w_current, o_current);
          o_current = o_current->next;
        }
      
        /* do the rotate */
        /*w_current->ADDING_SEL=1; NEWSEL: needed? */
        new_angle = (object->complex->angle + 90) % 360;
        o_complex_rotate(w_current, centerx, centery,
                         new_angle, 90, object);
        /*w_current->ADDING_SEL = 0; NEWSEL: needed? */
        s_conn_update_complex(w_current, object->complex->prim_objs);
        o_complex_draw(w_current, object);

        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* now draw the newly connected objects */
        connected_objects = s_conn_return_complex_others(connected_objects,
                                                         object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);
        break;
        
      case(OBJ_LINE):
        o_line_erase_grips(w_current, object);
        o_line_erase(w_current, object);

        o_line_rotate(w_current, centerx, centery, 
                      90, object);

        o_line_draw(w_current, object);
        break;

      case(OBJ_BOX):
				/* erase the current selection */
        o_box_erase_grips(w_current, object);
        o_box_erase(w_current, object);

        o_box_rotate(w_current, centerx, centery, 
                     90, object);

        o_box_draw(w_current, object);
        break;

      case(OBJ_CIRCLE):
        o_circle_erase_grips(w_current, object);
        o_circle_erase(w_current, object);

        o_circle_rotate(w_current, centerx, centery, 
                        90, object);

        o_circle_draw(w_current, object);
        break;

      case(OBJ_ARC):
        o_arc_erase(w_current, object);

#if 0 /* not needed anymore */
	SCREENtoWORLD(w_current, centerx, centery, 
		      &world_centerx, &world_centery);
        o_arc_rotate_world(w_current, world_centerx, world_centery, 90, object);
#endif

        o_arc_rotate(w_current, centerx, centery, 90, object);
        o_arc_draw(w_current, object);
        break;

      case(OBJ_TEXT):
				/* erase the current selection */
        o_text_erase(w_current, object);

        new_angle = (object->text->angle + 90) % 360;
        o_text_rotate(w_current, centerx, centery,
                      new_angle, 90, object);

        o_text_draw(w_current, object);
        break;
    }
    s_current = s_current->next;
  }

  w_current->page_current->CHANGED = 1;
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def o_rotate_90


@section Function @code{o_embed()}

@defun o_embed w_current
@end defun

<<o_misc.c : o_embed()>>=
void
o_embed(TOPLEVEL *w_current)
{
  OBJECT *object = NULL;
  char *new_basename;
  SELECTION *s_current = NULL;

  s_current = w_current->page_current->selection2_head->next;

  while (s_current != NULL) {
    object = s_current->selected_object;

    if (!object) {
      fprintf(stderr, "ERROR: NULL object in o_embed!\n");
      return;
    }

    if (object->type == OBJ_COMPLEX) {
      if (strncmp(object->complex_clib, "EMBEDDED", 8) != 0) {

        if (object->complex_clib) {
          free(object->complex_clib);
        }

        object->complex_clib = 
          u_basic_strdup("EMBEDDED");
        new_basename = u_basic_strdup_multiple(
                                               "EMBEDDED",
                                               object->
                                               complex_basename,
                                               NULL);

        free(object->complex_basename);

        object->complex_basename =
          u_basic_strdup(new_basename);

        free(new_basename);

        w_current->page_current->CHANGED = 1;
      }
    }
    s_current = s_current->next;
  }
}


@ %def o_embed


@section Function @code{o_unembed()}

@defun o_unembed w_current
@end defun

<<o_misc.c : o_unembed()>>=
void
o_unembed(TOPLEVEL *w_current)
{
  OBJECT *object = NULL;
  char *new_basename;
  char *new_clib;
  SELECTION *s_current = NULL;

  s_current = w_current->page_current->selection2_head->next;

  while (s_current != NULL) {
    object = s_current->selected_object;

    if (!object) {
      fprintf(stderr, "ERROR: NULL object in o_embed!\n");
      return;
    }

    if (object->type == OBJ_COMPLEX) {
      if (strncmp(object->complex_clib, "EMBEDDED", 8) == 0) {

        new_basename =
          (char *) malloc(
                          sizeof(char) *
                          (strlen(object->
                                  complex_basename)+1));

        sprintf(new_basename, "%s",
                (object->complex_basename + 8));

        new_clib =
          (char *) s_clib_search(new_basename);

        if (!new_clib) {
          fprintf(stderr, "Could not find component [%s], while trying to unembed.\n",
                  object->complex_basename);
          fprintf(stderr,
                  "Component is still embedded\n");
        } else {
          free(object->complex_basename);

          object->complex_basename = new_basename;

          free(object->complex_clib);

          object->complex_clib = new_clib;

          w_current->page_current->CHANGED = 1;
        }
      }
    }

    s_current=s_current->next;
  }
}


@ %def o_unembed


@section Function @code{o_mirror()}

@defun o_mirror w_current list centerx centery
@end defun

<<o_misc.c : o_mirror()>>=
void
o_mirror(TOPLEVEL *w_current, SELECTION *list, int centerx, int centery)
{
  OBJECT *object;
  SELECTION *s_current;
  OBJECT *o_current = NULL;
  GList *other_objects=NULL;
  GList *connected_objects=NULL;

  if (list == NULL) {
    w_current->event_state = SELECT;
    i_update_status(w_current, "Select Mode");
    w_current->inside_action = 0;
    return;
  }

  s_current = list;

  while (s_current != NULL) {

    object = s_current->selected_object;

    if (!object) {
      fprintf(stderr, "ERROR: NULL object in o_mirror!\n");
      return;
    }
    
    g_list_free(other_objects);
    other_objects = NULL;
    g_list_free(connected_objects);
    connected_objects = NULL;

    switch(object->type) {


      case(OBJ_NET):
        o_cue_undraw(w_current, object);
        o_net_erase(w_current, object);
        o_line_erase_grips(w_current, object);
        
        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);

        o_net_mirror(w_current, centerx, centery, object);
        s_conn_update_object(w_current, object);
        o_net_draw(w_current, object);
        
        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;

      case(OBJ_PIN):
        o_cue_undraw(w_current, object);
        o_pin_erase(w_current, object);
        o_line_erase_grips(w_current, object);
        
        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);

        o_pin_mirror(w_current, centerx, centery, object);
        s_conn_update_object(w_current, object);
        o_pin_draw(w_current, object);

        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;

      case(OBJ_BUS):
        o_bus_erase(w_current, object);
        o_line_erase_grips(w_current, object);

        other_objects = s_conn_return_others(other_objects, object);
        s_conn_remove(w_current, object);
        
        o_bus_mirror(w_current, centerx, centery, object);
        s_conn_update_object(w_current, object);
        o_bus_draw(w_current, object);
        
        /* draw the other objects */
        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* get other connected objects and redraw */
        connected_objects = s_conn_return_others(connected_objects, object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);

        /* finally redraw the cues on the current object */
        o_cue_draw_single(w_current, object); 
        break;
        
      case(OBJ_COMPLEX):
        o_cue_undraw_objects(w_current, object->complex->prim_objs);
        /* erase the current selection */
        o_complex_erase(w_current, object);

        other_objects = s_conn_return_complex_others(other_objects, object);
        
        /* remove all conn references */
        o_current = object->complex->prim_objs;
        while(o_current != NULL) {
          s_conn_remove(w_current, o_current);
          o_current = o_current->next;
        }
      
        o_complex_mirror(w_current, centerx, centery, object);
        s_conn_update_complex(w_current, object->complex->prim_objs);
        o_complex_draw(w_current, object);

        o_cue_undraw_list(w_current, other_objects);
        o_cue_draw_list(w_current, other_objects);

        /* now draw the newly connected objects */
        connected_objects = s_conn_return_complex_others(connected_objects,
                                                         object);
        o_cue_undraw_list(w_current, connected_objects);
        o_cue_draw_list(w_current, connected_objects);
        break;

      case(OBJ_LINE):
        o_line_erase_grips(w_current, object);
        o_line_erase(w_current, object);
        o_line_mirror(w_current,
                      centerx, centery, object);
        o_line_draw(w_current, object);
        break;

      case(OBJ_BOX):
        o_box_erase_grips(w_current, object);
        o_box_erase(w_current, object);
        o_box_mirror(w_current,
                     centerx, centery, object);
        o_box_draw(w_current, object);
        break;

      case(OBJ_CIRCLE):
        o_circle_erase_grips(w_current, object);
        o_circle_erase(w_current, object);
        o_circle_mirror(w_current,
                        centerx, centery, object);
        o_circle_draw(w_current, object);
        break;

      case(OBJ_ARC):
        o_arc_erase(w_current, object);
#if 0 /* not needed anymore */
	SCREENtoWORLD(w_current, centerx, centery, 
		      &world_centerx, &world_centery);
#endif
        o_arc_mirror(w_current, centerx, centery, object);
        o_arc_draw(w_current, object);
        break;

      case(OBJ_TEXT):
        o_text_erase(w_current, object);
        o_text_mirror(w_current,
                      centerx, centery, object);
        o_text_draw(w_current, object);
        break;

    }

    s_current = s_current->next;

  }

  w_current->page_current->CHANGED=1;
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def o_mirror

@section Function @code{o_edit_show_hidden_lowlevel()}

@defun o_edit_show_hidden_lowlevel w_current o_list
@end defun

<<o_misc.c : o_edit_show_hidden_lowlevel()>>=
void
o_edit_show_hidden_lowlevel(TOPLEVEL *w_current, OBJECT *o_list)
{
  OBJECT *o_current = o_list;

  if (o_current == NULL) {
    return;
  }

  while(o_current != NULL) {
    if (o_current->type == OBJ_TEXT && o_current->visibility == INVISIBLE) {

      // don't toggle the visibility flag

      if (w_current->show_hidden_text) {
        // draw the text object if it hidden 
        if (o_current->text->prim_objs == NULL) {
          o_text_recreate(w_current, o_current);
        }
        o_text_recalc(w_current, o_current);
        o_text_draw(w_current, o_current);
      } else {
        /* object is hidden and we are now NOT drawing it, so */
        /* get rid of the extra primitive data */
        o_text_recreate(w_current, o_current);
        o_text_recalc(w_current, o_current);
        /* unfortunately, you cannot erase the old visible text here */
        /* because o_text_draw will just return */
      }    
    }

    if (o_current->type == OBJ_COMPLEX) {
      o_edit_show_hidden_lowlevel(w_current, o_current->complex->prim_objs);
      o_complex_recalc(w_current, o_current);
    }
   
    o_current = o_current->next;
  }
}
@ %def o_edit_show_hidden_lowlevel



@section Function @code{o_edit_show_hidden()}

@defun o_edit_show_hidden w_current o_list
@end defun

<<o_misc.c : o_edit_show_hidden()>>=
void
o_edit_show_hidden(TOPLEVEL *w_current, OBJECT *o_list)
{
  /* this function just shows the hidden text, but doesn't toggle it */
  /* this function does not change the CHANGED bit, no real changes are */
  /* made to the schematic */
  
  /* toggle show_hidden_text variable, which when it is true */
  /* means that hidden text IS drawn */
  w_current->show_hidden_text = !w_current->show_hidden_text;

  o_edit_show_hidden_lowlevel(w_current, o_list);
  o_redraw_all_fast(w_current);

  if (w_current->show_hidden_text) {
    s_log_message("Hidden text is now visible\n");
  } else {
    s_log_message("Hidden text is now invisible\n");
  }
}


@ %def o_edit_show_hidden


@section Function @code{o_edit_make_visible()}

@defun o_edit_make_visible w_current o_list
@end defun

<<o_misc.c : o_edit_make_visible()>>=
void
o_edit_make_visible(TOPLEVEL *w_current, OBJECT *o_list)
{
  /* this function actually changes the visibility flag */
  OBJECT *o_current = NULL;

  if (o_list == NULL)
  return;
  o_current = o_list;

  while(o_current != NULL) {

    if (o_current->type == OBJ_TEXT) {
      if (o_current->visibility == INVISIBLE) {
        o_current->visibility = VISIBLE;

        if (o_current->text->prim_objs == NULL) {
          o_text_recreate(w_current, o_current);
        }

        o_text_draw(w_current, o_current);

        w_current->page_current->CHANGED = 1; 
      }
    }
    o_current = o_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);

}
@ %def o_edit_make_visible


@section Function @code{o_edit_find_text()}

@defun o_edit_find_text w_current o_list stext descend skip
@end defun

<<o_misc.c : o_edit_find_text()>>=
#define FIND_WINDOW_HALF_SIZE (5000)

OBJECT *last_o = NULL;
int skiplast;

int o_edit_find_text(TOPLEVEL * w_current, OBJECT * o_list, char *stext,
		     int descend, int skip)
{

  char *attrib = NULL;
  int count = 0;
  PAGE *parent = NULL;
  char *current_filename = NULL;
  int page_control = 0;
  int pcount = 0;
  int rv;

  OBJECT *o_current = NULL;

  skiplast = skip;
  o_current = o_list;

  if (o_current == NULL) {
    return 1;
  }

  while (o_current != NULL) {

    if (descend) {
      if (o_current->type == OBJ_COMPLEX) {
	parent = w_current->page_current;
	attrib = o_attrib_search_name_single_count(o_current,
						   "source", count);

	/* if above is null, then look inside symbol */
	if (attrib == NULL) {
	  attrib = o_attrib_search_name(o_current->
					complex->
					prim_objs, "source", count);
	  /*          looking_inside = TRUE; */
	}

	if (attrib) {
	  pcount = 0;
	  current_filename = u_basic_breakup_string(attrib, pcount);
	  if (current_filename != NULL) {
	    page_control =
		s_hierarchy_down_schematic_single(w_current,
						  current_filename,
						  parent,
						  page_control,
						  HIERARCHY_NORMAL_LOAD);
	    /* o_redraw_all(w_current); */

	    rv = o_edit_find_text(w_current,
				  w_current->page_current->object_head,
				  stext, descend, skiplast);
	    if (!rv) {
	      return 0;
	    }
	    s_hierarchy_up(w_current, w_current->page_current->up);
	  }
	}
      }
    }

    if (o_current->type == OBJ_TEXT) {
      if (!strcmp(stext, o_current->text->string)) {
	/*            printf("Found %s\n", stext);
	   if (!o_current->selected&&(!descend)) {
	   o_selection_add(w_current->page_current->selection2_head,
	   o_current);
	   } */
	if (!skiplast) {

#if 0 /* replaced by below call by avh, might not quite be right though */
	  set_window(w_current, o_current->text->x - FIND_WINDOW_HALF_SIZE,
		     o_current->text->x + FIND_WINDOW_HALF_SIZE,
		     o_current->text->y - FIND_WINDOW_HALF_SIZE,
		     o_current->text->y + FIND_WINDOW_HALF_SIZE);
#endif
	  a_zoom_extents(w_current, w_current->page_current->object_head,
                         A_PAN_DONT_REDRAW);
	  a_pan_general(w_current, o_current->text->x, o_current->text->y, 
	  	        1, A_PAN_DONT_REDRAW);
	  x_scrollbars_update(w_current);
	  o_redraw_all_fast(w_current);

	  last_o = o_current;
	  break;
	}
	if (last_o == o_current) {
	  skiplast = 0;
	}

      }
    }
    o_current = o_current->next;

    if (o_current == NULL) {
      return 1;
    }
  }
  return (o_current == NULL);
}

@ %def o_edit_find_text


@section Function @code{find_max()}

@defun find_max w_current o_list stext 
@end defun

<<o_misc.c : find_max()>>=
int current_max;
int used_count;
int used_list[4096];
void find_max(TOPLEVEL * w_current, OBJECT * o_list, char *stext)
{

  OBJECT *o_current = NULL;
  char *attrib = NULL;
  int count = 0;
  PAGE *parent = NULL;
  char *current_filename = NULL;
  int page_control = 0;
  int pcount = 0;

  int l, m;


  if (o_list == NULL)
    return;

  o_current = o_list;

  while (o_current != NULL) {


    if (o_current->type == OBJ_COMPLEX) {

      parent = w_current->page_current;
      attrib = o_attrib_search_name_single_count(o_current,
						 "source", count);

      /* if above is null, then look inside symbol */
      if (attrib == NULL) {
	attrib = o_attrib_search_name(o_current->
				      complex->prim_objs, "source", count);
	/*            looking_inside = TRUE; */
      }

      if (attrib) {
	pcount = 0;
	current_filename = u_basic_breakup_string(attrib, pcount);
	if (current_filename != NULL) {
	  page_control =
	      s_hierarchy_down_schematic_single(w_current,
						current_filename,
						parent,
						page_control,
						HIERARCHY_NORMAL_LOAD);

	  find_max(w_current, w_current->page_current->object_head, stext);
	  s_hierarchy_up(w_current, w_current->page_current->up);
	}
      }
    }
    if (o_current->type == OBJ_TEXT) {
      if ((l = strlen(o_current->text->string) - strlen(stext)) > 0) {
	if (!strncmp(stext, o_current->text->string, strlen(stext))) {
	  if (isdigit(o_current->text->string[strlen(stext)])) {
	    sscanf(o_current->text->string + strlen(stext), "%d", &m);
            if (used_count < 4094) {
              used_list[used_count++] = m;
            }
	    if (m > current_max) {
	      current_max = m;
	    }
	    /*            printf("%d %d\n", m, max); */
	  }
	}
      }
    }
    o_current = o_current->next;
  }
}

@ %def find_max


@section Function @code{autonumber_text()}

@defun autonumber_text w_current o_list stext 
@end defun

<<o_misc.c : autonumber_text()>>=
void
autonumber_text(TOPLEVEL * w_current, OBJECT * o_list, char *stext)
{
  OBJECT *o_current = NULL;
  char *attrib = NULL;
  int count = 0;
  PAGE *parent = NULL;
  char *current_filename = NULL;
  int page_control = 0;
  int pcount = 0;

  unsigned char ss[256];
  int l;

  o_current = o_list;
  while (o_current != NULL) {


    if (o_current->type == OBJ_COMPLEX) {

      parent = w_current->page_current;
      attrib = o_attrib_search_name_single_count(o_current,
						 "source", count);

      /* if above is null, then look inside symbol */
      if (attrib == NULL) {
	attrib = o_attrib_search_name(o_current->
				      complex->prim_objs, "source", count);
	/*            looking_inside = TRUE; */
      }

      if (attrib) {
	pcount = 0;
	current_filename = u_basic_breakup_string(attrib, pcount);
	if (current_filename != NULL) {
	  page_control =
	      s_hierarchy_down_schematic_single(w_current,
						current_filename,
						parent,
						page_control,
						HIERARCHY_NORMAL_LOAD);
	  /*o_redraw_all(w_current); */
	  autonumber_text(w_current, w_current->page_current->object_head,
			  stext);

	  s_hierarchy_up(w_current, w_current->page_current->up);

	}
      }
    }

    if (o_current->type == OBJ_TEXT) {
      if ((l = strlen(o_current->text->string) - strlen(stext)) > 0) {
	if (!strncmp(stext, o_current->text->string, strlen(stext))) {
	  /* printf("%s %d\n", o_current->text->string, (unsigned char) o_current->text->string[strlen(stext)]); */
	  if (o_current->text->string[strlen(stext)] == '?') {
	    free(o_current->text->string);

            while (current_max > used_list[used_count]) {
              used_count++;
            }
            while (current_max==used_list[used_count]) {
              current_max++;
              used_count++;
            }

	    sprintf(ss, "%s%d", stext, current_max++);
	    /*            printf("%s\n", ss); */
	    o_current->text->string =
		(char *) malloc(sizeof(char) * (strlen(ss) + 1));
	    strcpy(o_current->text->string, ss);
	    o_text_erase(w_current, o_current);
	    o_text_recreate(w_current, o_current);
	    o_text_draw(w_current, o_current);
	    w_current->page_current->CHANGED = 1;
	  }


	}
      }
    }
    o_current = o_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
}

@ %def autonumber_text


@section Function @code{o_edit_autonumber_text()}

@defun o_edit_autonumber_text w_current o_list stext 
@end defun

<<o_misc.c : o_edit_autonumber_text()>>=
void
o_edit_autonumber_text(TOPLEVEL * w_current, OBJECT * o_list, char *stext)
{
  int i, tmp,sorted=0;
  current_max = 1;
  used_count = 0;
  find_max(w_current, o_list, stext);

  if ((used_count < 4094)&&(used_count > 0)) {
    while (!sorted) {
      sorted = 1;
      for (i=0;i<used_count-1;i++) {
        if (used_list[i]>used_list[i+1]) {
          sorted = 0;
          tmp = used_list[i];
          used_list[i] = used_list[i+1];
          used_list[i+1] = tmp;
        }
        if (used_list[i]==used_list[i+1]) {
          printf("Warning: two components with same uref: %d\n", used_list[i]);
        }
      }
    }
    current_max = 1;
  } else {
    used_list[0] = current_max;
    used_count = 1;
  }
  used_list[used_count] = 1000000;
  used_count = 0;

  /*    printf("max: %d\n", current_max); */
  autonumber_text(w_current, o_list, stext);
  o_redraw_all(w_current);

}

@ %def o_edit_autonumber_text


@section Function @code{o_edit_hide_specific_text()}

@defun o_edit_hide_specific_text w_current o_list stext 
@end defun

<<o_misc.c : o_edit_hide_specific_text()>>=
void
o_edit_hide_specific_text(TOPLEVEL * w_current, OBJECT * o_list,
			  char *stext)
{
  OBJECT *o_current = NULL;

  if (o_list == NULL)
    return;

  o_current = o_list;

  while (o_current != NULL) {

    if (o_current->type == OBJ_TEXT) {
      if (!strncmp(stext, o_current->text->string, strlen(stext))) {
	if (o_current->visibility == VISIBLE) {
	  o_current->visibility = INVISIBLE;

	  if (o_current->text->prim_objs == NULL) {
	    o_text_recreate(w_current, o_current);
	  }
	  w_current->page_current->CHANGED = 1;
	}
      }
    }
    o_current = o_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
  o_redraw_all(w_current);
}

@ %def o_edit_hide_specific_text



@section Function @code{o_edit_show_specific_text()}

@defun o_edit_show_specific_text w_current o_list stext 
@end defun

<<o_misc.c : o_edit_show_specific_text()>>=
void
o_edit_show_specific_text(TOPLEVEL * w_current, OBJECT * o_list,
			  char *stext)
{
  OBJECT *o_current = NULL;

  if (o_list == NULL)
    return;

  o_current = o_list;

  while (o_current != NULL) {

    if (o_current->type == OBJ_TEXT) {
      if (!strncmp(stext, o_current->text->string, strlen(stext))) {
	if (o_current->visibility == INVISIBLE) {
	  o_current->visibility = VISIBLE;

	  if (o_current->text->prim_objs == NULL) {
	    o_text_recreate(w_current, o_current);
	  }
	  o_text_draw(w_current, o_current);
	  w_current->page_current->CHANGED = 1;
	}
      }
    }
    o_current = o_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
}
@ %def o_edit_show_specific_text
