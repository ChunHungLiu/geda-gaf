@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File i_callbacks.c,,,Top
@chapter File @file{i_callbacks.c}

@section File header

<<i_callbacks.c : *>>=
<<i_callbacks.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/i_callbacks.nw instead */

<<i_callbacks.c : include directives>>
<<i_callbacks.c : macros>>
<<i_callbacks.c : fnameext_get()>>
<<i_callbacks.c : fnameext_remove()>>
<<i_callbacks.c : fnameext_add()>>
<<i_callbacks.c : initiate_gschemdoc()>>
<<i_callbacks.c : DEFINE_I_CALLBACK()>>

/* right now, all callbacks execpt for the ones on the File menu have
 * the middle button shortcut. Let me (Ales) know if we should also
 * shortcut the File button */

/* File menu */
<<i_callbacks.c : i_callback_file_new()>>
<<i_callbacks.c : i_callback_toolbar_file_new()>>
<<i_callbacks.c : i_callback_file_new_window()>>
<<i_callbacks.c : i_callback_file_open()>>
<<i_callbacks.c : i_callback_toolbar_file_open()>>
<<i_callbacks.c : i_callback_file_script()>>
<<i_callbacks.c : i_callback_file_save()>>
<<i_callbacks.c : i_callback_toolbar_file_save()>>
<<i_callbacks.c : i_callback_file_save_all()>>
<<i_callbacks.c : i_callback_file_save_as()>>
<<i_callbacks.c : i_callback_file_print()>>
<<i_callbacks.c : i_callback_file_write_png()>>
<<i_callbacks.c : i_callback_file_close()>>
<<i_callbacks.c : i_callback_close()>>
<<i_callbacks.c : i_callback_file_quit()>>

/* Edit menu */
<<i_callbacks.c : i_callback_edit_undo()>>
<<i_callbacks.c : i_callback_toolbar_edit_undo()>>
<<i_callbacks.c : i_callback_edit_redo()>>
<<i_callbacks.c : i_callback_toolbar_edit_redo()>>
<<i_callbacks.c : i_callback_edit_select()>>
<<i_callbacks.c : i_callback_toolbar_edit_select()>>
<<i_callbacks.c : i_callback_edit_copy()>>
<<i_callbacks.c : i_callback_edit_copy_hotkey()>>
<<i_callbacks.c : i_callback_edit_move()>>
<<i_callbacks.c : i_callback_edit_move_hotkey()>>
<<i_callbacks.c : i_callback_edit_delete()>>
<<i_callbacks.c : i_callback_edit_edit()>>
<<i_callbacks.c : i_callback_edit_text()>>
<<i_callbacks.c : i_callback_edit_slot()>>
<<i_callbacks.c : i_callback_edit_color()>>
<<i_callbacks.c : i_callback_edit_rotate_90()>>
<<i_callbacks.c : i_callback_edit_rotate_90_hotkey()>>
<<i_callbacks.c : i_callback_edit_mirror()>>
<<i_callbacks.c : i_callback_edit_mirror_hotkey()>>
<<i_callbacks.c : i_callback_edit_lock()>>
<<i_callbacks.c : i_callback_edit_unlock()>>
<<i_callbacks.c : i_callback_edit_translate()>>
<<i_callbacks.c : i_callback_edit_embed()>>
<<i_callbacks.c : i_callback_edit_unembed()>>
<<i_callbacks.c : i_callback_edit_update()>>
<<i_callbacks.c : i_callback_edit_show_hidden()>>
<<i_callbacks.c : i_callback_edit_make_visible()>>
<<i_callbacks.c : i_callback_edit_find()>>
<<i_callbacks.c : i_callback_edit_hide_text()>>
<<i_callbacks.c : i_callback_edit_show_text()>>
<<i_callbacks.c : i_callback_edit_autonumber_text()>>
<<i_callbacks.c : i_callback_edit_linetype()>>
<<i_callbacks.c : i_callback_edit_filltype()>>

/* View menu */
<<i_callbacks.c : i_callback_view_redraw()>>
<<i_callbacks.c : i_callback_view_zoom_full()>>
<<i_callbacks.c : i_callback_view_zoom_extents()>>
<<i_callbacks.c : i_callback_view_zoom_box()>>
<<i_callbacks.c : i_callback_view_zoom_box_hotkey()>>
<<i_callbacks.c : i_callback_view_zoom_in()>>
<<i_callbacks.c : i_callback_view_zoom_out()>>
<<i_callbacks.c : i_callback_view_zoom_in_hotkey()>>
<<i_callbacks.c : i_callback_view_zoom_out_hotkey()>>
<<i_callbacks.c : i_callback_view_pan()>>
<<i_callbacks.c : i_callback_view_pan_hotkey()>>
<<i_callbacks.c : i_callback_view_update_cues()>>

/* Page menu */
<<i_callbacks.c : i_callback_page_manager()>>
<<i_callbacks.c : i_callback_page_next()>>
<<i_callbacks.c : i_callback_page_prev()>>
<<i_callbacks.c : i_callback_page_new()>>
<<i_callbacks.c : i_callback_page_close()>>
<<i_callbacks.c : i_callback_page_revert()>>
<<i_callbacks.c : i_callback_page_discard()>>
<<i_callbacks.c : i_callback_page_print()>>

/* Buffer menu */
<<i_callbacks.c : i_callback_buffer_copy1()>>
<<i_callbacks.c : i_callback_buffer_copy2()>>
<<i_callbacks.c : i_callback_buffer_copy3()>>
<<i_callbacks.c : i_callback_buffer_copy4()>>
<<i_callbacks.c : i_callback_buffer_copy5()>>
<<i_callbacks.c : i_callback_buffer_cut1()>>
<<i_callbacks.c : i_callback_buffer_cut2()>>
<<i_callbacks.c : i_callback_buffer_cut3()>>
<<i_callbacks.c : o_callback_buffer_cut4()>>
<<i_callbacks.c : i_callback_buffer_cut5()>>
<<i_callbacks.c : i_callback_buffer_paste1()>>
<<i_callbacks.c : i_callback_buffer_paste2()>>
<<i_callbacks.c : i_callback_buffer_paste3()>>
<<i_callbacks.c : i_callback_buffer_paste4()>>
<<i_callbacks.c : i_callback_buffer_paste5()>>
<<i_callbacks.c : i_callback_buffer_paste1_hotkey()>>
<<i_callbacks.c : i_callback_buffer_paste2_hotkey()>>
<<i_callbacks.c : i_callback_buffer_paste3_hotkey()>>
<<i_callbacks.c : i_callback_buffer_paste4_hotkey()>>
<<i_callbacks.c : i_callback_buffer_paste5_hotkey()>>

/* Add menu */
<<i_callbacks.c : i_callback_add_component()>>
<<i_callbacks.c : i_callback_toolbar_add_component()>>
<<i_callbacks.c : i_callback_add_attribute()>>
<<i_callbacks.c : i_callback_add_attribute_hotkey()>>
<<i_callbacks.c : i_callback_add_net()>>
<<i_callbacks.c : i_callback_add_net_hotkey()>>
<<i_callbacks.c : i_callback_toolbar_add_net()>>
<<i_callbacks.c : i_callback_add_bus()>>
<<i_callbacks.c : i_callback_add_bus_hotkey()>>
<<i_callbacks.c : i_callback_toolbar_add_bus()>>
<<i_callbacks.c : i_callback_add_text()>>
<<i_callbacks.c : i_callback_toolbar_add_text()>>
<<i_callbacks.c : i_callback_add_line()>>
<<i_callbacks.c : i_callback_add_line_hotkey()>>
<<i_callbacks.c : i_callback_add_box()>>
<<i_callbacks.c : i_callback_add_box_hotkey()>>
<<i_callbacks.c : i_callback_add_circle()>>
<<i_callbacks.c : i_callback_add_circle_hotkey()>>
<<i_callbacks.c : i_callback_add_arc()>>
<<i_callbacks.c : i_callback_add_arc_hotkey()>>
<<i_callbacks.c : i_callback_add_pin()>>
<<i_callbacks.c : i_callback_add_pin_hotkey()>>

/* Hierarchy menu */
<<i_callbacks.c : i_callback_hierarchy_down_schematic()>>
<<i_callbacks.c : i_callback_hierarchy_down_symbol()>>
<<i_callbacks.c : i_callback_hierarchy_up()>>
<<i_callbacks.c : i_callback_hierarchy_documentation()>>

/* Attributes menu */
<<i_callbacks.c : i_callback_attributes_attach()>>
<<i_callbacks.c : i_callback_attributes_detach()>>
<<i_callbacks.c : i_callback_attributes_show_name()>>
<<i_callbacks.c : i_callback_attributes_show_value()>>
<<i_callbacks.c : i_callback_attributes_show_both()>>
<<i_callbacks.c : i_callback_attributes_visibility_toggle()>>

/* Script menu */
/* not currently implemented */
<<i_callbacks.c : i_callback_script_console()>>

/* Options menu */
<<i_callbacks.c : i_callback_options_text_size()>>
<<i_callbacks.c : i_callback_options_snap_size()>>
<<i_callbacks.c : i_callback_options_afeedback()>>
<<i_callbacks.c : i_callback_options_grid()>>
<<i_callbacks.c : i_callback_options_snap()>>
<<i_callbacks.c : i_callback_options_rubberband()>>
<<i_callbacks.c : i_callback_options_show_log_window()>>

<<i_callbacks.c : i_callback_misc()>>
<<i_callbacks.c : i_callback_misc2()>>
<<i_callbacks.c : i_callback_misc3()>>
<<i_callbacks.c : i_callback_cancel()>>

/* help menu */
<<i_callbacks.c : i_callback_help_about()>>
<<i_callbacks.c : i_callback_help_manual()>>
<<i_callbacks.c : i_callback_help_hotkeys()>>

<<i_callbacks.c : i_callback_options_show_coord_window()>>

#if 0 /* experimental */
<<i_callbacks.c : i_callback_preview()>>
#endif

<<i_callbacks.c : i_callback_close_wm()>>

@


<<i_callbacks.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<i_callbacks.c : include directives>>=
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/globals.h"
#include "../include/prototype.h"

@


<<i_callbacks.c : macros>>=
#define DELIMITERS ", "

@ %def DELIMITERS


@section Function @code{fnameext_get()}

@defun fnameext_get fname
@end defun

<<i_callbacks.c : fnameext_get()>>=
/* Kazu Hirata <kazu@seul.org> on July 25, 1999 - Returns a pointer to
 * the last '.' in the given string. If there is none, the function
 * returns a pointer to the first null character in the string. If you
 * want to change the extention using the return value of the
 * function, you need to do pointer arithmetic, assuming your fname is
 * defined as a constant. :-) Note that, if the only '.' appears as
 * the first character, it is ignored. */
static const char *
fnameext_get(const char* fname)
{
  const char *p = strrchr(fname, '.');

  if((p == NULL) || (p == fname)) {
    p = &fname[strlen(fname)];
  }
  return p;
}


@ %def fnameext_get


@section Function @code{fnameext_remove()}

@defun fnameext_remove fname
@end defun

<<i_callbacks.c : fnameext_remove()>>=
/* Kazu Hirata <kazu@seul.org> on July 25, 1999 - The function removes
 * an extention including a '.' if any and returns the new string in a
 * newly allocated memory. If there is no '.' after the first
 * character, then the function simply returns a copy of fname. If
 * memory allocation fails, the function returns NULL. */
static char *
fnameext_remove(const char *fname)
{
  const char *p = fnameext_get(fname);
  char *fname_new;
  int len;

  if(*p == '\0') {
    fname_new = u_basic_strdup(p);
  } else {
    len = (p - fname); /*  + 1; this extra was causing grief */
    fname_new = (char *) malloc(sizeof(char) * (len + 1));
    if(fname_new == NULL) {
      return NULL;
    }
    strncpy(fname_new, fname, len);
    fname_new[len] = '\0';
  }
  return fname_new;
}


@ %def fnameext_remove


@section Function @code{fnameext_add()}

@defun fnameext_add fname ext
@end defun

<<i_callbacks.c : fnameext_add()>>=
/* Kazu Hirata <kazu@seul.org> on July 25, 1999 - The function adds an
 * extention and returns the new string in a newly allocated
 * memory. ext must have '.'  as the first character. If memory
 * allocation fails, the function returns NULL. */
static char *
fnameext_add(const char *fname, const char* ext)
{
  return u_basic_strdup_multiple(fname, ext, NULL);
}


@ %def fnameext_add


@section Function @code{initiate_gschemdoc()}

@defun initiate_gschemdoc fname
@end defun

<<i_callbacks.c : initiate_gschemdoc()>>=
/* Egil Kvaleberg <egil@kvaleberg.no> on October 7, 2002 - 
 * Initiate the gschemdoc utility to provide the used with as much
 * documentation on the symbol (i.e. component) as we can manage.
 */
static void
initiate_gschemdoc(const char* documentation,const char *device,
		   const char *value,
		   const char* symfile, const char *sympath)
{

#ifndef __MINGW32__

  int pid;

  if (!documentation) documentation="";
  if (!device) device="";
  if (!value) value="";
  if (!symfile) symfile="";
  if (!sympath) sympath="";

  s_log_message( _("Documentation for [%s,%s,%s,%s]\n"),
		    documentation,device,value,symfile);


  if ((pid = fork()) < 0) {
    fprintf(stderr, _("Could not fork\n"));
  } else if (pid == 0) {
    /* daughter process */

    /* assume gschemdoc is part of path */
    char *gschemdoc = "gschemdoc";

    execlp(gschemdoc, gschemdoc, documentation, device, value, symfile, sympath, NULL);

    /* if we return, then nothing happened */
    fprintf(stderr, _("Could not invoke %s\n"), gschemdoc);
    _exit(0);
  }
#else
  s_log_message(_("Documentation commands not supported under MINGW."));
#endif
}

@ %def initiate_gschemdoc


@section Macro @code{DEFINE_I_CALLBACK()}

@defun DEFINE_I_CALLBACK name
@end defun

<<i_callbacks.c : DEFINE_I_CALLBACK()>>=
/* evey i_callback functions have the same footprint */
#define DEFINE_I_CALLBACK(name)				\
	void						\
	i_callback_ ## name(gpointer data,		\
			    guint callback_action,	\
			    GtkWidget *widget)


@ %def DEFINE_I_CALLBACK


@section Function @code{i_callback_file_new()}

@defun i_callback_file_new data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_new()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
/* This should be renamed to page_new perhaps... */
DEFINE_I_CALLBACK(file_new)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *temp_filename;

  exit_if_null(w_current);

  /* TODO: probably 256 is enough, but shuold be something like
   * getcwd(NULL, 0); */
  if (getcwd(w_current->cwd, 256)) {
#ifdef __MINGW32__
    u_basic_strip_trailing(w_current->cwd, PATH_SEPARATER_CHAR);
#endif
    /* TODO: the #'s are for 10 digits hack */
    /* TODO: perform a NULL check */
    temp_filename = (char *) malloc(
                                    sizeof(char) * (strlen(w_current->cwd)+
                                                    strlen(w_current->series_name) +
                                                    strlen("/_##########.sch") +
                                                    1));

    w_current->num_untitled++;
    sprintf(temp_filename, "%s%c%s_%d.sch", w_current->cwd, PATH_SEPARATER_CHAR,
            w_current->series_name,
            w_current->num_untitled);
  } else {
    /* TODO: perform a NULL check */
    temp_filename = malloc(sizeof(char) * (
                                           strlen(w_current->series_name)+
                                           strlen("_##########.sch") +
                                           1));

    w_current->num_untitled++;
    sprintf(temp_filename, "%s_%d.sch",
            w_current->series_name,
            w_current->num_untitled);
  }

  /* in this function the filename is allocated and copied */
  s_page_new(w_current, temp_filename);
  s_log_message("New page created [%s]\n", temp_filename);
  free(temp_filename);

  i_set_filename(w_current, w_current->page_current->page_filename);

  update_page_manager(NULL, w_current);
  i_update_menus(w_current);
  x_window_setup_world(w_current);
  x_manual_resize(w_current);
  x_hscrollbar_update(w_current);
  x_vscrollbar_update(w_current);
  x_repaint_background(w_current);
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def i_callback_file_new


@section Function @code{i_callback_toolbar_file_new()}

@defun i_callback_toolbar_file_new widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_file_new()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_file_new(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;
    
  i_callback_file_new((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_file_new


@section Function @code{i_callback_file_new_window()}

@defun i_callback_file_new_window data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_new_window()>>=
DEFINE_I_CALLBACK(file_new_window)
{
  TOPLEVEL *w_current;
       
  w_current = x_window_create_new();

  exit_if_null(w_current);

  if (getcwd(w_current->cwd, 256)) {
#ifdef __MINGW32__
    u_basic_strip_trailing(w_current->cwd, PATH_SEPARATER_CHAR);
#endif
    if (w_current->page_current->page_filename) {
      free(w_current->page_current->page_filename);
    }

    /* TODO: perform a NULL check */
    w_current->page_current->page_filename = 
	malloc(sizeof(char) * (strlen(w_current->cwd)+ 
			       strlen(w_current->series_name)+
                               strlen("/_##########.sch")+1));

    w_current->num_untitled++;
    sprintf(w_current->page_current->page_filename, "%s%c%s_%d.sch",
            w_current->cwd, PATH_SEPARATER_CHAR,
            w_current->series_name,
            w_current->num_untitled);
  } else {
    /* TODO: shouldn't this part do the same thing as
     * what's equivalent in i_callback_file_new()? This is
     * not nice to user. */
    fprintf(stderr, _("Cannot obtain the current directory!\n"));
  }

  s_log_message(_("New Window created\n"));
  i_set_filename(w_current, w_current->page_current->page_filename);
  x_repaint_background(w_current);
}


@ %def i_callback_file_new_window


@section Function @code{i_callback_file_open()}

@defun i_callback_file_open data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_open()>>=
/* don't use the widget parameter on this function, or do some
 * checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
/* This should be renamed to page_open perhaps... */
DEFINE_I_CALLBACK(file_open)
{

  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  x_fileselect_setup(w_current, FILESELECT, OPEN);

#if 0 /* replaced by above */
  setup_open_file_selector(w_current);
#endif
}


@ %def i_callback_file_open


@section Function @code{i_callback_toolbar_file_open()}

@defun i_callback_toolbar_file_open widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_file_open()>>=
/* don't use the widget parameter on this function, or do some
 * checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
/* This should be renamed to page_open perhaps... */
void i_callback_toolbar_file_open(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_file_open((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_file_open


@section Function @code{i_callback_file_script()}

@defun i_callback_file_script data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_script()>>=
DEFINE_I_CALLBACK(file_script)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  setup_script_selector(w_current);
}


@ %def i_callback_file_script


@section Function @code{i_callback_file_save()}

@defun i_callback_file_save data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_save()>>=
/* don't use the widget parameter on this function, or do some
 * checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
DEFINE_I_CALLBACK(file_save)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* TODO: probably there should be a flag that says whether
   * page_filename is derived from untitled_name or specified by
   * a user. Some twisted people might name their files like
   * untitled_name. :-) */
  if (strstr(w_current->page_current->page_filename,
             w_current->untitled_name)) {
    x_fileselect_setup(w_current, FILESELECT, SAVEAS_NONE);
#if 0 /* replaced with x_fileselect_setup */
    setup_saveas_file_selector(
                               w_current,
                               SAVEAS,
                               w_current->page_current->page_filename);
#endif
  } else {

    if (f_save(w_current, w_current->page_current->page_filename) ) {
	    s_log_message(_("Saved [%s]\n"),w_current->page_current->page_filename);
	    /* don't know if should be kept going to select mode... */
	    w_current->page_current->CHANGED = 0;
	    i_set_state_msg(w_current, SELECT, _("Saved"));
	    i_update_toolbar(w_current);
            i_update_menus(w_current);
	    update_page_manager(NULL, w_current);
    } else {
      	    s_log_message(_("Could NOT save [%s]\n"), w_current->page_current->page_filename);

	    i_set_state_msg(w_current, SELECT, _("Error while trying to save"));
	    i_update_toolbar(w_current);
            i_update_menus(w_current);
    } 
  }
}


@ %def i_callback_file_save


@section Function @code{i_callback_toolbar_file_save()}

@defun i_callback_toolbar_file_save widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_file_save()>>=
/* don't use the widget parameter on this function, or do some
 * checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
/* This should be renamed to page_open perhaps... */
void i_callback_toolbar_file_save(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_file_save((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_file_open


@section Function @code{i_callback_file_save_all()}

@defun i_callback_file_save_all data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_save_all()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
DEFINE_I_CALLBACK(file_save_all)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (s_page_save_all(w_current)) {
     i_set_state_msg(w_current, SELECT, _("Failed to Save All"));
  } else {
     i_set_state_msg(w_current, SELECT, _("Saved All"));
  }

  i_update_toolbar(w_current);
  update_page_manager(NULL, w_current);
  i_update_menus(w_current);
}


@ %def i_callback_file_save_all


@section Function @code{i_callback_file_save_as()}

@defun i_callback_file_save_as data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_save_as()>>=
DEFINE_I_CALLBACK(file_save_as)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  x_fileselect_setup(w_current, FILESELECT, SAVEAS_NONE);

#if 0 /* replaced with above */
  setup_saveas_file_selector(w_current,
                             SAVEAS,
                             w_current->page_current->page_filename);
#endif
}


@ %def i_callback_file_save_as


@section Function @code{i_callback_file_print()}

@defun i_callback_file_print data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_print()>>=
DEFINE_I_CALLBACK(file_print)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *base=NULL;
  char *ps_filename=NULL;

  exit_if_null(w_current);

  /* get the base file name */
  if (strcmp(fnameext_get(w_current->page_current->page_filename),
             ".sch") == 0) {
    /* the filename ends with .sch */
    base = fnameext_remove(w_current->page_current->page_filename);
  } else {
    /* the filename does not end with .sch */
    base = u_basic_strdup(w_current->page_current->page_filename);
  }
  if(base == NULL) {
    /* TODO: do something */
  }

  /* add ".ps" tp the base filename */
  ps_filename = fnameext_add(base, ".ps");
  free(base);

  if (output_filename) {
    x_print_setup(w_current, output_filename);
  } else {
    x_print_setup(w_current, ps_filename);
  }

  if (ps_filename) {
    free(ps_filename);
  }
}


@ %def i_callback_file_print


@section Function @code{i_callback_file_write_png()}

@defun i_callback_file_write_png data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_write_png()>>=
DEFINE_I_CALLBACK(file_write_png)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *base=NULL;
  char *img_filename=NULL;

  exit_if_null(w_current);

#ifndef HAS_LIBGDGEDA
  /* TODO: integrate these to messages */
  fprintf(stderr,
          _("libgdgeda not installed or disabled, "
          "so this feature is disabled\n"));
  s_log_message(
		_("libgdgeda not installed or disabled, "
		"so this feature is disabled\n"));
  return;
#endif

  /* get the base file name */
  if (strcmp(fnameext_get(w_current->page_current->page_filename),
             ".sch") == 0) {
    /* the filename ends with .sch */
    base = fnameext_remove(w_current->page_current->page_filename);
  } else {
    /* the filename does not end with .sch */
    base = u_basic_strdup(w_current->page_current->page_filename);
  }
  if(base == NULL) {
    /* TODO: do something */
  }

  /* add ".ps" tp the base filename */
  img_filename = fnameext_add(base, ".png");
  free(base);

  if (output_filename) {
    x_image_setup(w_current, output_filename);
  } else {
    x_image_setup(w_current, img_filename);
  }

  if (img_filename) {
    free(img_filename);
  }
}


@ %def i_callback_file_write_png


@section Function @code{i_callback_file_close()}

@defun i_callback_file_close data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_close()>>=
/* don't use the widget parameter on this function, or do some
   checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current) */
/* this function closes a window */
DEFINE_I_CALLBACK(file_close)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  s_log_message(_("Closing Window\n"));
  x_window_close(w_current);
}


@ %def i_callback_file_close


@section Function @code{i_callback_close()}

@defun i_callback_close data callback_action widget
@end defun

<<i_callbacks.c : i_callback_close()>>=
/* this function is called when you send a delete event to gschem */
/* Also DON'T ref the widget parameter since they can be null */
/* TODO: Need a cleaner way of doing this. This routine is used by the
 * delete event signals */
int
i_callback_close(gpointer data, guint callback_action, GtkWidget *widget)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  i_callback_file_close(w_current, 0, widget);
  return(FALSE);
}


@ %def i_callback_close


@section Function @code{i_callback_file_quit()}

@defun i_callback_file_quit data callback_action widget
@end defun

<<i_callbacks.c : i_callback_file_quit()>>=
DEFINE_I_CALLBACK(file_quit)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  x_window_close_all();
}


@ %def i_callback_file_quit


@section Function @code{i_callback_edit_undo()}

@defun i_callback_edit_undo data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_undo()>>=
DEFINE_I_CALLBACK(edit_undo)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  o_undo_callback(w_current, UNDO_ACTION);
}


@ %def i_callback_edit_undo


@section Function @code{i_callback_toolbar_edit_undo()}

@defun i_callback_toolbar_edit_undo widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_edit_undo()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_edit_undo(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_edit_undo((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_edit_undo


@section Function @code{i_callback_edit_redo()}

@defun i_callback_edit_redo data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_redo()>>=
DEFINE_I_CALLBACK(edit_redo)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  o_undo_callback(w_current, REDO_ACTION);
}


@ %def i_callback_edit_redo


@section Function @code{i_callback_toolbar_edit_redo()}

@defun i_callback_toolbar_edit_redo widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_edit_redo()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_edit_redo(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_edit_redo((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_edit_redo


@section Function @code{i_callback_edit_select()}

@defun i_callback_edit_select data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_select()>>=
/* Select also does not update the middle button shortcut */
DEFINE_I_CALLBACK(edit_select)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  /* this is probably the only place this should be */
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);
  w_current->inside_action = 0;
}


@ %def i_callback_edit_select


@section Function @code{i_callback_toolbar_edit_select()}

@defun i_callback_toolbar_edit_select widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_edit_select()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_edit_select(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  if (GTK_TOGGLE_BUTTON (widget)->active) {
    if (!o_erase_rubber(w_current)) {
      i_callback_cancel(w_current, 0, NULL);
    }
    i_callback_edit_select((TOPLEVEL*) data, 0, NULL);
  }
}


@ %def i_callback_toolbar_edit_select


@section Function @code{i_callback_edit_copy()}

@defun i_callback_edit_copy data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_copy()>>=
DEFINE_I_CALLBACK(edit_copy)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_copy, _("Copy"));
  if (o_select_return_first_object(w_current)) {
    i_set_state(w_current, STARTCOPY);
  } else {
    i_set_state_msg(w_current, SELECT, _("Select objs first"));
  }
}


@ %def i_callback_edit_copy


@section Function @code{i_callback_edit_copy_hotkey()}

@defun i_callback_edit_copy_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_copy_hotkey()>>=
DEFINE_I_CALLBACK(edit_copy_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_copy_hotkey, _("Copy"));
  if (o_select_return_first_object(w_current)) {
    o_copy_start(w_current, mouse_x, mouse_y);
    w_current->event_state = ENDCOPY;
    w_current->inside_action = 1;
  }
}


@ %def i_callback_edit_copy_hotkey


@section Function @code{i_callback_edit_move()}

@defun i_callback_edit_move data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_move()>>=
DEFINE_I_CALLBACK(edit_move)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_move, _("Move"));
  if (o_select_return_first_object(w_current)) {
    i_set_state(w_current, STARTMOVE);
  } else {
    i_set_state_msg(w_current, SELECT, _("Select objs first"));
  }
}


@ %def i_callback_edit_move


@section Function @code{i_callback_edit_move_hotkey()}

@defun i_callback_edit_move_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_move_hotkey()>>=
DEFINE_I_CALLBACK(edit_move_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_move_hotkey, _("Move"));
  if (o_select_return_first_object(w_current)) {
    o_move_start(w_current, mouse_x, mouse_y);
    w_current->event_state = ENDMOVE;
    w_current->inside_action = 1;
  }
}


@ %def i_callback_edit_move_hotkey


@section Function @code{i_callback_edit_delete()}

@defun i_callback_edit_delete data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_delete()>>=
DEFINE_I_CALLBACK(edit_delete)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_delete, _("Delete"));

  if (o_select_return_first_object(w_current)) {
    o_delete(w_current);

    /* if you delete the objects you must go into select
     * mode after the delete */
    w_current->inside_action = 0;
    i_set_state(w_current, SELECT);
    i_update_toolbar(w_current);
  }
}


@ %def i_callback_edit_delete


@section Function @code{i_callback_edit_edit()}

@defun i_callback_edit_edit data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_edit()>>=
DEFINE_I_CALLBACK(edit_edit)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_edit, _("Edit"));
  o_edit(w_current, w_current->page_current->selection2_head->next);
}


@ %def i_callback_edit_edit


@section Function @code{i_callback_edit_text()}

@defun i_callback_edit_text data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_text()>>=
DEFINE_I_CALLBACK(edit_text)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_text, _("Edit Text"));
  object = o_select_return_first_object(w_current);
  if (object) {
    if (object->type == OBJ_TEXT) {
      o_text_edit(w_current, object);
    }
  }
}


@ %def i_callback_edit_text


@section Function @code{i_callback_edit_slot()}

@defun i_callback_edit_slot data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_slot()>>=
DEFINE_I_CALLBACK(edit_slot)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  i_update_middle_button(w_current, i_callback_edit_slot, _("Slot"));
  if (object) {
    o_slot_start(w_current, object);
  }
}


@ %def i_callback_edit_slot


@section Function @code{i_callback_edit_color()}

@defun i_callback_edit_color data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_color()>>=
DEFINE_I_CALLBACK(edit_color)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_color, _("Color"));

  color_edit_dialog(w_current);
}


@ %def i_callback_edit_color


@section Function @code{i_callback_edit_rotate_90()}

@defun i_callback_edit_rotate_90 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_rotate_90()>>=
/* rotate all objects in the selection list by 90 degrees */
DEFINE_I_CALLBACK(edit_rotate_90)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_set_state(w_current, ENDROTATEP);
  i_update_middle_button(w_current, i_callback_edit_rotate_90, _("Rotate"));
}


@ %def i_callback_edit_rotate_90


@section Function @code{i_callback_edit_rotate_90_hotkey()}

@defun i_callback_edit_rotate_90_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_rotate_90_hotkey()>>=
/* rotate all objects in the selection list by 90 degrees */
DEFINE_I_CALLBACK(edit_rotate_90_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  SELECTION *s_current;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head) {
    s_current = w_current->page_current->selection2_head->next;
    i_update_middle_button(w_current,
                           i_callback_edit_rotate_90_hotkey, _("Rotate"));
    o_rotate_90(w_current, s_current, mouse_x, mouse_y);
  }

  w_current->event_state = SELECT;
  w_current->inside_action = 0;
  i_update_toolbar(w_current);
}


@ %def i_callback_edit_rotate_90_hotkey


@section Function @code{i_callback_edit_mirror()}

@defun i_callback_edit_mirror data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_mirror()>>=
DEFINE_I_CALLBACK(edit_mirror)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_set_state(w_current, ENDMIRROR);
  i_update_middle_button(w_current, i_callback_edit_mirror, _("Mirror"));
}


@ %def i_callback_edit_mirror


@section Function @code{i_callback_edit_mirror_hotkey()}

@defun i_callback_edit_mirror_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_mirror_hotkey()>>=
DEFINE_I_CALLBACK(edit_mirror_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  if (object) {
    i_update_middle_button(w_current,
                           i_callback_edit_mirror_hotkey, _("Mirror"));

    o_mirror(w_current, 
             w_current->page_current->selection2_head->next, 
             mouse_x, mouse_y);
  }

  w_current->event_state = SELECT;
  w_current->inside_action = 0;
  i_update_toolbar(w_current);
}


@ %def i_callback_edit_mirror_hotkey


@section Function @code{i_callback_edit_lock()}

@defun i_callback_edit_lock data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_lock()>>=
/* locks all objects in selection list */
DEFINE_I_CALLBACK(edit_lock)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_lock, _("Lock"));

  if (o_select_return_first_object(w_current)) {
    o_lock(w_current);
  }
}


@ %def i_callback_edit_lock


@section Function @code{i_callback_edit_unlock()}

@defun i_callback_edit_unlock data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_unlock()>>=
/* unlocks all objects in selection list */
DEFINE_I_CALLBACK(edit_unlock)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_unlock, _("Unlock"));
  if (o_select_return_first_object(w_current)) {
    o_unlock(w_current);
  }
}


@ %def i_callback_edit_unlock


@section Function @code{i_callback_edit_translate()}

@defun i_callback_edit_translate data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_translate()>>=
DEFINE_I_CALLBACK(edit_translate)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current,
                         i_callback_edit_translate, _("Translate"));

  if (w_current->snap == 0) {
    s_log_message(_("WARNING: Do not translate with snap off!\n"));
    s_log_message(_("WARNING: Turning snap on and continuing "
                  "with translate.\n"));
    w_current->snap = 1;
    i_show_state(w_current, NULL); /* update status on screen */
  }

  if (w_current->snap_size != 100) {
    s_log_message(_("WARNING: Snap grid size is "
                  "not equal to 100!\n"));
    s_log_message(_("WARNING: If you are translating a symbol "
                  "to the origin, the snap grid size should be "
                  "set to 100\n"));
  }

  translate_dialog(w_current);
}


@ %def i_callback_edit_translate


@section Function @code{i_callback_edit_embed()}

@defun i_callback_edit_embed data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_embed()>>=
/* embedds all objects in selection list */
DEFINE_I_CALLBACK(edit_embed)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_embed, _("Embed"));
  if (o_select_return_first_object(w_current)) {
    o_embed(w_current);
  }
}


@ %def i_callback_edit_embed


@section Function @code{i_callback_edit_unembed()}

@defun i_callback_edit_unembed data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_unembed()>>=
/* unembedds all objects in selection list */
DEFINE_I_CALLBACK(edit_unembed)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_unembed, _("Unembed"));
  if (o_select_return_first_object(w_current)) {
    o_unembed(w_current);
  }
}


@ %def i_callback_edit_unembed


@section Function @code{i_callback_edit_update()}

@defun i_callback_edit_update data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_update()>>=
/* Update components */
DEFINE_I_CALLBACK(edit_update)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_update, _("Update"));
  if (o_select_return_first_object(w_current)) {
  	o_update_component(w_current,
                     w_current->page_current->selection2_head->next);
  }
}


@ %def i_callback_edit_update


@section Function @code{i_callback_edit_show_hidden()}

@defun i_callback_edit_show_hidden data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_show_hidden()>>=
DEFINE_I_CALLBACK(edit_show_hidden)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
  return;

  i_update_middle_button(w_current,
                         i_callback_edit_show_hidden,
                         _("ShowHidden"));

  o_edit_show_hidden(w_current, w_current->page_current->object_head);
}


@ %def i_callback_edit_show_hidden


@section Function @code{i_callback_edit_make_visible()}

@defun i_callback_edit_make_visible data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_make_visible()>>=
DEFINE_I_CALLBACK(edit_make_visible)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
  return;

  i_update_middle_button(w_current,
                         i_callback_edit_make_visible,
                         _("MakeVisible"));

  o_edit_make_visible(w_current, w_current->page_current->object_head);
}


@ %def i_callback_edit_make_visible


@section Function @code{i_callback_edit_find()}

@defun i_callback_edit_find data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_find()>>=
DEFINE_I_CALLBACK(edit_find)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
    return;

  find_text_dialog(w_current);
}

@ %def i_callback_edit_find


@section Function @code{i_callback_edit_hide_text()}

@defun i_callback_edit_hide_text data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_hide_text()>>=
DEFINE_I_CALLBACK(edit_hide_text)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
    return;

  hide_text_dialog(w_current);
}

@ %def i_callback_edit_hide_text


@section Function @code{i_callback_edit_show_text()}

@defun i_callback_edit_show_text data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_show_text()>>=
DEFINE_I_CALLBACK(edit_show_text)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
    return;

  show_text_dialog(w_current);
}

@ %def i_callback_edit_show_text



@section Function @code{i_callback_edit_autonumber_text()}

@defun i_callback_edit_autonumber_text data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_autonumber_text()>>=
DEFINE_I_CALLBACK(edit_autonumber_text)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action)
    return;

  autonumber_text_dialog(w_current);
}

@ %def i_callback_edit_autonumber_text


@section Function @code{i_callback_edit_linetype()}

@defun i_callback_edit_linetype data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_linetype()>>=
DEFINE_I_CALLBACK(edit_linetype)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_edit_color, _("Edit Line Type"));

  if ( (object = o_select_return_first_object(w_current)) ) {
    line_type_dialog(w_current, object);
  }
}


@ %def i_callback_edit_linetype


@section Function @code{i_callback_edit_filltype()}

@defun i_callback_edit_filltype data callback_action widget
@end defun

<<i_callbacks.c : i_callback_edit_filltype()>>=
/* PB : support for fill dialog */
DEFINE_I_CALLBACK(edit_filltype)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);
	
  i_update_middle_button(w_current, i_callback_edit_color, _("Edit Fill Type"));

  if ( (object = o_select_return_first_object(w_current)) ) {
    fill_type_dialog(w_current, object);
  }
}


@ %def i_callback_edit_filltype


@section Function @code{i_callback_view_redraw()}

@defun i_callback_view_redraw data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_redraw()>>=
/* repeat middle shortcut doesn't make sense on redraw, just hit right
 * button */
DEFINE_I_CALLBACK(view_redraw)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  o_redraw_all(w_current);
}


@ %def i_callback_view_redraw


@section Function @code{i_callback_view_zoom_full()}

@defun i_callback_view_zoom_full data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_full()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_full)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* scroll bar stuff */
  a_zoom(w_current, ZOOM_FULL, DONTCARE, A_PAN_DONT_REDRAW);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_full


@section Function @code{i_callback_view_zoom_extents()}

@defun i_callback_view_zoom_extents data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_extents()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_extents)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* scroll bar stuff */
  a_zoom_extents(w_current, w_current->page_current->object_head,
                A_PAN_DONT_REDRAW);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_extents


@section Function @code{i_callback_view_zoom_box()}

@defun i_callback_view_zoom_box data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_box()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_box)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  w_current->inside_action = 0;
  i_allow_expose();
  i_set_state(w_current, ZOOMBOXSTART);
}


@ %def i_callback_view_zoom_box


@section Function @code{i_callback_view_zoom_box_hotkey()}

@defun i_callback_view_zoom_box_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_box_hotkey()>>=
DEFINE_I_CALLBACK(view_zoom_box_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  a_zoom_box_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ZOOMBOXEND);
}


@ %def i_callback_view_zoom_box_hotkey


@section Function @code{i_callback_view_zoom_in()}

@defun i_callback_view_zoom_in data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_in()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_in)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  a_zoom(w_current, ZOOM_IN, MENU, 0);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_in


@section Function @code{i_callback_view_zoom_out()}

@defun i_callback_view_zoom_out data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_out()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_out)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  a_zoom(w_current, ZOOM_OUT, MENU, 0);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_out


@section Function @code{i_callback_view_zoom_in_hotkey()}

@defun i_callback_view_zoom_in_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_in_hotkey()>>=
/* repeat middle shortcut would get into the way of what user is try
 * to do */
DEFINE_I_CALLBACK(view_zoom_in_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  a_zoom(w_current, ZOOM_IN, HOTKEY, 0);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_in_hotkey


@section Function @code{i_callback_view_zoom_out_hotkey()}

@defun i_callback_view_zoom_out_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_zoom_out_hotkey()>>=
/* repeat middle shortcut would get into the way of what user is try to do */
DEFINE_I_CALLBACK(view_zoom_out_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  a_zoom(w_current, ZOOM_OUT, HOTKEY, 0);
  o_redraw_all_fast(w_current);
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_zoom_out_hotkey


@section Function @code{i_callback_view_pan()}

@defun i_callback_view_pan data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_pan()>>=
DEFINE_I_CALLBACK(view_pan)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  w_current->inside_action = 0;
  i_set_state(w_current, STARTPAN);

  /* I don't know if this would get in the way */
  i_update_middle_button(w_current, i_callback_view_pan, _("Pan"));
}


@ %def i_callback_view_pan


@section Function @code{i_callback_view_pan_hotkey()}

@defun i_callback_view_pan_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_pan_hotkey()>>=
DEFINE_I_CALLBACK(view_pan_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* I don't know if this would get in the way */
  i_update_middle_button(w_current, i_callback_view_pan_hotkey, _("Pan"));

  /* I have NO idea what ramifications removing the next line has,
   * only that it makes the code work when drawing a net and panning
   * at the same time.  Jeff McNeal - 11-19-98
   * w_current->inside_action = 0;
   * I think it's okay - Ales 12/13/98 */

  a_pan(w_current, mouse_x, mouse_y);

  /* Jeff McNeal on Nov 19, 1998 - if we are drawing a net,
   * don't change the event state, because we want to continue
   * drawing a net. If we are just panning, then continue in
   * select mode.  */
  if(!(w_current->event_state == DRAWNET ||
       w_current->event_state == NETCONT ||
       w_current->event_state == STARTDRAWNET )) {
    i_set_state(w_current, SELECT);
    i_update_toolbar(w_current);
  }
  o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
}


@ %def i_callback_view_pan_hotkey


@section Function @code{i_callback_view_update_cues()}

@defun i_callback_view_update_cues data callback_action widget
@end defun

<<i_callbacks.c : i_callback_view_update_cues()>>=
DEFINE_I_CALLBACK(view_update_cues)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  i_update_middle_button(w_current,
                         i_callback_view_update_cues, _("Update Cues"));

  o_redraw_all(w_current);
}


@ %def i_callback_view_update_cues


@section Function @code{i_callback_page_manager()}

@defun i_callback_page_manager data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_manager()>>=
DEFINE_I_CALLBACK(page_manager)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  setup_page_selector(w_current);
}


@ %def i_callback_page_manager


@section Function @code{i_callback_page_next()}

@defun i_callback_page_next data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_next()>>=
DEFINE_I_CALLBACK(page_next)
{
  PAGE *new_page = NULL;
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->next != NULL &&
      w_current->page_current->next->pid != -1) {

    if (w_current->enforce_hierarchy == TRUE) { 
      new_page = s_hierarchy_find_next_page(w_current->
                                            page_current, 
                                            w_current->page_current->page_control);
    } else {
      new_page = w_current->page_current->next;
    }

    if (new_page && new_page != w_current->page_current) {
      w_current->page_current = new_page;
    } else {
      return;
    }
  } else {
    return;
  }

  s_page_goto(w_current, w_current->page_current);
  i_set_filename(w_current, w_current->page_current->page_filename);
  x_scrollbars_update(w_current);
  o_redraw_all(w_current);
  update_page_manager(NULL, w_current);
  i_update_menus(w_current);

}


@ %def i_callback_page_next


@section Function @code{i_callback_page_prev()}

@defun i_callback_page_prev data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_prev()>>=
DEFINE_I_CALLBACK(page_prev)
{
  PAGE *new_page = NULL;
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->prev != NULL &&
      w_current->page_current->prev->pid != -1) {

    if (w_current->enforce_hierarchy == TRUE) { 
      new_page = s_hierarchy_find_prev_page(w_current->
                                            page_current, 
                                            w_current->page_current->page_control);
    } else {
      new_page = w_current->page_current->prev;
    }

    if (new_page && new_page != w_current->page_current) { 
      w_current->page_current = new_page;
    } else {
      return;
    }
  } else {
    return;
  }

  s_page_goto(w_current, w_current->page_current);
  i_set_filename(w_current, w_current->page_current->page_filename);
  x_scrollbars_update(w_current);
  o_redraw_all(w_current);
  update_page_manager(NULL, w_current);
  i_update_menus(w_current);
}


@ %def i_callback_page_prev


@section Function @code{i_callback_page_new()}

@defun i_callback_page_new data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_new()>>=
DEFINE_I_CALLBACK(page_new)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *filename = NULL;

  exit_if_null(w_current);

  if (getcwd(w_current->cwd, 256)) {
#ifdef __MINGW32__
    u_basic_strip_trailing(w_current->cwd, PATH_SEPARATER_CHAR);
#endif
    /* TODO: perform a NULL check */
    /* the 20 is a hack and needs to be changed */
    filename = malloc(sizeof(char) *
                      (strlen(w_current->cwd) +
                       strlen(w_current->series_name) +
                       strlen("/_##########.sch") +
                       1));

    w_current->num_untitled++;
    sprintf(filename, "%s%c%s_%d.sch",
            w_current->cwd, PATH_SEPARATER_CHAR,
            w_current->series_name,
            w_current->num_untitled);

  } else {
    fprintf(stderr, _("Cannot get cwd!\n"));
  }

  s_page_new(w_current, filename);

  update_page_manager(NULL, w_current);
  i_update_menus(w_current);
  i_set_filename(w_current, w_current->page_current->page_filename);
  s_log_message(_("New Page created [%s]\n"),
                w_current->page_current->page_filename);
  o_redraw_all(w_current);
}


@ %def i_callback_page_new


@section Function @code{i_callback_page_close()}

@defun i_callback_page_close data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_close()>>=
DEFINE_I_CALLBACK(page_close)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  PAGE *p_current;
  PAGE *p_save;

  exit_if_null(w_current);

  if (w_current->page_current->CHANGED) {
    x_fileselect_setup(w_current, FILESELECT, SAVEAS_CLOSE);

#if 0 /* replaced with above */
    setup_saveas_file_selector(
                               w_current, CLOSE,
                               w_current->page_current->page_filename);
#endif
    return;
  }

  /* Can we go up in the hierarchy first? */
  p_current = s_hierarchy_find_page(w_current->page_head, 
                                    w_current->page_current->up);
  if (p_current) {
    s_log_message(_("Closing [%s]\n"),
                  w_current->page_current->page_filename);
    s_page_free(w_current, w_current->page_current);
    w_current->page_current = p_current;

    s_page_goto(w_current, w_current->page_current);
    i_set_filename(w_current,
                   w_current->page_current->page_filename);
    x_scrollbars_update(w_current);
    o_redraw_all(w_current);
    update_page_manager(NULL, w_current);
    i_update_menus(w_current);
    return;
  }

  if (w_current->page_current->prev) {
    if (w_current->page_current->prev->pid != -1) {
      p_current = w_current->page_current->prev;
      s_log_message(_("Closing [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;

      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }

  if (w_current->page_current->next) {
    if (w_current->page_current->next->pid != -1) {
      p_current = w_current->page_current->next;
      s_log_message(_("Closing [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;
      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }

  /* finally go here if you can't delete the page */
  /* because it's the last page being displayed */
  /* s_log_message("Cannot close current page\n");*/
  /* now the code creates a new page, and closes the old one */
  p_save = w_current->page_current;
  i_callback_page_new(w_current, 0, NULL);
  w_current->page_current = p_save;	

  if (w_current->page_current->next) {
    if (w_current->page_current->next->pid != -1) {
      p_current = w_current->page_current->next;
      s_log_message(_("Closing [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;
      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }

}


@ %def i_callback_page_close


@section Function @code{i_callback_page_revert()}

@defun i_callback_page_revert data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_revert()>>=
/* TODO: may have memory leak? */
DEFINE_I_CALLBACK(page_revert)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *filename;
  int page_control;
  int up;

  exit_if_null(w_current);

  filename = u_basic_strdup(w_current->page_current->page_filename);

  /* save this for later */
  page_control = w_current->page_current->page_control;
  up = w_current->page_current->up;

  s_page_free(w_current, w_current->page_current);
  s_page_new(w_current, filename);

  /* now re open it */
  f_open(w_current, w_current->page_current->page_filename);
  i_set_filename(w_current, w_current->page_current->page_filename);

  /* make sure we maintain the hierarchy info */
  w_current->page_current->page_control = page_control;
  w_current->page_current->up = up;

  x_repaint_background(w_current);
  x_window_setup_world(w_current);
  x_manual_resize(w_current);
  a_zoom_extents(w_current, w_current->page_current->object_head,
                A_PAN_DONT_REDRAW);
  o_undo_savestate(w_current, UNDO_ALL);

  /* now update the scrollbars */
  x_hscrollbar_update(w_current);
  x_vscrollbar_update(w_current);
  update_page_manager(NULL, w_current);
  i_update_menus(w_current);

  o_redraw_all(w_current);
  free(filename);
}


@ %def i_callback_page_revert


@section Function @code{i_callback_page_discard()}

@defun i_callback_page_discard data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_discard()>>=
DEFINE_I_CALLBACK(page_discard)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  PAGE *p_current;
  PAGE *p_save;

  exit_if_null(w_current);

  /* Can we go up in the hierarchy first? */
  p_current = s_hierarchy_find_page(w_current->page_head, 
                                    w_current->page_current->up);
  if (p_current) {
    s_log_message(_("Closing [%s]\n"),
                  w_current->page_current->page_filename);
    s_page_free(w_current, w_current->page_current);
    w_current->page_current = p_current;

    s_page_goto(w_current, w_current->page_current);
    i_set_filename(w_current,
                   w_current->page_current->page_filename);
    x_scrollbars_update(w_current);
    o_redraw_all(w_current);
    update_page_manager(NULL, w_current);
    i_update_menus(w_current);
    return;
  }

  if (w_current->page_current->prev) {
    if (w_current->page_current->prev->pid != -1) {
      p_current = w_current->page_current->prev;
      s_log_message(_("Discarding page [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;
      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }

  if (w_current->page_current->next) {
    if (w_current->page_current->next->pid != -1) {
      p_current = w_current->page_current->next;
      s_log_message(_("Discarding page [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;
      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }

  /* finally go here if you can't delete the page */
  /* because it's the last page being displayed */
  /* s_log_message("Cannot close current page\n");*/
  /* now the code creates a new page, and closes the old one */

  p_save = w_current->page_current;
  i_callback_page_new(w_current, 0, NULL);
  w_current->page_current = p_save;	

  if (w_current->page_current->next) {
    if (w_current->page_current->next->pid != -1) {
      p_current = w_current->page_current->next;
      s_log_message(_("Closing [%s]\n"),
                    w_current->page_current->page_filename);
      s_page_free(w_current, w_current->page_current);
      w_current->page_current = p_current;
      s_page_goto(w_current, w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      x_scrollbars_update(w_current);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      return;
    }
  }
}


@ %def i_callback_page_discard


@section Function @code{i_callback_page_print()}

@defun i_callback_page_print data callback_action widget
@end defun

<<i_callbacks.c : i_callback_page_print()>>=
DEFINE_I_CALLBACK(page_print)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  s_page_print_all(w_current);
}


@ %def i_callback_page_print


@section Function @code{i_callback_buffer_copy1()}

@defun i_callback_buffer_copy1 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_copy1()>>=
DEFINE_I_CALLBACK(buffer_copy1)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_copy1, _("Copy 1"));
  o_buffer_copy(w_current, 0);
}


@ %def i_callback_buffer_copy1


@section Function @code{i_callback_buffer_copy2()}

@defun i_callback_buffer_copy2 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_copy2()>>=
DEFINE_I_CALLBACK(buffer_copy2)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_copy2, _("Copy 2"));
  o_buffer_copy(w_current, 1);
}


@ %def i_callback_buffer_copy2


@section Function @code{i_callback_buffer_copy3()}

@defun i_callback_buffer_copy3 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_copy3()>>=
DEFINE_I_CALLBACK(buffer_copy3)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_copy3, _("Copy 3"));
  o_buffer_copy(w_current, 2);
}


@ %def i_callback_buffer_copy3


@section Function @code{i_callback_buffer_copy4()}

@defun i_callback_buffer_copy4 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_copy4()>>=
DEFINE_I_CALLBACK(buffer_copy4)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_copy4, _("Copy 4"));
  o_buffer_copy(w_current, 3);
}


@ %def i_callback_buffer_copy4


@section Function @code{i_callback_buffer_copy5()}

@defun i_callback_buffer_copy5 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_copy5()>>=
DEFINE_I_CALLBACK(buffer_copy5)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_copy5, _("Copy 5"));
  o_buffer_copy(w_current, 4);
}


@ %def i_callback_buffer_copy5


@section Function @code{i_callback_buffer_cut1()}

@defun i_callback_buffer_cut1 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_cut1()>>=
DEFINE_I_CALLBACK(buffer_cut1)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_cut1, _("Cut 1"));
  o_buffer_cut(w_current, 0);
}


@ %def i_callback_buffer_cut1


@section Function @code{i_callback_buffer_cut2()}

@defun i_callback_buffer_cut2 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_cut2()>>=
DEFINE_I_CALLBACK(buffer_cut2)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_cut2, _("Cut 2"));
  o_buffer_cut(w_current, 1);
}


@ %def i_callback_buffer_cut2


@section Function @code{i_callback_buffer_cut3()}

@defun i_callback_buffer_cut3 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_cut3()>>=
DEFINE_I_CALLBACK(buffer_cut3)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_cut3, _("Cut 3"));
  o_buffer_cut(w_current, 2);
}


@ %def i_callback_buffer_cut3


@section Function @code{o_callback_buffer_cut4()}

@defun o_callback_buffer_cut4 data callback_action widget
@end defun

<<i_callbacks.c : o_callback_buffer_cut4()>>=
DEFINE_I_CALLBACK(buffer_cut4)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_cut4, _("Cut 4"));
  o_buffer_cut(w_current, 3);
}


@ %def o_callback_buffer_cut4


@section Function @code{i_callback_buffer_cut5()}

@defun i_callback_buffer_cut5 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_cut5()>>=
DEFINE_I_CALLBACK(buffer_cut5)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->page_current->selection2_head->next == NULL)
  return;

  i_update_middle_button(w_current, i_callback_buffer_cut5, _("Cut 5"));
  o_buffer_cut(w_current, 4);
}


@ %def i_callback_buffer_cut5


@section Function @code{i_callback_buffer_paste1()}

@defun i_callback_buffer_paste1 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste1()>>=
DEFINE_I_CALLBACK(buffer_paste1)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_buffer_paste1, _("Paste 1"));
  if (object_buffer[0] != NULL) {
    if (object_buffer[0]->next != NULL) {
      w_current->buffer_number = 0;
      w_current->inside_action = 1;
      i_set_state(w_current, STARTPASTE);
    }
  } else { 
    i_set_state_msg(w_current, SELECT, _("Empty buffer"));
  }
}


@ %def i_callback_buffer_paste1


@section Function @code{i_callback_buffer_paste2()}

@defun i_callback_buffer_paste2 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste2()>>=
DEFINE_I_CALLBACK(buffer_paste2)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_buffer_paste2, _("Paste 2"));
  if (object_buffer[1] != NULL) {
    if (object_buffer[1]->next != NULL) {
      w_current->buffer_number = 1;
      w_current->inside_action = 1;
      i_set_state(w_current, STARTPASTE);
    }
  } else {
    i_set_state_msg(w_current, SELECT, _("Empty buffer"));
  }
}


@ %def i_callback_buffer_paste2


@section Function @code{i_callback_buffer_paste3()}

@defun i_callback_buffer_paste3 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste3()>>=
DEFINE_I_CALLBACK(buffer_paste3)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_buffer_paste3, _("Paste 3"));
  if (object_buffer[2] != NULL) {
    if (object_buffer[2]->next != NULL) {
      w_current->buffer_number = 2;
      w_current->inside_action = 1;
      i_set_state(w_current, STARTPASTE);
    }
  } else { 
    i_set_state_msg(w_current, SELECT, _("Empty buffer"));
  }
}


@ %def i_callback_buffer_paste3


@section Function @code{i_callback_buffer_paste4()}

@defun i_callback_buffer_paste4 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste4()>>=
DEFINE_I_CALLBACK(buffer_paste4)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_buffer_paste4, _("Paste 4"));
  if (object_buffer[3] != NULL) {
    if (object_buffer[3]->next != NULL) {
      w_current->buffer_number = 3;
      w_current->inside_action = 1;
      i_set_state(w_current, STARTPASTE);
    }
  } else {
    i_set_state_msg(w_current, SELECT, _("Empty buffer"));
  }
}


@ %def i_callback_buffer_paste4


@section Function @code{i_callback_buffer_paste5()}

@defun i_callback_buffer_paste5 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste5()>>=
DEFINE_I_CALLBACK(buffer_paste5)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  i_update_middle_button(w_current, i_callback_buffer_paste5, _("Paste 5"));
  if (object_buffer[4] != NULL) {
    if (object_buffer[4]->next != NULL) {
      w_current->buffer_number = 4;
      w_current->inside_action = 1;
      i_set_state(w_current, STARTPASTE);
    }
  } else {
    i_set_state_msg(w_current, SELECT, _("Empty buffer"));
  }
}


@ %def i_callback_buffer_paste5


@section Function @code{i_callback_buffer_paste1_hotkey()}

@defun i_callback_buffer_paste1_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste1_hotkey()>>=
DEFINE_I_CALLBACK(buffer_paste1_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (object_buffer[0] == NULL) {
    return;
  }

  if (object_buffer[0]->next == NULL)  {
    return;
	
  }
	
  o_buffer_paste_start(w_current, mouse_x, mouse_y, 0);
}


@ %def i_callback_buffer_paste1_hotkey


@section Function @code{i_callback_buffer_paste2_hotkey()}

@defun i_callback_buffer_paste2_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste2_hotkey()>>=
DEFINE_I_CALLBACK(buffer_paste2_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (object_buffer[1] == NULL) {
    return;
  }

  if (object_buffer[1]->next == NULL)  {
    return;
	
  }

  o_buffer_paste_start(w_current, mouse_x, mouse_y, 1);
}


@ %def i_callback_buffer_paste2_hotkey


@section Function @code{i_callback_buffer_paste3_hotkey()}

@defun i_callback_buffer_paste3_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste3_hotkey()>>=
DEFINE_I_CALLBACK(buffer_paste3_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (object_buffer[2] == NULL) {
    return;
  }

  if (object_buffer[2]->next == NULL)  {
    return;
	
  }

  o_buffer_paste_start(w_current, mouse_x, mouse_y, 2);
}


@ %def i_callback_buffer_paste3_hotkey


@section Function @code{i_callback_buffer_paste4_hotkey()}

@defun i_callback_buffer_paste4_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste4_hotkey()>>=
DEFINE_I_CALLBACK(buffer_paste4_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (object_buffer[3] == NULL) {
    return;
  }

  if (object_buffer[3]->next == NULL)  {
    return;
	
  }

  o_buffer_paste_start(w_current, mouse_x, mouse_y, 3);
}


@ %def i_callback_buffer_paste4_hotkey


@section Function @code{i_callback_buffer_paste5_hotkey()}

@defun i_callback_buffer_paste5_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_buffer_paste5_hotkey()>>=
DEFINE_I_CALLBACK(buffer_paste5_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (object_buffer[4] == NULL) {
    return;
  }

  if (object_buffer[4]->next == NULL)  {
    return;
	
  }

  o_buffer_paste_start(w_current, mouse_x, mouse_y, 4);
}


@ %def i_callback_buffer_paste5_hotkey


@section Function @code{i_callback_add_component()}

@defun i_callback_add_component data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_component()>>=
DEFINE_I_CALLBACK(add_component)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  x_fileselect_setup(w_current, COMPSELECT, -1);

#if 0 /* replaced by above */
  setup_place_file_selector(w_current);
#endif
  i_update_middle_button(w_current,
                         i_callback_add_component, _("Component"));

  i_allow_expose();
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);
}


@ %def i_callback_add_component


@section Function @code{i_callback_toolbar_add_component()}

@defun i_callback_toolbar_add_component widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_add_component()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_add_component(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_add_component((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_add_component


@section Function @code{i_callback_add_attribute()}

@defun i_callback_add_attribute data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_attribute()>>=
DEFINE_I_CALLBACK(add_attribute)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  attrib_edit_dialog(w_current, NULL, FROM_MENU);
  i_update_middle_button(w_current, i_callback_add_attribute,
                         _("Attribute"));

  i_allow_expose();
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);
}


@ %def i_callback_add_attribute


@section Function @code{i_callback_add_attribute_hotkey()}

@defun i_callback_add_attribute_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_attribute_hotkey()>>=
DEFINE_I_CALLBACK(add_attribute_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  attrib_edit_dialog(w_current, NULL, FROM_HOTKEY);
  i_update_middle_button(w_current, i_callback_add_attribute_hotkey,
                         _("Attribute"));

  i_allow_expose();
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);
}


@ %def i_callback_add_attribute_hotkey


@section Function @code{i_callback_add_net()}

@defun i_callback_add_net data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_net()>>=
DEFINE_I_CALLBACK(add_net)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  /* need to click */
  i_update_middle_button(w_current, i_callback_add_net, _("Net"));
  i_allow_expose();
  i_set_state(w_current, STARTDRAWNET);
  i_update_toolbar(w_current);
  /* somewhere you need to nearest point locking... */
  w_current->inside_action = 0;
}


@ %def i_callback_add_net


@section Function @code{i_callback_add_net_hotkey()}

@defun i_callback_add_net_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_net_hotkey()>>=
DEFINE_I_CALLBACK(add_net_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
 
  o_erase_rubber(w_current);

  /* need to click */
  i_update_middle_button(w_current, i_callback_add_net_hotkey, _("Net"));
  i_allow_expose();
  i_set_state(w_current, STARTDRAWNET);
  i_update_toolbar(w_current);

  o_net_start(w_current, mouse_x, mouse_y);

  w_current->event_state=DRAWNET;
  w_current->inside_action = 1;
}


@ %def i_callback_add_net_hotkey


@section Function @code{i_callback_toolbar_add_net()}

@defun i_callback_toolbar_add_net widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_add_net()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_add_net(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  if (GTK_TOGGLE_BUTTON (widget)->active) {
    i_callback_add_net((TOPLEVEL*) data, 0, NULL);
  }
}


@ %def i_callback_toolbar_add_net


@section Function @code{i_callback_add_bus()}

@defun i_callback_add_bus data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_bus()>>=
DEFINE_I_CALLBACK(add_bus)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  /* need to click */
  i_update_middle_button(w_current, i_callback_add_bus, _("Bus"));
  i_allow_expose();
  i_set_state(w_current, STARTDRAWBUS);
  i_update_toolbar(w_current);

  /* somewhere you need to nearest point locking... */
  w_current->inside_action = 0;
}


@ %def i_callback_add_bus


@section Function @code{i_callback_add_bus_hotkey()}

@defun i_callback_add_bus_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_bus_hotkey()>>=
DEFINE_I_CALLBACK(add_bus_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  /* need to click */
  i_update_middle_button(w_current, i_callback_add_bus_hotkey, _("Bus"));
  i_allow_expose();
  i_set_state(w_current, STARTDRAWBUS);
  i_update_toolbar(w_current);

  o_bus_start(w_current, mouse_x, mouse_y);

  w_current->event_state=DRAWBUS;
  w_current->inside_action = 1;
}


@ %def i_callback_add_bus_hotkey


@section Function @code{i_callback_toolbar_add_bus()}

@defun i_callback_toolbar_add_bus widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_add_bus()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_add_bus(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  if (GTK_TOGGLE_BUTTON (widget)->active) {
     i_callback_add_bus((TOPLEVEL*) data, 0, NULL);
  }
}


@ %def i_callback_toolbar_add_bus


@section Function @code{i_callback_add_text()}

@defun i_callback_add_text data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_text()>>=
DEFINE_I_CALLBACK(add_text)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  
  o_erase_rubber(w_current);

  w_current->inside_action = 0;
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);

  text_input_dialog(w_current);
}


@ %def i_callback_add_text


@section Function @code{i_callback_toolbar_add_text()}

@defun i_callback_toolbar_add_text widget data
@end defun

<<i_callbacks.c : i_callback_toolbar_add_text()>>=
/* don't use the widget parameter on this function, or do some checking... */
/* since there is a call: widget = NULL, data = 0 (will be w_current hack) */
void i_callback_toolbar_add_text(GtkWidget* widget, gpointer data)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);
  if (!w_current->window) return;

  i_callback_add_text((TOPLEVEL*) data, 0, NULL);
}


@ %def i_callback_toolbar_add_text


@section Function @code{i_callback_add_line()}

@defun i_callback_add_line data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_line()>>=
DEFINE_I_CALLBACK(add_line)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_line, _("Line"));
  i_allow_expose();
  i_set_state(w_current, DRAWLINE);
  w_current->inside_action = 0;
}


@ %def i_callback_add_line


@section Function @code{i_callback_add_line_hotkey()}

@defun i_callback_add_line_hotkey data callback_action widget 
@end defun

<<i_callbacks.c : i_callback_add_line_hotkey()>>=
DEFINE_I_CALLBACK(add_line_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_line_hotkey, _("Line"));

  o_line_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ENDLINE);
}


@ %def i_callback_add_line_hotkey


@section Function @code{i_callback_add_box()}

@defun i_callback_add_box data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_box()>>=
DEFINE_I_CALLBACK(add_box)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_box, _("Box"));
  w_current->inside_action = 0;
  i_allow_expose();
  i_set_state(w_current, DRAWBOX);
}


@ %def i_callback_add_box


@section Function @code{i_callback_add_box_hotkey()}

@defun i_callback_add_box_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_box_hotkey()>>=
DEFINE_I_CALLBACK(add_box_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_box_hotkey, _("Box"));

  o_box_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ENDBOX);
}


@ %def i_callback_add_box_hotkey


@section Function @code{i_callback_add_circle()}

@defun i_callback_add_circle data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_circle()>>=
DEFINE_I_CALLBACK(add_circle)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_circle, _("Circle"));
  w_current->inside_action = 0;
  i_allow_expose();
  i_set_state(w_current, DRAWCIRCLE);
}


@ %def i_callback_add_circle


@section Function @code{i_callback_add_circle_hotkey()}

@defun i_callback_add_circle_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_circle_hotkey()>>=
DEFINE_I_CALLBACK(add_circle_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_circle_hotkey,
                         _("Circle"));

  o_circle_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ENDCIRCLE);
}


@ %def i_callback_add_circle_hotkey


@section Function @code{i_callback_add_arc()}

@defun i_callback_add_arc data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_arc()>>=
DEFINE_I_CALLBACK(add_arc)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  
  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_arc, _("Arc"));
  w_current->inside_action = 0;
  i_allow_expose();
  i_set_state(w_current, DRAWARC);
}


@ %def i_callback_add_arc


@section Function @code{i_callback_add_arc_hotkey()}

@defun i_callback_add_arc_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_arc_hotkey()>>=
DEFINE_I_CALLBACK(add_arc_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_arc_hotkey, _("Arc"));

  o_arc_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ENDARC);
}


@ %def i_callback_add_arc_hotkey


@section Function @code{i_callback_add_pin()}

@defun i_callback_add_pin data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_pin()>>=
DEFINE_I_CALLBACK(add_pin)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_pin, _("Pin"));
  w_current->inside_action = 0;
  i_allow_expose();
  i_set_state(w_current, DRAWPIN);
}


@ %def i_callback_add_pin


@section Function @code{i_callback_add_pin_hotkey()}

@defun i_callback_add_pin_hotkey data callback_action widget
@end defun

<<i_callbacks.c : i_callback_add_pin_hotkey()>>=
DEFINE_I_CALLBACK(add_pin_hotkey)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  o_erase_rubber(w_current);

  i_update_middle_button(w_current, i_callback_add_pin_hotkey, _("Pin"));

  o_pin_start(w_current, mouse_x, mouse_y);

  w_current->inside_action = 1;
  i_allow_expose();
  i_set_state(w_current, ENDPIN);
}


@ %def i_callback_add_pin_hotkey


/* Hierarchy menu */
@section Function @code{i_callback_hierarchy_down_schematic()}

@defun i_callback_hierarchy_down_schematic data callback_action widget
@end defun

<<i_callbacks.c : i_callback_hierarchy_down_schematic()>>=
DEFINE_I_CALLBACK(hierarchy_down_schematic)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *attrib=NULL;
  char *current_filename=NULL;
  int count=0;
  OBJECT *object=NULL;
  PAGE *save_first_page=NULL;
  PAGE *parent=NULL;
  int loaded_flag=FALSE;
  int page_control = 0;
  int saved_page_control = 0;
  int pcount = 0;
  int looking_inside=FALSE;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);
  if (object != NULL) {
    /* only allow going into symbols */
    if (object->type == OBJ_COMPLEX) {

      parent = w_current->page_current;
      attrib = o_attrib_search_name_single_count(object,
                                                 "source",
                                                 count);

      /* if above is null, then look inside symbol */
      if (attrib == NULL) {
        attrib = o_attrib_search_name(object->
                                      complex->
                                      prim_objs,
                                      "source", 
                                      count);
        looking_inside = TRUE;
#if DEBUG
        printf("going to look inside now\n");
#endif
      }

      while (attrib) {

				/* look for source=filename,filename, ... */
        pcount = 0;
        
        current_filename = u_basic_breakup_string(attrib, ',', pcount);

				/* loop over all filenames */
        while(current_filename != NULL) {

          s_log_message(
                        _("Searching for source [%s]\n"), 
                        current_filename);
          saved_page_control = page_control;
          page_control = 
            s_hierarchy_down_schematic_single(
                                              w_current, 
                                              current_filename, 
                                              parent,
                                              page_control,
                                              HIERARCHY_NORMAL_LOAD);

          if (page_control != -1)  {
            a_zoom_extents(w_current, 
                          w_current->
                          page_current->
                          object_head,
                          A_PAN_DONT_REDRAW);
            o_undo_savestate(w_current, 
                             UNDO_ALL);
          }


          /* save the first page */
          if (!loaded_flag && 
              page_control != -1 && 
              page_control != 0) {
            save_first_page = w_current->
              page_current;
          }

          /* now do some error fixing */
          if (page_control == -1) {
            s_log_message(
                          _("Cannot find source [%s]\n"), 
                          current_filename);
            fprintf(stderr, 
                    _("Cannot find source [%s]\n"), 
                    current_filename); 

            /* restore this for the next */
            /* page */
            page_control = 
              saved_page_control;
          } else {
            /* this only signifies that */
            /* we tried */
            loaded_flag = TRUE;
          }

          free(current_filename);
          pcount++;
          current_filename = u_basic_breakup_string(attrib, ',', pcount);
        }

        if (attrib) {
          free(attrib);
        }

        if (current_filename) {
          free(current_filename);
        }

        count++;

				/* continue looking outside first */
        if (!looking_inside) {
          attrib = 
            o_attrib_search_name_single_count(object, "source", count);
        } 

				/* okay we were looking outside and didn't */
				/* find anything, so now we need to look */
				/* inside the symbol */
        if (!looking_inside && attrib == NULL && !loaded_flag ) {
          looking_inside = TRUE;
#if DEBUG
          printf("switching to go to look inside\n");
#endif
        }

        if (looking_inside) {
#if DEBUG
          printf("looking inside\n");
#endif
          attrib = o_attrib_search_name(
                                        object->complex->
                                        prim_objs,
                                        "source",
                                        count);
        }
      } 

      if (loaded_flag) {
	
        if (save_first_page) {
          w_current->page_current = 
            save_first_page;
        }
        i_set_filename(w_current, w_current->
                       page_current->page_filename);
        a_zoom_extents(w_current, 
                      w_current->page_current->object_head,
                      A_PAN_DONT_REDRAW);
        o_redraw_all(w_current);
        update_page_manager(NULL, w_current);
        i_update_menus(w_current);
      }
    }
  }
}


@ %def i_callback_hierarchy_down_schematic


@section Function @code{i_callback_hierarchy_down_symbol()}

@defun i_callback_hierarchy_down_symbol data callback_action widget
@end defun

<<i_callbacks.c : i_callback_hierarchy_down_symbol()>>=
DEFINE_I_CALLBACK(hierarchy_down_symbol)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;
  char *filename;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);
  if (object != NULL) {
    /* only allow going into symbols */
    if (object->type == OBJ_COMPLEX) {
      filename = u_basic_strdup_multiple( 
                                         object->complex_clib, 
					 PATH_SEPARATER_STRING, 
                                         object->complex_basename, NULL);
      s_log_message(_("Searching for symbol [%s]\n"), filename);
      s_hierarchy_down_symbol(w_current, filename, 
                              w_current->page_current);
      i_set_filename(w_current,
                     w_current->page_current->page_filename);
      a_zoom_extents(w_current, 
                    w_current->page_current->object_head,
                    A_PAN_DONT_REDRAW);
      o_undo_savestate(w_current, UNDO_ALL);
      o_redraw_all(w_current);
      update_page_manager(NULL, w_current);
      i_update_menus(w_current);
      free(filename);
    }
  }
}


@ %def i_callback_hierarchy_down_symbol

@section Function @code{i_callback_hierarchy_up()}


@defun i_callback_hierarchy_up data callback_action widget
@end defun

<<i_callbacks.c : i_callback_hierarchy_up()>>=
DEFINE_I_CALLBACK(hierarchy_up)
{
	TOPLEVEL *w_current = (TOPLEVEL *) data;

	exit_if_null(w_current);

	s_hierarchy_up(w_current, w_current->page_current->up);
	i_set_filename(w_current, w_current->page_current->page_filename);
	o_redraw_all(w_current);
	update_page_manager(NULL, w_current);
        i_update_menus(w_current);
}


@ %def i_callback_hierarchy_up



@section Function @code{i_callback_hierarchy_documentation()}

@defun i_callback_hierarchy_documentation data callback_action widget
@end defun

<<i_callbacks.c : i_callback_hierarchy_documentation()>>=
/* Egil Kvaleberg <egil@kvaleberg.no> on October 7, 2002 - 
 * Provide documentation for symbol (i.e. component)
 */
DEFINE_I_CALLBACK(hierarchy_documentation)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  char *attrib_doc = NULL;
  char *attrib_device = NULL;
  char *attrib_value = NULL;
  OBJECT *object = NULL;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);
  if (object != NULL) {
    /* only allow going into symbols */
    if (object->type == OBJ_COMPLEX) {

      /* look for "documentation" first outside, then inside symbol */
      attrib_doc = o_attrib_search_name_single_count(object, "documentation", 0);
      if (!attrib_doc) {
	attrib_doc = o_attrib_search_name(object->complex->prim_objs,
								"documentation", 0);
      }
      /* look for "device" */
      attrib_device = o_attrib_search_name_single_count(object, "device", 0);
      if (!attrib_device) {
	attrib_device = o_attrib_search_name(object->complex->prim_objs,
								"device", 0);
      }
      /* look for "value" */
      attrib_value = o_attrib_search_name_single_count(object, "value", 0);
      if (!attrib_value) {
	attrib_value = o_attrib_search_name(object->complex->prim_objs,
								"value", 0);
      }
      initiate_gschemdoc(attrib_doc,
			attrib_device,
			attrib_value,
			object->complex_basename,
			object->complex_clib);

      if (attrib_doc) free(attrib_doc);
      if (attrib_device) free(attrib_device);
      if (attrib_value) free(attrib_value);
    }
  }
}

@ %def i_callback_hierarchy_documentation


/* Attributes menu */
@section Function @code{i_callback_attributes_attach()}

@defun i_callback_attributes_attach data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_attach()>>=
DEFINE_I_CALLBACK(attributes_attach)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *first_object;
  SELECTION *s_current;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  /* do we want to update the shortcut outside of the ifs? */
  /* probably, if this fails the user may want to try again */
  i_update_middle_button(w_current, i_callback_attributes_attach,
                         _("Attach"));

  /* skip over head */
  s_current = w_current->page_current->selection2_head->next;
  if (!s_current) {
    return;
  }

  first_object = s_current->selected_object; 
  if (!first_object) {
    return;	
  }

  /* skip over first object */
  s_current = s_current->next;
  while (s_current != NULL) {
    if (s_current->selected_object) {
      o_attrib_attach(w_current,
                      w_current->page_current->object_head,
                      s_current->selected_object,
                      first_object);
      w_current->page_current->CHANGED=1;
    }
    s_current = s_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def i_callback_attributes_attach


@section Function @code{i_callback_attributes_detach()}

@defun i_callback_attributes_detach data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_detach()>>=
DEFINE_I_CALLBACK(attributes_detach)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  SELECTION *s_current;
  OBJECT *o_current;

  exit_if_null(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  /* same note as above on i_update_middle_button */
  i_update_middle_button(w_current, i_callback_attributes_detach,
                         _("Detach"));

  /* skip over head */
  s_current = w_current->page_current->selection2_head->next;
  while (s_current != NULL) {
    o_current = s_current->selected_object;
    if (o_current) {
      if (o_current->attribs) {
        o_attrib_free_all(w_current, 
                          o_current->attribs);
        o_current->attribs = NULL;
        w_current->page_current->CHANGED=1;
      }
    }
    s_current = s_current->next;
  }
  o_undo_savestate(w_current, UNDO_ALL);
}


@ %def i_callback_attributes_detach


@section Function @code{i_callback_attributes_show_name()}

@defun i_callback_attributes_show_name data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_show_name()>>=
DEFINE_I_CALLBACK(attributes_show_name)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  i_update_middle_button(w_current, i_callback_attributes_show_name,
                         _("ShowN"));

  if (object != NULL) {
    o_attrib_toggle_show_name_value(w_current, 
                                    w_current->page_current->
                                    selection2_head->next,
                                    SHOW_NAME);
  }
}


@ %def i_callback_attributes_show_name


@section Function @code{i_callback_attributes_show_value()}

@defun i_callback_attributes_show_value data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_show_value()>>=
DEFINE_I_CALLBACK(attributes_show_value)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  i_update_middle_button(w_current, i_callback_attributes_show_value,
                         _("ShowV"));

  if (object != NULL) {
    o_attrib_toggle_show_name_value(w_current, 
                                    w_current->page_current->
                                    selection2_head->next,
                                    SHOW_VALUE);
  }
}


@ %def i_callback_attributes_show_value


@section Function @code{i_callback_attributes_show_both()}

@defun i_callback_attributes_show_both data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_show_both()>>=
DEFINE_I_CALLBACK(attributes_show_both)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  i_update_middle_button(w_current, i_callback_attributes_show_both,
                         _("ShowB"));

  if (object != NULL) {
    o_attrib_toggle_show_name_value(w_current, 
                                    w_current->page_current->
                                    selection2_head->next,
                                    SHOW_NAME_VALUE);
  }
}


@ %def i_callback_attributes_show_both


@section Function @code{i_callback_attributes_visibility_toggle()}

@defun i_callback_attributes_visibility_toggle data callback_action widget
@end defun

<<i_callbacks.c : i_callback_attributes_visibility_toggle()>>=
DEFINE_I_CALLBACK(attributes_visibility_toggle)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *object;

  exit_if_null(w_current);

  object = o_select_return_first_object(w_current);

  /* This is a new addition 3/15 to prevent this from executing
   * inside an action */
  if (w_current->inside_action) {
    return;
  }

  i_update_middle_button(w_current,
                         i_callback_attributes_visibility_toggle,
                         _("VisToggle"));

  if (object != NULL) {
    o_attrib_toggle_visibility(w_current, 
                               w_current->page_current->
                               selection2_head->next);
  }
}


@ %def i_callback_attributes_visibility_toggle


/* Script menu */
/* not currently implemented */
@section Function @code{i_callback_script_console()}

@defun i_callback_script_console data callback_action widget
@end defun

<<i_callbacks.c : i_callback_script_console()>>=
DEFINE_I_CALLBACK(script_console)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  printf(_("Sorry but this is a non-functioning menu option\n"));
}


@ %def i_callback_script_console


/* Layers menu */

/* Options menu */

/* repeat last command doesn't make sense on options either??? (does it?) */
@section Function @code{i_callback_options_text_size()}

@defun i_callback_options_text_size data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_text_size()>>=
DEFINE_I_CALLBACK(options_text_size)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  text_size_dialog(w_current);
}


@ %def i_callback_options_text_size


@section Function @code{i_callback_options_snap_size()}

@defun i_callback_options_snap_size data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_snap_size()>>=
DEFINE_I_CALLBACK(options_snap_size)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  snap_size_dialog(w_current);
}


@ %def i_callback_options_snap_size


@section Function @code{i_callback_options_afeedback()}

@defun i_callback_options_afeedback data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_afeedback()>>=
/* repeat last command doesn't make sense on options either??? (does
 * it?) */
DEFINE_I_CALLBACK(options_afeedback)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->actionfeedback_mode == BOUNDINGBOX) {
    w_current->actionfeedback_mode = OUTLINE;
    s_log_message(_("Action feedback mode set to OUTLINE\n"));
  } else {
    w_current->actionfeedback_mode = BOUNDINGBOX;
    s_log_message(_("Action feedback mode set to BOUNDINGBOX\n"));
  }
}


@ %def i_callback_options_afeedback


@section Function @code{i_callback_options_grid()}

@defun i_callback_options_grid data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_grid()>>=
DEFINE_I_CALLBACK(options_grid)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  if (w_current->grid) {
    w_current->grid = 0;
    s_log_message(_("Grid OFF\n"));
  } else {
    w_current->grid = 1;
    s_log_message(_("Grid ON\n"));
  }

  o_redraw_all(w_current);
}


@ %def i_callback_options_grid


@section Function @code{i_callback_options_snap()}

@defun i_callback_options_snap data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_snap()>>=
DEFINE_I_CALLBACK(options_snap)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  if (w_current->snap) {
    w_current->snap = 0;
    s_log_message(_("Snap OFF (CAUTION!)\n"));
  } else {
    w_current->snap = 1;
    s_log_message(_("Snap ON\n"));
  }
  i_show_state(w_current, NULL); /* update status on screen */
}


@ %def i_callback_options_snap


@section Function @code{i_callback_options_rubberband()}

@defun i_callback_options_rubberband data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_rubberband()>>=
/* Rubber band is cool ! */
/* Added on/off option from the pull down menu */
/* Chris Ellec - January 2001 */
DEFINE_I_CALLBACK(options_rubberband)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  if (w_current->netconn_rubberband) {
    w_current->netconn_rubberband = 0;
    s_log_message(_("Rubber band OFF \n"));
  } else {
    w_current->netconn_rubberband = 1;
    s_log_message(_("Rubber band ON\n"));
  }
}


@ %def i_callback_options_rubberband


@section Function @code{i_callback_options_show_log_window()}

@defun i_callback_options_show_log_window data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_show_log_window()>>=
DEFINE_I_CALLBACK(options_show_log_window)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  x_log_setup_win(w_current);
}


@ %def i_callback_options_show_log_window


@section Function @code{i_callback_misc()}

@defun i_callback_misc data callback_action widget
@end defun

<<i_callbacks.c : i_callback_misc()>>=
/* this is Ales' catch all misc callback */
DEFINE_I_CALLBACK(misc)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  s_tile_print(w_current);
}


@ %def i_callback_misc


@section Function @code{i_callback_misc2()}

@defun i_callback_misc2 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_misc2()>>=
/* this is Ales' second catch all misc callback */
DEFINE_I_CALLBACK(misc2)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;
  OBJECT *first = o_select_return_first_object(w_current);

  if (first) {
    /*o_cue_draw_single(w_current, first);*/
    o_cue_undraw(w_current, first);
    s_conn_print(first->conn_list);
  }
}


@ %def i_callback_misc2


@section Function @code{i_callback_misc3()}

@defun i_callback_misc3 data callback_action widget
@end defun

<<i_callbacks.c : i_callback_misc3()>>=
/* this is Ales' third catch all misc callback */
DEFINE_I_CALLBACK(misc3)
{

}


@ %def i_callback_misc3


@section Function @code{i_callback_cancel()}

@defun i_callback_cancel data callback_action widget
@end defun

<<i_callbacks.c : i_callback_cancel()>>=
/* HACK: be sure that you don't use the widget parameter in this one,
 * since it is being called with a null, I suppose we should call it
 * with the right param. */
DEFINE_I_CALLBACK(cancel)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);

  /* leave this on for now... but it might have to change */
  /* this is problematic since we don't know what the right mode */
  /* (when you cancel inside an action) should be */
  i_set_state(w_current, SELECT);
  i_update_toolbar(w_current);

  /* clear the key guile command-sequence */
  gh_eval_str("(set! current-command-sequence '())");

  /* see above comment hack */
#if 0
  set_cursor_normal();
#endif

  if (w_current->inside_action) { 
     o_redraw_all(w_current); 
  }

  /* it is possible to cancel in the middle of a complex place
   * so lets be sure to clean up the complex_place_head
   * structure and also clean up the attrib_place_head.
   * remember these don't remove the head structure */
  o_list_delete_rest(w_current,
                     w_current->page_current->complex_place_head);
  o_list_delete_rest(w_current,
                     w_current->page_current->attrib_place_head);

  /* also free internal current_attribute */
  o_attrib_free_current(w_current);

  w_current->inside_action=0;
}


@ %def i_callback_cancel


@section Function @code{i_callback_help_about()}

@defun i_callback_help_about data callback_action widget
@end defun

<<i_callbacks.c : i_callback_help_about()>>=
DEFINE_I_CALLBACK(help_about)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  about_dialog(w_current);
}


@ %def i_callback_help_about


@section Function @code{i_callback_help_manual()}

@defun i_callback_help_manual data callback_action widget
@end defun

<<i_callbacks.c : i_callback_help_manual()>>=
DEFINE_I_CALLBACK(help_manual)
{
  initiate_gschemdoc("-m", NULL, NULL, NULL, NULL);
}

@ %def i_callback_help_manual


@section Function @code{i_callback_help_hotkeys()}

@defun i_callback_help_hotkeys data callback_action widget
@end defun

<<i_callbacks.c : i_callback_help_hotkeys()>>=
DEFINE_I_CALLBACK(help_hotkeys)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  x_dialog_hotkeys(w_current);
}


@ %def i_callback_help_hotkeys


@section Function @code{i_callback_options_show_coord_window()}

@defun i_callback_options_show_coord_window data callback_action widget
@end defun

<<i_callbacks.c : i_callback_options_show_coord_window()>>=
DEFINE_I_CALLBACK(options_show_coord_window)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  coord_dialog (w_current, mouse_x, mouse_y);
}


@ %def i_callback_options_show_coord_window


@section Function @code{i_callback_preview()}

@defun i_callback_preview data callback_action widget
@end defun

<<i_callbacks.c : i_callback_preview()>>=
DEFINE_I_CALLBACK(preview)
{
  TOPLEVEL *w_current = (TOPLEVEL *) data;

  exit_if_null(w_current);
  setup_preview(w_current);
}


@ %def i_callback_preview


@section Function @code{i_callback_close_wm()}

@defun i_callback_close_wm widget event data
@end defun

<<i_callbacks.c : i_callback_close_wm()>>=
/* these is a special wrapper function which cannot use the above */
/* DEFINE_I_CALLBACK macro */

/* When invoked (via signal delete_event), closes the current window */
/* if this is the last window, quit gschem */
/* used when you click the close button on the window which sends a DELETE */
/* signal to the app */
void i_callback_close_wm ( GtkWidget *widget, GdkEvent *event, 
	                   gpointer data ) 
{

  TOPLEVEL *w_current = (TOPLEVEL *) data;
  exit_if_null(w_current);

  x_window_close(w_current);
}


@ %def i_callback_close_wm


