@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_circle.c,,,Top
@chapter File @file{o_circle.c}

@section File header

<<o_circle.c : *>>=
<<o_circle.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_circle.nw instead */

<<o_circle.c : include directives>>
<<o_circle.c : macros>>

<<o_circle.c : o_circle_draw()>>        /* done */
<<o_circle.c : o_circle_fill_hollow()>> /* done */
<<o_circle.c : o_circle_fill_fill()>>   /* done */
<<o_circle.c : o_circle_fill_hatch()>>  /* done */
<<o_circle.c : o_circle_fill_mesh()>>   /* done */
<<o_circle.c : o_circle_erase()>>
<<o_circle.c : o_circle_draw_xor()>>
<<o_circle.c : o_circle_start()>>
<<o_circle.c : o_circle_end()>>
<<o_circle.c : o_circle_rubbercircle()>>
<<o_circle.c : o_circle_draw_grips()>>
<<o_circle.c : o_circle_erase_grips()>>

@ 

<<o_circle.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 

<<o_circle.c : include directives>>=
#include <config.h>
#include <stdio.h>
#include <math.h>

#include <libgeda/libgeda.h>

#include "../include/prototype.h"

@ 

<<o_circle.c : macros>>=
/* Kazu on July 16, 1999 - Added these macros to simplify the code */
#define GET_BOX_WIDTH(w)			\
	abs((w)->last_x - (w)->start_x)
#define GET_BOX_HEIGHT(w)			\
	abs((w)->last_y - (w)->start_y)

@ %def GET_BOX_WIDTH GET_BOX_HEIGHT


@section Function @code{o_circle_draw()}

@defun o_circle_draw w_current o_current
This function is used to draw a circle on screen. The circle is described by 
the OBJECT which is referred by @code{o_current}. The display is done 
according to the current state, given by the TOPLEVEL object pointed by 
@code{w_current}.
@end defun

It first checks if the OBJECT pointed is valid or not. If not it returns and 
do not output anything. That should never happen though.

<<o_circle.c : o_circle_draw()>>=
void
o_circle_draw(TOPLEVEL *w_current, OBJECT *o_current)
{
  int wleft, wright, wtop, wbottom; /* world bounds */
  int radius;
  int circle_width, length, space;
  int fill_width, angle1, pitch1, angle2, pitch2;
  GdkCapStyle circle_end;
  GdkColor *color;
  void (*draw_func)() = NULL;
  void (*fill_func)();

  if (o_current->circle == NULL) {
    return;
  }
	
@ %def o_circle_draw

The function now recalculates the OBJECT as a circle. It involves calculating 
every single dimensions according to the zoom factor, the position, @dots{}.
It also recalculates the bounding box of the object and check whether this 
object is visible or not. If not there is no reason to draw it !

<<o_circle.c : o_circle_draw()>>=	
  o_circle_recalc(w_current, o_current);
	
	/* Get read to check for visibility of this line by using it's
	 * bounding box */
  world_get_circle_bounds(w_current, o_current->circle,
                          &wleft, &wtop, &wright, &wbottom);
	
  if (!visible(w_current, wleft, wtop, wright, wbottom)) {
    return;
  }
	
#if DEBUG
  printf("drawing circle\n\n");
#endif
	
@ 

The draw of the circle is divided in two steps : first step is to draw the outline, the second is to draw the filling pattern inside (if any).

Finally the function takes care of the grips.

<<o_circle.c : o_circle_draw()>>=
  if (w_current->override_color != -1 ) {
    color = x_get_color(w_current->override_color);
  } else {
    color = x_get_color(o_current->color);
  }

  radius = o_current->circle->screen_radius;

  <<o_circle_draw() : drawing outline>>
  <<o_circle_draw() : filling>>

  <<o_circle_draw() : grip specific stuff>>

}

@ 

The values describing the line type are extracted from the @code{o_current} pointed structure. These are the width of the line, the field called length and the field called space and the desired end type for the line.

Depending on the type of the line that has to be used to draw the circle the appropriate function is called. Values of space and length are adapted to the type of line. The possible functions are the following : @code{o_arc_draw_solid}, @code{o_arc_draw_dotted}, @code{o_arc_draw_dashed} and @code{o_arc_draw_phantom}. Therefore it reuses the code from arc primitive.

The combination @code{length} == 0 and @code{space} == 0 is avoided as it lead to an endless loop in function called after. If such a case is encountered the circle is drawn as a solid circle independently of its initial type.

<<o_circle_draw() : drawing outline>>=
  if(o_current->screen_line_width > 0) {
    circle_width = o_current->screen_line_width;
  } else {
    circle_width = 1;
  }

  length = o_current->screen_line_length;
  space = o_current->screen_line_space;

  switch(o_current->line_end) {
    case END_NONE:   circle_end = GDK_CAP_BUTT;       break;
    case END_SQUARE: circle_end = GDK_CAP_PROJECTING; break;
    case END_ROUND:  circle_end = GDK_CAP_ROUND;      break;
    default: fprintf(stderr, "Unknown end for circle\n");
      circle_end = GDK_CAP_BUTT;
      break;
  }

  switch(o_current->line_type) {
    case TYPE_SOLID:
    length = -1;
    space = -1;
    draw_func = (void *) o_arc_draw_solid;
    break;
			
    case TYPE_DOTTED:
    length = -1; /* ..._draw_dotted only space used */
    draw_func = (void *) o_arc_draw_dotted;
    break;
			
    case TYPE_DASHED:
    draw_func = (void *) o_arc_draw_dashed;
    break;
			
    case TYPE_CENTER:
    draw_func = (void *) o_arc_draw_center;
    break;
			
    case TYPE_PHANTOM:
    draw_func = (void *) o_arc_draw_phantom;
    break;
			
    case TYPE_ERASE:
    break;
			
    default:
    length = -1;
    space = -1;
    circle_width = 0; /* just to be careful */
    fprintf(stderr, "Unknown type for circle !\n");
    draw_func = (void *) o_arc_draw_solid;			
    break;
  }

  if((length == 0) || (space == 0))
  draw_func = (void *) o_arc_draw_solid;
	
  (*draw_func)(w_current->window, w_current->gc, color,
               circle_end,
               o_current->circle->screen_x,
               o_current->circle->screen_y,
               radius,
               0, FULL_CIRCLE / 64,
               circle_width, length, space);
  (*draw_func)(w_current->backingstore, w_current->gc, color,
               circle_end,
               o_current->circle->screen_x,
               o_current->circle->screen_y,
               radius,
               0, FULL_CIRCLE / 64,
               circle_width, length, space);

@ 

The values needed for the fill operation are taken from the @code{o_current} pointed OBJECT. It include the type of fill required, the width of the lines (if the fill use line) and angles and pitchs for hatch based filling.

Once again the width of the line is important as if it is equal to 0 it may not be displayed. That is definetely not what we are looking for.

Depending on the type of fill that has to be used inside the circle the right function is called. Values of @code{angle1}, @code{angle2}, @code{pitch1} and @code{pitch2} are adapted to the type of filling. The possible functions are the following : @code{o_circle_fill_hollow}, @code{o_circle_fill_fill}, @code{o_circle_fill_mesh} and @code{o_circle_fill_hatch}.

The combination @code{pitch1} <= 0 and @code{pitch2} <= 0 is avoided as it lead to an endless loop in function called after. It happens when the zoom factor is too small for two lines separated by the pitch to be distinct. If such a case is encountered the circle is filled hollow (e.q. not filled).

<<o_circle_draw() : filling>>=
  if(o_current->screen_fill_width > 0) {
    fill_width = o_current->screen_fill_width;
  } else {
    fill_width = 1;
  }
	
  angle1 = o_current->fill_angle1;
  pitch1 = o_current->screen_fill_pitch1;
  angle2 = o_current->fill_angle2;
  pitch2 = o_current->screen_fill_pitch2;
	
  switch(o_current->fill_type) {
    case FILLING_HOLLOW:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      /* this function is empty ! however if it do not use it we have to add a test
         before the call. Simply putting a return here instead is not possible as
         it would prevent any hollow circle from having its grips */
      fill_func = (void *) o_circle_fill_hollow;
      break;
		
    case FILLING_FILL:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      fill_func = (void *) o_circle_fill_fill;
      break;
			
    case FILLING_MESH:
      fill_func = (void *) o_circle_fill_mesh;
      break;

    case FILLING_HATCH:
      angle2 = -1;
      pitch2 = 1;
      fill_func = (void *) o_circle_fill_hatch;
      break;
			
    case FILLING_VOID:
    default:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      fill_func = (void *) o_circle_fill_hollow;			
      fprintf(stderr, "Unknown type for circle (fill) !\n");
  }

  if((pitch1 <= 0) || (pitch2 <= 0)) {
    fill_func = (void *) o_circle_fill_fill;
  }

  (*fill_func)(w_current->window, w_current->gc, color,
               o_current->circle->screen_x,
               o_current->circle->screen_y,
               radius,
               fill_width, angle1, pitch1, angle2, pitch2);
  (*fill_func)(w_current->backingstore, w_current->gc, color,
               o_current->circle->screen_x,
               o_current->circle->screen_y,
               radius,
               fill_width, angle1, pitch1, angle2, pitch2);

#if DEBUG
  printf("drawing circle\n");
#endif

@ 

<<o_circle_draw() : grip specific stuff>>=
  if (o_current->draw_grips && w_current->draw_grips == TRUE) {	
		
    if (!o_current->selected) {
      /* erase the grips */
      o_current->draw_grips = FALSE;
      gdk_gc_set_foreground(w_current->gc, 
                            x_get_color(w_current->background_color));
    } else {
      gdk_gc_set_foreground(w_current->gc, color);
    }
    gdk_gc_set_line_attributes(w_current->gc, 0, GDK_LINE_SOLID,
                               circle_end, GDK_JOIN_MITER);


    o_circle_draw_grips(w_current, w_current->window, o_current);
    o_circle_draw_grips(w_current, w_current->backingstore, o_current);
  }

@ 



@section Function @code{o_circle_fill_hollow()}

@defun o_circle_fill_hollow w gc color x y radius width angle1 pitch1 angle2 pitch2
This function does nothing. It has the same prototype as all the filling functions. It prevent from making a difference between filling in function @code{o_circle_draw()}.
@end defun

The unit for @code{width}, @code{pitch1} and @code{pitch2} is pixel and unit for @code{angle1} and @code{angle2} is degree.

<<o_circle.c : o_circle_fill_hollow()>>=
void
o_circle_fill_hollow(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                     gint x, gint y, gint radius,
                     gint width,
                     gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  
}

@ %def o_circle_fill_hollow


@section Function @code{o_circle_fill_fill()}

@defun o_circle_fill_fill w gc color x y radius width angle1 pitch1 angle2 pitch2
This function fills the inside of the circle with a solid pattern. Parameters @code{angle1}, @code{pitch1} and @code{angle2}, @code{pitch2} and @code{width} are unused here but kept for compatibility with other circle filling functions.
@end defun

The circle is described by the coordinates of its center and its radius. Please not that it is not the way GDK take it. Translation is made afterward.

The unit for @code{width}, @code{pitch1} and @code{pitch2} is pixel and unit for @code{angle1} and @code{angle2} is degree.

The solid fill is done with the @code{gdk_draw_arc()} function and its parameters @code{filled} set. The circle is filled with the color @code{color} given as a parameter to the function.

<<o_circle.c : o_circle_fill_fill()>>=
void
o_circle_fill_fill(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                   gint x, gint y, gint radius,
                   gint width,
                   gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  gdk_gc_set_foreground(gc, color);
  gdk_gc_set_line_attributes(gc, 1, GDK_LINE_SOLID,
                             GDK_CAP_BUTT, GDK_JOIN_MITER);

  gdk_draw_arc(w, gc,
               TRUE, x-radius, y-radius, 2*radius, 2*radius, 0, FULL_CIRCLE);

}

@ %def o_circle_fill_fill


@section Function @code{o_circle_fill_hatch()}

@defun o_circle_fill_hatch w gc color x y radius width angle1 pitch1 angle2 pitch2
This function fills the inside of the circle with a pattern made of lines. The lines are drawn inside the circle with an angle @code{angle1} from the horizontal. The distance between two of these lines is given by @code{pitch1} and their width by @code{width}.
Parameters @code{angle2}, @code{pitch2} are unused here but kept for compatibility with other circle filling functions.
@end defun

The circle is described by the coordinates of its center and its radius. Please not that it is not the way GDK take it. Translation is made afterward. 

The unit for @code{width}, @code{pitch1} and @code{pitch2} is pixel and unit for @code{angle1} and @code{angle2} is degree.

The only attribute of line here is its width from the parameter @code{width}.

Negative or null values for @code{pitch1} are not allowed as it leads to an endless loop.

<<o_circle.c : o_circle_fill_hatch()>>=
void
o_circle_fill_hatch(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                    gint x, gint y, gint radius,
                    gint width,
                    gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  double x0, y0, x1, y1, x2, y2;
  double cos_a_, sin_a_;

  gdk_gc_set_line_attributes(gc, width, GDK_LINE_SOLID,
                             GDK_CAP_BUTT, GDK_JOIN_MITER);

@ %def o_circle_fill_hatch

  The function use a matrix. Its elements are obtained from the sinus and cosinus of the angle @code{angle1}. It represent the rotation matrix that when applied to a point, rotate it of @code{angle1}.

<<o_circle.c : o_circle_fill_hatch()>>=	
  cos_a_ = cos(((double) angle1) * M_PI/180);
  sin_a_ = sin(((double) angle1) * M_PI/180);

  <<o_circle_fill_hatch() : calculating and drawing the lines>>
	
}
@ 

When drawing a line in a circle there is two intersections. It looks for the coordinates of one of these points when the line is horizontal. The second one can be easily obtained by symmetry in relation to the vertical axis going through the centre of the circle.

These two points are then rotated of angle @code{angle1} using the elements of the rotation matrix previously computed.

The corresponding line can be drawn providing that the coordinates are rounded.

These operations are repeated for every horizontal line that can fit in the upper half of the circle (using and incrementing the variable @var{y0}).

<<o_circle_fill_hatch() : calculating and drawing the lines>>=
  y0 = 0;
  while(y0 < (double) radius) {
    x0 = pow((double) radius, 2) - pow(y0, 2);
    x0 = sqrt(x0);

    x1 = (x0*cos_a_ - y0*sin_a_) + x;
    y1 = y - (x0*sin_a_ + y0*cos_a_);
    x2 = ((-x0)*cos_a_ - y0*sin_a_) + x;
    y2 = y - ((-x0)*sin_a_ + y0*cos_a_);
		
    gdk_draw_line(w, gc,
                  (int) x1, (int) y1, (int) x2, (int) y2);
        
@ 

The function use the symetry in relation to the centre of the circle. It avoid repetitive computation for the second half of the surface of the circle.

<<o_circle_fill_hatch() : calculating and drawing the lines>>=
	x1 = (x0*cos_a_ - (-y0)*sin_a_) + x;
	y1 = y- (x0*sin_a_ + (-y0)*cos_a_);
	x2 = ((-x0)*cos_a_ - (-y0)*sin_a_) + x;
	y2 = y- ((-x0)*sin_a_ + (-y0)*cos_a_);
		
	gdk_draw_line(w, gc, (int) x1, (int) y1, (int) x2, (int) y2);
		
	y0 = y0 + pitch1;
	}
@


@section Function @code{o_circle_fill_mesh()}

@defun o_circle_fill_mesh w gc color x y radius width angle1 pitch1 angle2 pitch2
This function fills the inside of the circle with a pattern made of set of parallel lines in two directions. The first set is drawn inside the circle with an angle @code{angle1} from the horizontal. The distance between two of these lines is given by @code{pitch1}.
The second set is drawn inside the circle with an angle @code{angle2} from the horizontal. The distance between two of these lines is given by @code{pitch2}.
Every lines have the same width given by @code{width}.
@end defun

The unit for @code{width}, @code{pitch1} and @code{pitch2} is pixel and unit for @code{angle1} and @code{angle2} is degree.

This function simply makes two successive calls to the function @code{o_circle_fill_hatch()} respectively with @code{angle1}, @code{pitch1} and @code{angle2}, @code{pitch2} for parameters.

<<o_circle.c : o_circle_fill_mesh()>>=
void
o_circle_fill_mesh(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                   gint x, gint y, gint radius,
                   gint width,
                   gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  o_circle_fill_hatch(w, gc, color,
                      x, y, radius,
                      width, angle1, pitch1, -1, -1);
  o_circle_fill_hatch(w, gc, color,
                      x, y, radius,
                      width, angle2, pitch2, -1, -1);
	
}

@ %def o_circle_fill_mesh


@section Function @code{o_circle_erase()}

@defun o_circle_erase w_current o_current
@end defun

<<o_circle.c : o_circle_erase()>>=
void
o_circle_erase(TOPLEVEL *w_current, OBJECT *o_current)
{
	w_current->override_color = w_current->background_color;
	o_circle_draw(w_current, o_current);
	w_current->override_color = -1;
}

@ %def o_circle_erase


@section Function @code{o_circle_draw_xor()}

@defun o_circle_draw_xor w_current dx dy o_current
@end defun

<<o_circle.c : o_circle_draw_xor()>>=
/* add in offsets, get rid of global diffs_x,y */
void
o_circle_draw_xor(TOPLEVEL *w_current, int dx, int dy, OBJECT *o_current)
{
  int temp;
  int color;

  if (o_current->circle == NULL) {
    return;
  }

  temp = SCREENabs(w_current,o_current->circle->radius) * 2;

  if (o_current->saved_color != -1) {
    color = o_current->saved_color;
  } else {
    color = o_current->color;
  }

  /* To draw be sure to setup width height */
  gdk_gc_set_foreground(w_current->outline_xor_gc,
                        x_get_darkcolor(color));
  gdk_draw_arc(w_current->window, w_current->outline_xor_gc,
               FALSE,
               o_current->circle->screen_left + dx,
               o_current->circle->screen_top  + dy,
               temp, temp, 0, FULL_CIRCLE);

  /* backing store ?  not appropriate here */
}

@ %def o_circle_draw_xor


@section Function @code{o_circle_start()}

@defun o_circle_start w_current x y
@end defun

<<o_circle.c : o_circle_start()>>=
void
o_circle_start(TOPLEVEL *w_current, int x, int y)
{
  w_current->last_x = w_current->start_x = fix_x(w_current, x);
  w_current->last_y = w_current->start_y = fix_y(w_current, y);

  gdk_gc_set_foreground(w_current->xor_gc,
                        x_get_color(w_current->select_color));
  gdk_gc_set_line_attributes(w_current->xor_gc, 0,
                             GDK_LINE_SOLID, GDK_CAP_NOT_LAST, 
                             GDK_JOIN_MITER);
  gdk_draw_line(w_current->window, w_current->xor_gc,
                w_current->start_x,
                w_current->start_y,
                w_current->last_x ,
                w_current->last_y );

#if 0
  gdk_draw_arc(w_current->window, w_current->xor_gc, FALSE,
               w_current->start_x,
               w_current->start_y,
               1, 1, 0, FULL_CIRCLE);
#endif

  w_current->distance = 0;
}

@ %def o_circle_start


@section Function @code{o_circle_end()}

@defun o_circle_end w_current x y
@end defun

<<o_circle.c : o_circle_end()>>=
void
o_circle_end(TOPLEVEL *w_current, int x, int y)
{
  int center_x, center_y;
  int radius;

  if (w_current->inside_action == 0) {
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }

  gdk_gc_set_foreground(w_current->xor_gc,
                        x_get_color(w_current->select_color));
  gdk_draw_line(w_current->window, w_current->xor_gc,
                w_current->start_x,
                w_current->start_y,
                w_current->last_x ,
                w_current->last_y );

  gdk_gc_set_foreground(w_current->gc,
                        x_get_color(w_current->select_color));

  gdk_draw_arc(w_current->window, w_current->xor_gc, FALSE,
               w_current->start_x - w_current->distance,
               w_current->start_y - w_current->distance,
               w_current->distance * 2,
               w_current->distance * 2,
               0, FULL_CIRCLE);

  w_current->distance = dist(w_current->start_x,
                             w_current->start_y,
                             w_current->last_x,
                             w_current->last_y);

  gdk_gc_set_foreground(w_current->gc,
                        x_get_color(w_current->graphic_color));

  gdk_draw_arc(w_current->window, w_current->gc, FALSE,
               w_current->start_x - w_current->distance,
               w_current->start_y - w_current->distance,
               w_current->distance * 2,
               w_current->distance * 2,
               0, FULL_CIRCLE);

  gdk_draw_arc(w_current->backingstore, w_current->gc, FALSE,
               w_current->start_x - w_current->distance,
               w_current->start_y - w_current->distance,
               w_current->distance * 2,
               w_current->distance * 2,
               0, FULL_CIRCLE);

#if 0
  sqrt(pow(w_current->start_x - w_current->last_x, 2) +
       pow(w_current->start_y - w_current->last_y, 2));
#endif

  /* ack! zero length radius */
  if (w_current->distance == 0) {
    return;
  }

#if 0
  w_current->loc_x = w_current->start_x - w_current->distance;
  w_current->loc_y = w_current->start_y - w_current->distance;
#endif

  SCREENtoWORLD(w_current,
                w_current->start_x,
                w_current->start_y,
                &center_x,
                &center_y);

  radius = snap_grid(w_current,
                     WORLDabs(w_current, w_current->distance));

  w_current->page_current->object_tail =
  o_circle_add(w_current,
               w_current->page_current->object_tail,
               OBJ_CIRCLE, w_current->graphic_color,
               center_x, center_y, radius);

  w_current->start_x = (-1);
  w_current->start_y = (-1);
  w_current->last_x  = (-1);
  w_current->last_y  = (-1);
  w_current->loc_x   = (-1);
  w_current->loc_y   = (-1);
  w_current->distance = (-1);
  w_current->page_current->CHANGED = 1;
  o_undo_savestate(w_current, UNDO_ALL);
}

@ %def o_circle_end


@section Function @code{o_circle_rubbercircle()}

@defun o_circle_rubbercircle w_current x y
@end defun

<<o_circle.c : o_circle_rubbercircle()>>=
void
o_circle_rubbercircle(TOPLEVEL *w_current, int x, int y)
{
  int diff_x, diff_y;

  if (w_current->inside_action == 0) {
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }

  /* erase the old one */
  gdk_gc_set_foreground(w_current->xor_gc,
                        x_get_color(w_current->select_color));
  gdk_draw_line(w_current->window, w_current->xor_gc,
                w_current->start_x,
                w_current->start_y,
                w_current->last_x ,
                w_current->last_y );

  w_current->last_x = fix_x(w_current, x);
  w_current->last_y = fix_y(w_current, y);

  diff_x = GET_BOX_WIDTH (w_current);
  diff_y = GET_BOX_HEIGHT(w_current);

  if (diff_x >= diff_y) {
    w_current->last_y = w_current->start_y;
  } else {
    w_current->last_x = w_current->start_x;
  }

  gdk_draw_arc(w_current->window, w_current->xor_gc, FALSE,
               w_current->start_x - w_current->distance,
               w_current->start_y - w_current->distance,
               w_current->distance * 2,
               w_current->distance * 2,
               0, FULL_CIRCLE);

  w_current->distance = dist(w_current->start_x,
                             w_current->start_y,
                             w_current->last_x,
                             w_current->last_y);

  /* draw a new one */
  gdk_gc_set_foreground(w_current->xor_gc,
                        x_get_color(w_current->select_color));
  gdk_draw_line(w_current->window, w_current->xor_gc,
                w_current->start_x,
                w_current->start_y,
                w_current->last_x,
                w_current->last_y);
  gdk_draw_arc(w_current->window, w_current->xor_gc, FALSE,
               w_current->start_x - w_current->distance,
               w_current->start_y - w_current->distance,
               w_current->distance * 2,
               w_current->distance * 2,
               0, FULL_CIRCLE);
}

@ %def o_circle_rubbercircle


@section Function @code{o_circle_draw_grips()}

@defun o_circle_draw_grips w_current w o_current
@end defun

<<o_circle.c : o_circle_draw_grips()>>=
void
o_circle_draw_grips(TOPLEVEL *w_current, GdkWindow *w, OBJECT *o_current) 
{
  int size, x2size;
  int x, y;
  int factor;

  if (w_current->draw_grips == FALSE) 
  return;

  factor = (int) w_current->page_current->to_world_x_constant;
  if (factor > SMALL_ZOOMFACTOR1) {
    size = SCREENabs(w_current, GRIP_SIZE1); 
  } else if (factor > SMALL_ZOOMFACTOR2) {
    size = SCREENabs(w_current, GRIP_SIZE2); 
  } else {
    size = SCREENabs(w_current, GRIP_SIZE3); 
  }
  x2size = size * 2;

  x = o_current->circle->screen_x + o_current->circle->screen_radius;
  y = o_current->circle->screen_y + o_current->circle->screen_radius;

  gdk_draw_rectangle(w, w_current->gc, FALSE,
                     x - size, y - size, x2size, x2size);
}

@ %def o_circle_draw_grips


@section Function @code{o_circle_erase_grips}

@defun o_circle_erase_grips w_current o_current
@end defun

<<o_circle.c : o_circle_erase_grips()>>=
void
o_circle_erase_grips(TOPLEVEL *w_current, OBJECT *o_current) 
{
  int size, x2size;
  int x, y;
  int factor;

  if (w_current->draw_grips == FALSE) 
  return;

  gdk_gc_set_foreground(w_current->gc, 
                        x_get_color(w_current->background_color));

  factor = (int) w_current->page_current->to_world_x_constant;
  if (factor > SMALL_ZOOMFACTOR1) {
    size = SCREENabs(w_current, GRIP_SIZE1); 
  } else if (factor > SMALL_ZOOMFACTOR2) {
    size = SCREENabs(w_current, GRIP_SIZE2); 
  } else {
    size = SCREENabs(w_current, GRIP_SIZE3); 
  }
  x2size = 2 * size;

  x = o_current->circle->screen_x + o_current->circle->screen_radius;
  y = o_current->circle->screen_y + o_current->circle->screen_radius;

  gdk_draw_rectangle(w_current->window, w_current->gc, FALSE,
                     x - size, y - size, x2size, x2size);

  gdk_draw_rectangle(w_current->backingstore, w_current->gc, FALSE,
                     x - size, y - size, x2size, x2size);
}
@ %def o_circle_erase_grips
