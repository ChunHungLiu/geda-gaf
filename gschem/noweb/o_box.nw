@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File o_box.c,,,Top
@chapter File @file{o_box.c}

@section File header

<<o_box.c : *>>=
<<o_box.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/o_box.nw instead */

<<o_box.c : include directives>>
<<o_box.c : macros>>

<<o_box.c : o_box_draw()>>
<<o_box.c : o_box_draw_solid()>>
<<o_box.c : o_box_draw_dotted()>>
<<o_box.c : o_box_draw_dashed()>>
<<o_box.c : o_box_draw_center()>>
<<o_box.c : o_box_draw_phantom()>>
<<o_box.c : o_box_fill_hollow()>>
<<o_box.c : o_box_fill_fill()>>
<<o_box.c : o_box_fill_hatch()>>
<<o_box.c : o_box_fill_mesh()>>

<<o_box.c : o_box_erase()>>

<<o_box.c : o_box_draw_xor()>>

<<o_box.c : o_box_start()>>
<<o_box.c : o_box_end()>>

<<o_box.c : o_box_rubberbox()>>
<<o_box.c : o_box_rubberbox_xor()>>

<<o_box.c : o_box_draw_grips()>>
<<o_box.c : o_box_erase_grips()>>

@ 

<<o_box.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 

<<o_box.c : include directives>>=
#include <config.h>
#include <math.h>
#include <stdio.h>

#include <libgeda/libgeda.h>

#include "../include/prototype.h"

@ 

<<o_box.c : macros>>=
/* Kazu on July 16, 1999 - Added these macros to simplify the code */
#define GET_BOX_WIDTH(w)			\
	abs((w)->last_x - (w)->start_x)
#define GET_BOX_HEIGHT(w)			\
	abs((w)->last_y - (w)->start_y)
#define GET_BOX_LEFT(w)				\
	min((w)->start_x, (w)->last_x);
#define GET_BOX_TOP(w)				\
	min((w)->start_y, (w)->last_y);

@ %def GET_BOX_WIDTH GET_BOX_HEIGHT GET_BOX_LEFT GET_BOX_TOP


@section Function [[o_box_draw()]]

@defun o_box_draw w_current o_current
This function is used to draw a box on screen. The box is described in the 
OBJECT which is referred by [[o_current]]. The box is displayed according 
to the current state, described in the TOPLEVEL object pointed by 
[[w_current]].
@end defun

It first checks if the OBJECT pointed is valid or not. If not it returns and 
do not output anything. That should never happen though.

<<o_box.c : o_box_draw()>>=
void
o_box_draw(TOPLEVEL *w_current, OBJECT *o_current)
{
  int wleft, wright, wtop, wbottom; /* world bounds */
  int line_width, length, space;
  int fill_width, angle1, pitch1, angle2, pitch2;
  GdkCapStyle box_end;
  GdkColor *color;
  void (*draw_func)() = NULL;
  void (*fill_func)();

  if (o_current->box == NULL) {
    return;
  }

@ %def o_box_draw

The function now recalculates the OBJECT as a box. It involves calculating 
every single dimensions according to the zoom factor the position, @dots{}.
It also recalculates the bounding box of the object and check whether this 
object is visible or not. If not there is no reason to draw it !

<<o_box.c : o_box_draw()>>=	
  o_box_recalc(w_current, o_current);

	/* Get read to check for visibility of this line by using it's
	 * bounding box */
  world_get_box_bounds(w_current, o_current->box,
                       &wleft, &wtop, &wright, &wbottom);
	
  if (!visible(w_current, wleft, wtop, wright, wbottom)) {
    return;
  }
	
#if DEBUG
  printf("drawing box\n\n");
	
  printf("drawing box: %d %d %d %d\n",
         o_current->box->screen_upper_x,
         o_current->box->screen_upper_y,
         o_current->box->screen_upper_x +
         abs(o_current->box->screen_lower_x -
             o_current->box->screen_upper_x),
         o_current->box->screen_upper_y +
         abs(o_current->box->screen_lower_y -
             o_current->box->screen_upper_y));
#endif

@ 

The drawing of the box is divided in two steps : first step is to draw the outline, the second is to draw the filling pattern inside (if any).

Finally the function takes care of the grips.

<<o_box.c : o_box_draw()>>=	
  if (w_current->override_color != -1 ) {  /* Override */
    color = x_get_color(w_current->override_color);
  } else {
    color = x_get_color(o_current->color);
  }

  <<o_box_draw() : drawing outline>>
  <<o_box_draw() : filling>>

  <<o_box_draw() : grip specific stuff>>

}
@ 

The values describing the line type are extracted from the [[o_current]] pointed structure. These are the width of the line, the field called length and the field called space and the desired end type for the line.

Depending on the type of the line that has to be used to draw the box the appropriate function is called. Values of space and length are adapted to the type of line. The possible functions are the following : [[o_box_draw_solid]], [[o_box_draw_dotted]], [[o_box_draw_dashed]] and [[o_box_draw_phantom]].

The combination [[length]] == 0 and [[space]] == 0 is avoided as it lead to an endless loop in function called after. If such a case is encountered the box is drawn as a solid box independently of its initial type.

<<o_box_draw() : drawing outline>>=

  if(o_current->screen_line_width > 0) {
    line_width = o_current->screen_line_width;
  } else {
    line_width = 1;
  }

  switch(o_current->line_end) {
    case END_NONE:   box_end = GDK_CAP_BUTT;       break;
    case END_SQUARE: box_end = GDK_CAP_PROJECTING; break;
    case END_ROUND:  box_end = GDK_CAP_ROUND;      break;
    default: fprintf(stderr, "Unknown end for box (%d)\n", o_current->line_end);
    box_end = GDK_CAP_BUTT;
    break;
  }
	
  length = o_current->screen_line_length;
  space = o_current->screen_line_space;
	
  switch(o_current->line_type) {
    case TYPE_SOLID:
      length = -1;
      space = -1;
      draw_func = (void *) o_box_draw_solid;
      break;

    case TYPE_DOTTED:
      length = -1; /* ..._draw_dotted only space is used */
      draw_func = (void *) o_box_draw_dotted;
      break;

    case TYPE_DASHED:
      draw_func = (void *) o_box_draw_dashed;
      break;

    case TYPE_CENTER:
      draw_func = (void *) o_box_draw_center;
      break;

    case TYPE_PHANTOM:
      draw_func = (void *) o_box_draw_phantom;
      break;

    case TYPE_ERASE:
      break;
			
    default:
      length = -1;
      space = -1;
      line_width = 0; /* just to be careful */
      draw_func = (void *) o_box_draw_solid;
      fprintf(stderr, "Unknown type for box !\n");
      break;
  }

  if((length == 0) || (space == 0))
  draw_func = (void *) o_box_draw_solid;
	
  (*draw_func)(w_current->window, w_current->gc, color, box_end,
               FALSE,
               o_current->box->screen_upper_x,
               o_current->box->screen_upper_y,
               abs(o_current->box->screen_lower_x -
                   o_current->box->screen_upper_x),
               abs(o_current->box->screen_lower_y -
                   o_current->box->screen_upper_y),
               line_width, length, space);
  (*draw_func)(w_current->backingstore, w_current->gc, color, box_end,
               FALSE,
               o_current->box->screen_upper_x,
               o_current->box->screen_upper_y,
               abs(o_current->box->screen_lower_x -
                   o_current->box->screen_upper_x),
               abs(o_current->box->screen_lower_y -
                   o_current->box->screen_upper_y),
               line_width, length, space);

@ 

The values needed for the fill operation are taken from the [[o_current]] pointed OBJECT. It include the type of fill required, the width of the lines (if the fill use line) and angles and pitchs for hatch based filling.

Once again the width of the line is important as if it is equal to 0 it may not be displayed. That is definetely not what we are looking for.

Depending on the type of fill that has to be used inside the box the appropriate function is called. Values of [[angle1]], [[angle2]], [[pitch1]] and [[pitch2]] are adapted to the type of filling. The possible functions are the following : [[o_box_fill_hollow]], [[o_box_fill_fill]], [[o_box_fill_mesh]] and [[o_box_fill_hatch]].

The combination [[pitch1]] <= 0 and [[pitch2]] <= 0 is avoided as it lead to an endless loop in function called after. It happens when the zoom factor is too small for two lines separated by the pitch to be distinct. If such a case is encountered the circle is filled hollow (e.q. not filled).

<<o_box_draw() : filling>>=
  if(o_current->screen_fill_width > 0) {
    fill_width = o_current->screen_fill_width;
  } else {
    fill_width = 1;
  }
	
  angle1 = o_current->fill_angle1;
  pitch1 = o_current->screen_fill_pitch1;
  angle2 = o_current->fill_angle2;
  pitch2 = o_current->screen_fill_pitch2;
	
  switch(o_current->fill_type) {
    case FILLING_HOLLOW:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      /* this function is empty ! however if it do not use it we have to add a test
         before the call. Simply putting a return here instead is not possible as
         it would prevent any hollow box from having its grips drawn */
      fill_func = (void *) o_box_fill_hollow;
      break;
		
    case FILLING_FILL:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      fill_func = (void *) o_box_fill_fill;
      break;
			
    case FILLING_MESH:
      fill_func = (void *) o_box_fill_mesh;
      break;

    case FILLING_HATCH:
      angle2 = -1;
      pitch2 = 1;
      fill_func = (void *) o_box_fill_hatch;
      break;
			
    case FILLING_VOID:
    default:
      angle1 = -1; angle2 = -1;
      pitch1 = 1; pitch2 = 1;
      fill_func = (void *) o_box_fill_hollow;
      fprintf(stderr, "Unknown type for box (fill) !\n");
  }

  if((pitch1 <= 0) || (pitch2 <= 0)) {
    fill_func = (void *) o_box_fill_fill;
  }

  (*fill_func)(w_current->window, w_current->gc, color,
               o_current->box->screen_upper_x,
               o_current->box->screen_upper_y,
               abs(o_current->box->screen_lower_x -
                   o_current->box->screen_upper_x),
               abs(o_current->box->screen_lower_y -
                   o_current->box->screen_upper_y),
               fill_width, angle1, pitch1, angle2, pitch2);
  (*fill_func)(w_current->backingstore, w_current->gc, color,
               o_current->box->screen_upper_x,
               o_current->box->screen_upper_y,
               abs(o_current->box->screen_lower_x -
                   o_current->box->screen_upper_x),
               abs(o_current->box->screen_lower_y -
                   o_current->box->screen_upper_y),
               fill_width, angle1, pitch1, angle2, pitch2);

@ 

<<o_box_draw() : grip specific stuff>>=
if ((o_current->draw_grips == TRUE) && (w_current->draw_grips == TRUE)) {	
	
	/* pb20011003 - modified to use the new o_box_[draw|erase]_grips() */
    if (!o_current->selected) {
		/* object is no more selected, erase the grips */
		o_current->draw_grips = FALSE;
		o_box_erase_grips(w_current, o_current);
	} else {
		/* object is selected, draw the grips on the box */
		o_box_draw_grips(w_current, o_current);
	}
	
}

@


@section Function [[o_box_draw_solid]]

@defun o_box_draw_solid w gc color cap filled x y width height line_width length space
This function draws a box with a solid line type. The length and space parameters are not used by this function.
@end defun

The function uses the functions previously defined in @file{o_line.c}. It is called four times for each of the side of the box. Therefore note that the cap parameter is significant here even if it is a box (i.e. a closed shape).

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

The unit of [[x]], [[y]], [[width]], [[height]], [[line_width]], [[length]] and [[space]] is pixel.

<<o_box.c : o_box_draw_solid()>>=
void
o_box_draw_solid(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                 GdkCapStyle cap, gint filled, gint x, gint y, gint width,
                 gint height, gint line_width, gint length, gint space)
{
  o_line_draw_solid(w, gc, color, cap,
                    x, y, x + width, y, line_width, length, space);
  o_line_draw_solid(w, gc, color, cap,
                    x + width, y, x + width, y + height, line_width, 
                    length, space);
  o_line_draw_solid(w, gc, color, cap,
                    x + width, y + height, x, y + height, line_width, 
                    length, space);
  o_line_draw_solid(w, gc, color, cap,
                    x, y + height, x, y, line_width, length, space);
}

@ %def o_box_draw_solid


@section Function [[o_box_draw_dotted]]

@defun o_box_draw_dotted w gc color cap filled x y width height line_width length space
This function draws a box with a dotted line type. The parameter [[space]] represents the distance between two of the dots. The parameter [[length]] is unused. The diameter of the dots is given by the width of the line given by [[width]].
@end defun

The function uses the functions previously defined in @file{o_line.c}. It is called four times for each of the side of the box.

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

The unit of [[x]], [[y]], [[width]], [[height]], [[line_width]], [[length]] and [[space]] is pixel.

A negative or null value for [[space]] leads to an endless loop in [[o_line_draw_dotted]].

<<o_box.c : o_box_draw_dotted()>>=
/* length parameter is unused */
void
o_box_draw_dotted(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                  GdkCapStyle cap, gint filled, gint x, gint y, gint width,
                  gint height, gint line_width, gint length, gint space)
{
  o_line_draw_dotted(w, gc, color, cap,
                     x, y, x + width, y, line_width, length, space);
  o_line_draw_dotted(w, gc, color, cap,
                     x + width, y, x + width, y + height, 
                     line_width, length, space);
  o_line_draw_dotted(w, gc, color, cap,
                     x + width, y + height, x, y+height, 
                     line_width, length, space);
  o_line_draw_dotted(w, gc, color, cap,
                     x, y + height, x, y, line_width, length, space);
	
}

@ %def o_box_draw_dotted


@section Function [[o_box_draw_dashed]]

@defun o_box_draw_dashed w gc color cap filled x y width height line_width length space
This function draws a box with a dashed line type. The parameter [[space]] represents the distance between two of the dash. The parameter [[length]] represents the length of a dash.
@end defun

The function uses the functions previously defined in @file{o_line.c}. It is called four times for each of the side of the box.

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

The unit of [[x]], [[y]], [[width]], [[height]], [[line_width]], [[length]] and [[space]] is pixel.

A negative or null value for length or space leads to an endless loop in [[o_line_draw_dashed]].

<<o_box.c : o_box_draw_dashed()>>=
void
o_box_draw_dashed(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                  GdkCapStyle cap, gint filled, gint x, gint y, gint width,
                  gint height, gint line_width, gint length, gint space)
{
  o_line_draw_dashed(w, gc, color, cap,
                     x, y, x + width, y, line_width, length, space);
  o_line_draw_dashed(w, gc, color, cap,
                     x + width, y, x + width, y + height, 
                     line_width, length, space);
  o_line_draw_dashed(w, gc, color, cap,
                     x + width, y + height, x, y+height, 
                     line_width, length, space);
  o_line_draw_dashed(w, gc, color, cap,
                     x, y + height, x, y, line_width, length, space);
}

@ %def o_box_draw_dashed


@section Function [[o_box_draw_center]]

@defun o_box_draw_center w gc color cap filled x y width height line_width length space
This function draws a box with a centered line type. The parameter [[space]] represents the distance between a dot and the dash. The parameter [[length]] represents the length of a dash.
@end defun

The function uses the functions previously defined in @file{o_line.c}. It is called four times for each of the side of the box.

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

The unit of [[x]], [[y]], [[width]], [[height]], [[line_width]], [[length]] and [[space]] is pixel.

A negative or null value for length or space leads to an endless loop in [[o_line_draw_center]].

<<o_box.c : o_box_draw_center()>>=
void
o_box_draw_center(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                  GdkCapStyle cap, gint filled, gint x, gint y, gint width,
                  gint height, gint line_width, gint length, gint space)
{
  o_line_draw_center(w, gc, color, cap,
                     x, y, x + width, y, line_width, length, space);
  o_line_draw_center(w, gc, color, cap,
                     x + width, y, x + width, y + height, 
                     line_width, length, space);
  o_line_draw_center(w, gc, color, cap,
                     x + width, y + height, x, y+height, 
                     line_width, length, space);
  o_line_draw_center(w, gc, color, cap,
                     x, y + height, x, y, line_width, length, space);
}

@ %def o_box_draw_center


@section Function [[o_box_draw_phantom]]

@defun o_box_draw_phantom w gc color cap filled x y width height line_width lentgh space
This function draws a box with a phantom line type. The parameter [[space]] represents the distance between a dot and a dash. The parameter [[length]] represents the length of a dash.
@end defun

The function uses the functions previously defined in @file{o_line.c}. It is called four times for each of the side of the box.

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

The unit of [[x]], [[y]], [[width]], [[height]], [[line_width]], [[length]] and [[space]] is pixel.

A negative or null value for length or space leads to an endless loop in [[o_line_draw_phantom]].

<<o_box.c : o_box_draw_phantom()>>=
void
o_box_draw_phantom(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                   GdkCapStyle cap, gint filled, gint x, gint y,
                   gint width, gint height, gint line_width,
                   gint length, gint space)
{
  o_line_draw_phantom(w, gc, color, cap,
                      x, y, x + width, y, line_width, length, space);
  o_line_draw_phantom(w, gc, color, cap,
                      x + width, y, x + width, y+height, 
                      line_width, length, space);
  o_line_draw_phantom(w, gc, color, cap,
                      x + width, y + height, x, y+height, 
                      line_width, length, space);
  o_line_draw_phantom(w, gc, color, cap,
                      x, y + height, x, y, line_width, length, space);
}

@ %def o_box_draw_phantom


@section Function [[o_box_fill_hollow]]

@defun o_box_fill_hollow w gc color x y width height fill_width angle1 pitch1 angle2 pitch2
This function does nothing. It has the same prototype as all the filling functions. It prevent from making a difference between filling in function [[o_box_draw]].
@end defun

<<o_box.c : o_box_fill_hollow()>>=
void
o_box_fill_hollow(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                  gint x, gint y,
                  gint width, gint height,
                  gint fill_width,
                  gint angle1, gint pitch1,
                  gint angle2, gint pitch2)
{
  
}

@ %def o_box_fill_hollow


@section Function [[o_box_fill_fill]]

@defun o_box_fill_fill w gc color x y width height fill_width angle1 pitch1 angle2 pitch2
This function fills the inside of the box with a solid pattern. Parameters [[angle1]], [[pitch1]] and [[angle2]], [[pitch2]] and [[width]] are unused here but kept for compatibility with other box filling functions.
@end defun

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

All parameters are given in pixel.

The solid fill is done with the [[gdk_draw_rectangle]] function and its parameters [[filled]] set. The box is filled with the color [[color]] given as a parameter to the function.

<<o_box.c : o_box_fill_fill()>>=
void
o_box_fill_fill(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                gint x, gint y,
                gint width, gint height,
                gint fill_width,
                gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  gdk_gc_set_foreground(gc, color);
  gdk_gc_set_line_attributes(gc, 1, GDK_LINE_SOLID,
                             GDK_CAP_BUTT, GDK_JOIN_MITER);

  gdk_draw_rectangle(w, gc, TRUE, x, y, width, height);
	
}

@ %def o_box_fill_fill


@section Function [[o_box_fill_hatch]]

@defun o_box_fill_hatch w gc color x y width height fill_width angle1 pitch1 angle2 pitch2
This function fills the inside of the box with a pattern made of lines. The lines are drawn inside the box with an angle [[angle1]] from the horizontal. The distance between two of these lines is given by [[pitch1]] and their width by [[fill_width]].
Parameters [[angle2]] and [[pitch2]] are unused here but kept for compatbility with other box filling functions.
@end defun

The box is defined in the same way as it is in GDK : one point and the width and height of the box.

All parameters are given in pixel.

Negative or null values for [[pitch1]] are not allowed as it leads to an endless loop.

<<o_box.c : o_box_fill_hatch()>>=
void
o_box_fill_hatch(GdkDrawable *w, GdkGC *gc, GdkColor *color,
                 gint x, gint y,
                 gint width, gint height,
                 gint fill_width,
                 gint angle1, gint pitch1, gint angle2, gint pitch2)
{
  int x3, y3, x4, y4;
  double cos_a_, sin_a_;
  double x0, y0, r;
  double x1, y1, x2, y2;
  double amin, amax, a[4], min1, min2, max1, max2;

  gdk_gc_set_line_attributes(gc, fill_width, GDK_LINE_SOLID,
                             GDK_CAP_BUTT, GDK_JOIN_MITER);

@ %def o_box_fill_hatch

The function uses a matrix. Its elements are obtained from the sinus and the cosinus of the angle [[angle1]]. It represents the rotation matrix that when applied to a point, rotate it of [[angle1]].

<<o_box.c : o_box_fill_hatch()>>=
  cos_a_ = cos(((double) angle1) * M_PI/180);
  sin_a_ = sin(((double) angle1) * M_PI/180);

@ 

The function considers the smallest circle around the box. Its radius is given by the following relation. Its center is given by the point a the middle of the box horizontally and vertically (intersection of its two diagonals.

<<o_box.c : o_box_fill_hatch()>>=

  r = sqrt((double) (pow(width, 2) + pow(height, 2))) / 2;

  <<o_box_fill_hatch() : calculating and drawing the lines>>

}
  
@ 

When drawing a line in a circle there is two intersections. With the previously described circle, these intersections are out of the box. They can be easily calculated, the first by resolution of an equation and the second one by symetry in relation to the vertical axis going through the center of the circle.

These two points are then rotated of angle [[angle1]] using the matrix previously mentionned.

<<o_box_fill_hatch() : calculating and drawing the lines>>=
 
	y0 = 0;
	while(y0 < r) {
		x0 = pow(r, 2) - pow(y0, 2);
		x0 = sqrt(x0);

		x1 = (x0*cos_a_ - y0*sin_a_);
		y1 = (x0*sin_a_ + y0*cos_a_);
		x2 = ((-x0)*cos_a_ - y0*sin_a_);
		y2 = ((-x0)*sin_a_ + y0*cos_a_);

@ 

It now parametrizes the segment : first intersection is given the value of 0 and the second is given the value of 1. The four values for each intersection of the segment and the four sides (vertical or horizontal) of the box are given by the following relations :

<<o_box_fill_hatch() : calculating and drawing the lines>>=		
		if((int) (x2 - x1) != 0) {
			a[0] = ((-width/2) - x1) / (x2 - x1);
			a[1] = ((width/2)  - x1) / (x2 - x1);
		} else {
			a[0] = 0; a[1] = 1;
		}

		if((int) (y2 - y1) != 0) {
			a[2] = ((-height/2) - y1) / (y2 - y1);
			a[3] = ((height/2)  - y1) / (y2 - y1);
		} else {
			a[2] = 0; a[3] = 1;
		}

@ 

It now has to check which of these four values are for intersections with the sides of the box (some values may be for intersections out of the box). This is made by a min/max function.

<<o_box_fill_hatch() : calculating and drawing the lines>>=
		if(a[0] < a[1]) {
			min1 = a[0]; max1 = a[1];
		} else {
			min1 = a[1]; max1 = a[0];
		}

		if(a[2] < a[3]) {
			min2 = a[2]; max2 = a[3];
		} else {
			min2 = a[3]; max2 = a[2];
		}

		amin = (min1 < min2) ? min2 : min1;
		amin = (amin < 0) ? 0 : amin;

		amax = (max1 < max2) ? max1 : max2;
		amax = (amax < 1) ? amax : 1;

@ 

If the segment really go through the box it draws the line. It also take the opportunity of the symetry in the box in relation to its center to draw the second line at the same time.

If there is no intersection of the segment with any of the sides, then there is no need to continue : there would be no more segment in the box to draw.

<<o_box_fill_hatch() : calculating and drawing the lines>>=		
  if((amax > amin) && (amax != 1) && (amin != 0)) {
    /* There is intersection between the line and the box edges */
    x3 = (int) (x1 + amin*(x2 - x1));
    y3 = (int) (y1 + amin*(y2 - y1));

    x4 = (int) (x1 + amax*(x2 - x1));
    y4 = (int) (y1 + amax*(y2 - y1));

    gdk_draw_line(w, gc, x3 + (x + width/2),
                  (y + height/2) - y3, x4 + (x + width/2),
                  (y + height/2) - y4);
			
    gdk_draw_line(w, gc, -x3 + (x + width/2),
                  +y3 + (y + height/2), -x4 + (x + width/2),
                  +y4 + (y + height/2));
			
  } else {
    break;
  }
		
 y0 = y0 + pitch1;
 
        }

@


@section Function [[o_box_fill_mesh]]

@defun o_box_fill_mesh w gc color x y width height fill_width angle1 pitch1 angle2 pitch2
This function fills the inside of the box with a pattern made of two sets of parallel lines in two directions. The first set is drawn inside the box with an angle [[angle1]] from the horizontal. The distance between two of these lines is given by [[pitch1]].
The second set is drawn inside the box with an angle [[angle2]] from the horizontal. The distance between two of these lines is given by [[pitch2]].
Every lines have the same width given be [[fill_width]].
@end defun

This function simply makes two successive calls to the function [[o_box_fill_hatch]] respectively with [[angle1]], [[pitch1]] and [[angle2]], [[pitch2]] for parameters.

<<o_box.c : o_box_fill_mesh()>>=
void
o_box_fill_mesh(GdkDrawable *w, GdkGC *gc, GdkColor *color,
		gint x, gint y,
		gint width, gint height,
		gint fill_width,
		gint angle1, gint pitch1,
                gint angle2, gint pitch2)
{
  o_box_fill_hatch(w, gc, color, x, y, width, height,
		   fill_width, angle1, pitch1, -1, -1);
  o_box_fill_hatch(w, gc, color, x, y, width, height,
	  	   fill_width, angle2, pitch2, -1, -1);
}

@ %def o_box_fill_mesh


@section Function [[o_box_erase]]

@defun o_box_erase w_current o_current
This function erases a box, described in a [[OBJECT]] structure pointed by [[o_current]].
@end defun

It makes a call to the function [[o_box_draw()]] after setting the special color. Therefore a box is drawn with background color over the previous one.

<<o_box.c : o_box_erase()>>=
void
o_box_erase(TOPLEVEL *w_current, OBJECT *o_current)
{
    w_current->override_color = w_current->background_color;
    o_box_draw(w_current, o_current);
    w_current->override_color = -1;
}

@ %def o_box_erase


@section Function [[o_box_draw_xor]]

@defun o_box_draw_xor w_current dx dy o_current
This function daws the box object described by [[*o_current]] translated by the vector ([[dx]],[[dy]]) with an xor-function over the current sheet.
The translation vector is in screen unit.
@end defun

The box is displayed with the color of the object.

<<o_box.c : o_box_draw_xor()>>=
void
o_box_draw_xor(TOPLEVEL *w_current, int dx, int dy, OBJECT *o_current)
{
  int screen_x1, screen_y1;
  int screen_x2, screen_y2;
  int color;

  if (o_current->box == NULL) {
    return;
  }

  screen_x1 = o_current->box->screen_upper_x;
  screen_y1 = o_current->box->screen_upper_y;
  screen_x2 = o_current->box->screen_lower_x;
  screen_y2 = o_current->box->screen_lower_y;

  if (o_current->saved_color != -1) {
    color = o_current->saved_color;
  } else {
    color = o_current->color;
  }

  gdk_gc_set_foreground(w_current->outline_xor_gc,
                        x_get_darkcolor(color));
  gdk_draw_rectangle(w_current->window,
                     w_current->outline_xor_gc, FALSE,
                     screen_x1 + dx,
                     screen_y1 + dy,
                     abs(screen_x2 - screen_x1),
                     abs(screen_y2 - screen_y1));
}

@ %def o_box_draw_xor


@section Function [[o_box_start]]

@defun o_box_start w_current x y
This function starts the process to input a new box. Parameters for this box are put into/extracted from the [[w_current]] toplevel structure.
[[x]] and [[y]] are current coordinates of the pointer in screen coordinates.
@end defun

The first step is to input one corner of the box. This corner is ([[x]],[[y]]) snapped to the grid and saved in [[w_current->start_x]] and [[w_current->start_y]].

The other corner will be saved in ([[w_current->last_x]],[[w_current->last_y]]).

<<o_box.c : o_box_start()>>=
void
o_box_start(TOPLEVEL *w_current, int x, int y)
{
  /* init start_[x|y], last_[x|y] to describe box */
  w_current->last_x = w_current->start_x = fix_x(w_current, x);
  w_current->last_y = w_current->start_y = fix_y(w_current, y);

  /* start to draw the box */
  o_box_rubberbox_xor(w_current);
  
}

@ %def o_box_start


@section Function [[o_box_end()]]

@defun o_box_end w_current x y
This function ends the input of the second corner of a box. The ([[x]],[[y]]) point is set to be this second corner. The box is then defined by ([[w_current->start_x]],[[w_current->start_y]] and ([[w_current->last_x]],[[w_current->last_y]] that is a snapped version of ([[x]],[[y]]).
[[x]] and [[y]] are in screen unit.
@end defun

The temporary box is erased ; a new box object is allocated, initialized and linked to the object list ; The object is finally drawn on the current sheet.

<<o_box.c : o_box_end()>>=
void
o_box_end(TOPLEVEL *w_current, int x, int y)
{
  int x1, y1;
  int x2, y2;
  int box_width, box_height;
  int box_left, box_top;

  if (w_current->inside_action == 0) {
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }

  /* get the last coords of the pointer */
  w_current->last_x = fix_x(w_current, x);
  w_current->last_y = fix_y(w_current, y);

  /* erase the temporary box */
  o_box_rubberbox_xor(w_current);
  
  box_width  = GET_BOX_WIDTH (w_current);
  box_height = GET_BOX_HEIGHT(w_current);
  box_left   = GET_BOX_LEFT  (w_current);
  box_top    = GET_BOX_TOP   (w_current);

  /* boxes with null width and height are not allowed */
  if ((box_width == 0) && (box_height == 0)) {
	  /* cancel the object creation */
	  w_current->start_x = (-1);
	  w_current->start_y = (-1);
	  w_current->last_x  = (-1);
	  w_current->last_y  = (-1);
	  return;
  }

  /* calculate the world coords of the upper left and lower right corners */
  SCREENtoWORLD(w_current, box_left, box_top, &x1, &y1);
  SCREENtoWORLD(w_current,
                box_left + box_width, box_top  + box_height, &x2, &y2);
  x1 = snap_grid(w_current, x1);
  y1 = snap_grid(w_current, y1);
  x2 = snap_grid(w_current, x2);
  y2 = snap_grid(w_current, y2);

  /* create the object */
  w_current->page_current->object_tail = 
  o_box_add(w_current,
            w_current->page_current->object_tail,
            OBJ_BOX, w_current->graphic_color, x1, y1, x2, y2);

  /* draw it */
  o_redraw_single(w_current, w_current->page_current->object_tail);
  
#if DEBUG
  printf("coords: %d %d %d %d\n", x1, y2, x2, y2);
#endif
	
  w_current->start_x = (-1);
  w_current->start_y = (-1);
  w_current->last_x  = (-1);
  w_current->last_y  = (-1);
	
  w_current->page_current->CHANGED = 1;

  o_undo_savestate(w_current, UNDO_ALL);
}

@ %def o_box_end


@section Function [[o_box_rubberbox]]

@defun o_box_rubberbox w_current x y
This function is used to draw the box while dragging one of its edge or angle. It erases the previous temporary box drawn before, and draws a new updated one. [[x]] and [[y]] are the new position of the mobile point, ie the mouse.
@end defun

The old values are inside the [[w_current]] pointed structure. Old wicth, height and left and top values are recomputed by the corresponding macros. The box is then erased by performing a xor-drawing over the box.

<<o_box.c : o_box_rubberbox()>>=
void
o_box_rubberbox(TOPLEVEL *w_current, int x, int y)
{
  if (w_current->inside_action == 0) {
    o_redraw(w_current, w_current->page_current->object_head);
    return;
  }

  /* erase the previous temporary box */
  o_box_rubberbox_xor(w_current);

@ %def o_box_rubberbox

New values are fixed according to the [[x]] and [[y]] parameters. These are saved in [[w_current]] pointed structure as new temporary values. The new box is then drawn.

<<o_box.c : o_box_rubberbox()>>=
  /* update the coords of the corner */
  w_current->last_x = fix_x(w_current, x);
  w_current->last_y = fix_y(w_current, y);

  /* draw the new temporary box */
  o_box_rubberbox_xor(w_current);
  
}

@ %def o_box_rubberbox


@section Function [[o_box_rubberbox_xor]]

@defun o_box_rubberbox_xor w_current
This function draws the box from the variables in the toplevel structure [[*w_current]].
One corner of the box is at ([[w_current->start_x]],[[w_current->start_y]]) and the second corner is at ([[w_current->last_x]],[[w_current->last_y]].
@end defun

The box is drawn with a xor-function over the current sheet with the selection color.

<<o_box.c : o_box_rubberbox_xor()>>=
void
o_box_rubberbox_xor(TOPLEVEL *w_current)
{
	int box_width, box_height, box_left, box_top;

	/* get the width/height and the upper left corner of the box */
	box_width  = GET_BOX_WIDTH (w_current);
	box_height = GET_BOX_HEIGHT(w_current);
	box_left   = GET_BOX_LEFT  (w_current);
	box_top    = GET_BOX_TOP   (w_current);

	/* draw the box from the previous variables */
	gdk_gc_set_foreground(w_current->xor_gc,
						  x_get_color(w_current->select_color));
	gdk_gc_set_line_attributes(w_current->xor_gc, 0,
							   GDK_LINE_SOLID, GDK_CAP_NOT_LAST, 
							   GDK_JOIN_MITER);
	gdk_draw_rectangle(w_current->window, w_current->xor_gc,
					   FALSE, box_left, box_top, box_width, box_height);
	
}

@ %def o_box_rubberbox_xor


@section Function [[o_box_draw_grips()]]

@defun o_box_draw_grips w_current w o_current
This function draws four grips on the corners of the box described by [[*o_current]].
@end defun

<<o_box.c : o_box_draw_grips()>>=
/* p20011003 - modified the prototype : removed parameter 'GdkWindow *w' */
void
o_box_draw_grips(TOPLEVEL *w_current, OBJECT *o_current) 
{
  if (w_current->draw_grips == FALSE)
	  return;

  /* grip on upper left corner (whichone = BOX_UPPER_LEFT) */
  o_grips_draw(w_current,
			   o_current->box->screen_upper_x,
			   o_current->box->screen_upper_y);

  /* grip on upper right corner (whichone = BOX_UPPER_RIGHT) */
  o_grips_draw(w_current,
			   o_current->box->screen_lower_x,
			   o_current->box->screen_upper_y);
  
  /* grip on lower left corner (whichone = BOX_LOWER_LEFT) */
  o_grips_draw(w_current,
			   o_current->box->screen_upper_x,
			   o_current->box->screen_lower_y);

  /* grip on lower right corner (whichone = BOX_LOWER_RIGHT) */
  o_grips_draw(w_current,
			   o_current->box->screen_lower_x,
			   o_current->box->screen_lower_y);

}

@ %def o_box_draw_grips


@section Function [[o_box_erase_grips()]]

@defun o_box_erase_grips
This function erases the four grips displayed on the [[*o_current]] box object. These grips are on each of the corner.
@end defun

<<o_box.c : o_box_erase_grips()>>=
void
o_box_erase_grips(TOPLEVEL *w_current, OBJECT *o_current) 
{
  if (w_current->draw_grips == FALSE)
	  return;

  /* grip on upper left corner (whichone = BOX_UPPER_LEFT) */
  o_grips_erase(w_current,
				o_current->box->screen_upper_x,
				o_current->box->screen_upper_y);

  /* grip on upper right corner (whichone = BOX_UPPER_RIGHT) */
  o_grips_erase(w_current,
				o_current->box->screen_lower_x,
				o_current->box->screen_upper_y);
  
  /* grip on lower left corner (whichone = BOX_LOWER_LEFT) */
  o_grips_erase(w_current,
				o_current->box->screen_upper_x,
				o_current->box->screen_lower_y);

  /* grip on lower right corner (whichone = BOX_LOWER_RIGHT) */
  o_grips_erase(w_current,
				o_current->box->screen_lower_x,
				o_current->box->screen_lower_y);
  
}

@ %def o_box_erase_grips
