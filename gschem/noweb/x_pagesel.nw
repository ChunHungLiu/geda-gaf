@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File x_pagesel.c,,,Top
@chapter File @file{x_pagesel.c}

@section File header

<<x_pagesel.c : *>>=
<<x_pagesel.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/x_pagesel.nw instead */

<<x_pagesel.c : include directives>>


<<x_pagesel.c : x_pagesel_open()>>
<<x_pagesel.c : x_pagesel_close()>>
<<x_pagesel.c : x_pagesel_update()>>
<<x_pagesel.c : x_pagesel_callback_response()>>


<<x_pagesel.c : Pagesel widget>>

@


<<x_pagesel.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<x_pagesel.c : include directives>>=
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include <libgeda/libgeda.h>

#include "../include/globals.h"
#include "../include/prototype.h"

#ifdef HAVE_LIBDMALLOC
#include <dmalloc.h>
#endif

#include "../include/x_pagesel.h"


static void x_pagesel_callback_response (GtkDialog *dialog,
                                         gint arg1,
                                         gpointer user_data);

@


@section Function @code{x_pagesel_open()}

@defun x_pagesel_open toplevel
Opens the page manager dialog for [[toplevel]] if it is not already. In this last case, it raises the dialog.
@end defun

<<x_pagesel.c : x_pagesel_open()>>=
void
x_pagesel_open (TOPLEVEL *toplevel)
{
  if (toplevel->pswindow == NULL) {
    toplevel->pswindow = GTK_WIDGET (g_object_new (TYPE_PAGESEL,
                                                   "toplevel", toplevel,
                                                   NULL));

    g_signal_connect (toplevel->pswindow,
                      "response",
                      G_CALLBACK (x_pagesel_callback_response),
                      toplevel);
    
    gtk_widget_show (toplevel->pswindow);
  } else {
    gdk_window_raise (toplevel->pswindow->window);
  }

}

@ %def x_pagesel_open


@section Function @code{x_pagesel_close()}

@defun x_pagesel_close toplevel
Closes the page manager dialog associated with [[toplevel]].
@end defun

<<x_pagesel.c : x_pagesel_close()>>=
void
x_pagesel_close (TOPLEVEL *toplevel)
{
  if (toplevel->pswindow) {
    g_assert (IS_PAGESEL (toplevel->pswindow));
    gtk_widget_destroy (toplevel->pswindow);
    toplevel->pswindow = NULL;
  }
  
}

@ %def x_pagesel_close


@section Function @code{x_pagesel_update()}

@defun x_pagesel_update toplevel
Updates the list and status of [[toplevel]]\'s pages if the page manager dialog is opened.
@end defun

<<x_pagesel.c : x_pagesel_update()>>=
void
x_pagesel_update (TOPLEVEL *toplevel)
{
  if (toplevel->pswindow) {
    g_assert (IS_PAGESEL (toplevel->pswindow));
    pagesel_update (PAGESEL (toplevel->pswindow));
  }
  
}

@ %def x_pagesel_update


@section Function @code{x_pagesel_callback_response()}

@defun x_pagesel_callback_response dialog arg1 user_data
Handles response [[arg1]] of the page manager dialog [[dialog]].

Parameter [[user_data]] is a pointer on the relevant toplevel structure.
@end defun

<<x_pagesel.c : x_pagesel_callback_response()>>=
static void
x_pagesel_callback_response (GtkDialog *dialog,
                             gint arg1,
                             gpointer user_data)
{
  TOPLEVEL *toplevel = (TOPLEVEL*)user_data;

  switch (arg1) {
      case PAGESEL_RESPONSE_UPDATE:
        pagesel_update (PAGESEL (dialog));
        break;
      case GTK_RESPONSE_DELETE_EVENT:
      case PAGESEL_RESPONSE_CLOSE:
        g_assert (GTK_WIDGET (dialog) == toplevel->pswindow);
        gtk_widget_destroy (GTK_WIDGET (dialog));
        toplevel->pswindow = NULL;
        break;
      default:
        g_assert_not_reached ();
  }
  
}

@ %def x_pagesel_callback_response


@section Widget @code{Pagesel}

<<x_pagesel.c : Pagesel widget>>=
enum {
  PROP_TOPLEVEL=1,
};

enum {
  COLUMN_PAGE,
  COLUMN_NAME,
  COLUMN_CHANGED,
  NUM_COLUMNS
};


static void pagesel_class_init (PageselClass *class);
static void pagesel_init       (Pagesel *pagesel);
static void pagesel_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec);
static void pagesel_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec);

<<x_pagesel.c : pagesel_callback_button_*()>>
<<x_pagesel.c : pagesel_callback_selection_changed()>>

<<x_pagesel.c : pagesel_get_type()>>
<<x_pagesel.c : pagesel_class_init()>>
<<x_pagesel.c : pagesel_init()>>
<<x_pagesel.c : pagesel_set_property()>>
<<x_pagesel.c : pagesel_get_property()>>

<<x_pagesel.c : pagesel_update()>>

@ 


@subsection Function [[page_get_type()]]

@defun pagesel_get_type
@end defun

<<x_pagesel.c : pagesel_get_type()>>=
GType
pagesel_get_type ()
{
  static GType pagesel_type = 0;
  
  if (!pagesel_type) {
    static const GTypeInfo pagesel_info = {
      sizeof(PageselClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) pagesel_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof(Pagesel),
      0,    /* n_preallocs */
      (GInstanceInitFunc) pagesel_init,
    };
		
    pagesel_type = g_type_register_static (GTK_TYPE_DIALOG,
                                           "Pagesel",
                                           &pagesel_info, 0);
  }
  
  return pagesel_type;
}

@ %def pagesel_get_type


@subsection Function [[pagesel_class_init()]]

@defun pagesel_class_init klass
@end defun

<<x_pagesel.c : pagesel_class_init()>>=
static void
pagesel_class_init (PageselClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = pagesel_set_property;
  gobject_class->get_property = pagesel_get_property;

  g_object_class_install_property (
    gobject_class, PROP_TOPLEVEL,
    g_param_spec_pointer ("toplevel",
                          "",
                          "",
                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE));
	
}

@ %def pagesel_class_init


@subsection Function @code{pagesel_init()}

@defun pagesel_init pagesel
@end defun

<<x_pagesel.c : pagesel_init()>>=
static void
pagesel_init (Pagesel *pagesel)
{
  GtkWidget *scrolled_win, *treeview, *bbox, *button;
  GtkTreeModel *store;
  GtkCellRenderer *renderer;
  GtkTreeViewColumn *column;
  GtkTreeSelection *selection;
  struct button_t {
    gchar *label;
    void (*callback)(void);
#ifndef HAS_GTK12
    const gchar *stock_id;
#endif
  };
  struct button_t buttons[] = {
    { "New Page",     G_CALLBACK (pagesel_callback_button_new_page)
#ifndef HAS_GTK12
      , GTK_STOCK_NEW     
#endif
    },
    { "Open Page",    G_CALLBACK (pagesel_callback_button_open_page)
#ifndef HAS_GTK12
      , GTK_STOCK_OPEN    
#endif
    },
    { "Save Page",    G_CALLBACK (pagesel_callback_button_save_page)
#ifndef HAS_GTK12
      , GTK_STOCK_SAVE
#endif
    },
    { "Close Page",   G_CALLBACK (pagesel_callback_button_close_page)
#ifndef HAS_GTK12
      , GTK_STOCK_CLOSE
#endif
    },
    { "Discard Page", G_CALLBACK (pagesel_callback_button_discard_page)
#ifndef HAS_GTK12
      , GTK_STOCK_CANCEL
#endif
    },
    { NULL,           NULL                                             
      , NULL
    } };
  struct button_t *tmp;

  /* dialog initialization */
  g_object_set (G_OBJECT (pagesel),
                /* GtkContainer */
                "border-width",    0,
                /* GtkWindow */
                "type",            GTK_WINDOW_TOPLEVEL,
                "title",           _("Page Manager"),
                "default-height",  220, 
                "default-width",   515,
                "modal",           FALSE,
                "window-position", GTK_WIN_POS_NONE,
                "type-hint",       GDK_WINDOW_TYPE_HINT_NORMAL,
                /* GtkDialog */
                "has-separator",   TRUE,
                NULL);

  /* create the model for the treeview */
  store = (GtkTreeModel*)gtk_tree_store_new (NUM_COLUMNS,
                                             G_TYPE_POINTER,  /* page */
                                             G_TYPE_STRING,   /* name */
                                             G_TYPE_BOOLEAN); /* changed */

  /* create a scrolled window for the treeview */
  scrolled_win = GTK_WIDGET (
    g_object_new (GTK_TYPE_SCROLLED_WINDOW,
                  /* GtkContainer */
                  "border-width",      5,
                  /* GtkScrolledWindow */
                  "hscrollbar-policy", GTK_POLICY_AUTOMATIC,
                  "vscrollbar-policy", GTK_POLICY_AUTOMATIC,
                  "shadow-type",       GTK_SHADOW_ETCHED_IN,
                  NULL));
  /* create the treeview */
  treeview = GTK_WIDGET (g_object_new (GTK_TYPE_TREE_VIEW,
                                       /* GtkTreeView */
                                       "model",      store,
                                       "rules-hint", TRUE,
                                       NULL));
  selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (treeview));
  gtk_tree_selection_set_mode (selection,
                               GTK_SELECTION_SINGLE);
  g_signal_connect (selection,
                    "changed",
                    G_CALLBACK (pagesel_callback_selection_changed),
                    pagesel);
  /*   - first column: page name */
  renderer = GTK_CELL_RENDERER (
    g_object_new (GTK_TYPE_CELL_RENDERER_TEXT,
                  /* GtkCellRendererText */
                  "editable", FALSE,
                  NULL));
  column = GTK_TREE_VIEW_COLUMN (
    g_object_new (GTK_TYPE_TREE_VIEW_COLUMN,
                  /* GtkTreeViewColumn */
                  "title", _("Filename"),
                  "min-width", 435,
                  "resizable", TRUE,
                  NULL));
  gtk_tree_view_column_pack_start (column, renderer, TRUE);
  gtk_tree_view_column_add_attribute (column, renderer, "text", COLUMN_NAME);
  gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
  /*   - second column: changed */
  renderer = GTK_CELL_RENDERER (
    g_object_new (GTK_TYPE_CELL_RENDERER_TOGGLE,
                  /* GtkCellRendererToggle */
                  "activatable", FALSE,
                  NULL));
  column = GTK_TREE_VIEW_COLUMN (
    g_object_new (GTK_TYPE_TREE_VIEW_COLUMN,
                  /* GtkTreeViewColumn */
                  "title", _("Changed"),
                  "sizing", GTK_TREE_VIEW_COLUMN_FIXED,
                  NULL));
  gtk_tree_view_column_pack_start (column, renderer, TRUE);
  gtk_tree_view_column_add_attribute (column, renderer, "active", COLUMN_CHANGED);
  gtk_tree_view_append_column (GTK_TREE_VIEW (treeview), column);
      
  /* add the treeview to the scrolled window */
  gtk_container_add (GTK_CONTAINER (scrolled_win), treeview);
  /* set treeview of pagesel */
  pagesel->treeview = GTK_TREE_VIEW (treeview);

  /* create the button array for actions */
  bbox = GTK_WIDGET (g_object_new (GTK_TYPE_HBUTTON_BOX,
                                   /* GtkContainer */
                                   "border-width", 5,
                                   /* GtkButtonBox */
                                   "layout-style", GTK_BUTTONBOX_EDGE,
                                   NULL));
  for (tmp = buttons; tmp->label != NULL; tmp++) {
#ifdef HAS_GTK12
    button = GTK_WIDGET (g_object_new (GTK_TYPE_BUTTON,
                                       /* GtkButton */
                                       "label", _(tmp->label),
                                       NULL));
#else
    button = gtk_button_new_from_stock (tmp->stock_id);
    /* If the label is set after the button is created, the icon is lost */
    /*    gtk_button_set_label (GTK_BUTTON(button), _(tmp->label)); */
#endif
    g_signal_connect (button,
                      "clicked",
                      tmp->callback,
                      pagesel);
    gtk_container_add (GTK_CONTAINER (bbox), button);
  }

  /* add scrolled window and action buttons to the dialog vbox */
  gtk_box_pack_start (GTK_BOX (GTK_DIALOG (pagesel)->vbox), scrolled_win,
                      TRUE, TRUE, 0);
  gtk_widget_show_all (scrolled_win);
  gtk_box_pack_start (GTK_BOX (GTK_DIALOG (pagesel)->vbox), bbox,
                      FALSE, TRUE, 0);
  gtk_widget_show_all (bbox);


  /* now add buttons in the action area */
  gtk_dialog_add_buttons (GTK_DIALOG (pagesel),
                          /*  - update button */
                          GTK_STOCK_REFRESH, PAGESEL_RESPONSE_UPDATE,
                          /*  - close button */
                          GTK_STOCK_CLOSE,   PAGESEL_RESPONSE_CLOSE,
                          NULL);
  
}

@ %def pagesel_init


@subsection Function [[pagesel_set_property()]]

@defun pagesel_set_property object property_id value pspec
@end defun

<<x_pagesel.c : pagesel_set_property()>>=
static void
pagesel_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Pagesel *pagesel = PAGESEL (object);

  switch(property_id) {
      case PROP_TOPLEVEL:
        pagesel->toplevel = (TOPLEVEL*)g_value_get_pointer (value);
        pagesel_update (pagesel);
        break;
      default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
  }

}

@ %def pagesel_set_property


@subsection Function [[pagesel_get_property()]]

@defun pagesel_get_property object property_id value pspec
@end defun

<<x_pagesel.c : pagesel_get_property()>>=
static void
pagesel_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Pagesel *pagesel = PAGESEL (object);

  switch(property_id) {
      case PROP_TOPLEVEL:
        g_value_set_pointer (value, (gpointer)pagesel->toplevel);
        break;
      default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
  }

}

@ %def pagesel_get_property


@subsection Function @code{pagesel_callback_selection_changed()}

@defun pagesel_callback_selection_changed selection user_data
@end defun

<<x_pagesel.c : pagesel_callback_selection_changed()>>=
static void
pagesel_callback_selection_changed (GtkTreeSelection *selection,
                                    gpointer user_data)
{
  GtkTreeModel *model;
  GtkTreeIter iter;
  Pagesel *pagesel = (Pagesel*)user_data;
  TOPLEVEL *toplevel;
  PAGE *page;

  if (!gtk_tree_selection_get_selected (selection, &model, &iter)) {
    return;
  }
  
  toplevel = pagesel->toplevel;
  gtk_tree_model_get (model, &iter,
                      COLUMN_PAGE, &page,
                      -1);

  /* temp */
  s_page_goto (toplevel, page);
  i_set_filename (toplevel, toplevel->page_current->page_filename);
  x_scrollbars_update (toplevel);
  o_redraw_all (toplevel);

}

@ %def pagesel_callback_selection_changed


@subsection Function @code{pagesel_callback_button_*()}

@defun pagesel_callback_button_* button user_data
@end defun

<<x_pagesel.c : pagesel_callback_button_*()>>=
#define DEFINE_BUTTON_CALLBACK(name, action)                      \
static void                                                       \
pagesel_callback_button_ ## name (GtkButton *button,              \
                                  gpointer user_data)             \
{                                                                 \
  i_callback_ ## action (PAGESEL (user_data)->toplevel, 0, NULL); \
}

DEFINE_BUTTON_CALLBACK (new_page,     file_new);
DEFINE_BUTTON_CALLBACK (open_page,    file_open);
DEFINE_BUTTON_CALLBACK (save_page,    file_save);
DEFINE_BUTTON_CALLBACK (close_page,   page_close);
DEFINE_BUTTON_CALLBACK (discard_page, page_discard);

@ %def pagesel_callback_button_new_page pagesel_callback_button_open_page pagesel_callback_button_save_page pagesel_callback_button_close_page pagesel_callback_button_discard_page


@subsection Function @code{pagesel_update()}

@defun pagesel_update pagesel
Updates the tree model of [[pagesel]]\'s treeview.

Right now, each time it is called, it rebuilds all the model from the list of page in the toplevel.
@end defun

<<x_pagesel.c : pagesel_update()>>=
/* recursive function to populate the tree store */
static
add_page (GtkTreeModel *model, GtkTreeIter *parent,
          PAGE *page)
{
  GtkTreeIter iter;
  PAGE *p_current;

  /* add the page to the store */
  gtk_tree_store_append (GTK_TREE_STORE (model),
                         &iter,
                         parent);
  gtk_tree_store_set (GTK_TREE_STORE (model),
                      &iter,
                      COLUMN_PAGE, page,
                      COLUMN_NAME, page->page_filename,
                      COLUMN_CHANGED, page->CHANGED,
                      -1);
  
  /* search a page that has a up field == p_current->pid */
  for (p_current = page->next;
       p_current != NULL;
       p_current = p_current->next) {
    if (p_current->up == page->pid) {
      add_page (model, &iter, p_current);
    }
  }
  
}

/* recursive function to select the current page in the treeview */
static
select_page (GtkTreeView *treeview, GtkTreeIter *parent, PAGE *page)
{
  GtkTreeModel *treemodel = gtk_tree_view_get_model (treeview);
  GtkTreeIter iter;
  PAGE *p_current;

  if (!gtk_tree_model_iter_children (treemodel, &iter, parent)) {
    return;
  }

  do {
    gtk_tree_model_get (treemodel, &iter,
                        COLUMN_PAGE, &p_current,
                        -1);
    if (p_current == page) {
      gtk_tree_view_expand_all (treeview);
      gtk_tree_selection_select_iter (
        gtk_tree_view_get_selection (treeview),
        &iter);
      return;
    }

    select_page (treeview, &iter, page);
    
  } while (gtk_tree_model_iter_next (treemodel, &iter));
  
}

void
pagesel_update (Pagesel *pagesel)
{
  GtkTreeModel *model;
  TOPLEVEL *toplevel;
  PAGE *p_current;

  g_assert (IS_PAGESEL (pagesel));

  g_return_if_fail (pagesel->toplevel);

  toplevel = pagesel->toplevel;
  model    = gtk_tree_view_get_model (pagesel->treeview);

  /* wipe out every thing in the store */
  gtk_tree_store_clear (GTK_TREE_STORE (model));
  /* now rebuild */
  for (p_current = toplevel->page_head->next;
       p_current != NULL;
       p_current = p_current->next) {
    /* find every page that is not a hierarchy-down of another page */
    if (p_current->up < 0 ||
        s_hierarchy_find_page (toplevel->page_head->next,
                               p_current->up) == NULL) {
      add_page (model, NULL, p_current);
    }
  }

  /* select the current page in the treeview */
  select_page (pagesel->treeview, NULL, toplevel->page_current);
  
}

@ %def pagesel_update
