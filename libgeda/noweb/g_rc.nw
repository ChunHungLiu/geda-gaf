@c -*- mode: Noweb; noweb-doc-mode: texinfo-mode; noweb-code-mode: c-mode -*-

@node File g_rc.c,,,Top
@chapter File @file{g_rc.c}

@section File header

<<g_rc.c : *>>=
<<g_rc.c : copyright and license>>

/* DO NOT read or edit this file ! Use ../noweb/g_rc.nw instead */

<<g_rc.c : include directives>>

<<g_rc.c : g_rc_parse_general()>>
<<g_rc.c : g_rc_parse_path()>>
<<g_rc.c : g_rc_parse_system_rc()>>
<<g_rc.c : g_rc_parse_home_rc()>>
<<g_rc.c : g_rc_parse_local_rc()>>
<<g_rc.c : g_rc_parse_gaf_rc()>>
<<g_rc.c : g_rc_parse()>>

<<g_rc.c : g_rc_component_library()>>
<<g_rc.c : g_rc_component_library_search()>>
<<g_rc.c : g_rc_source_library()>>
<<g_rc.c : g_rc_source_library_search()>>
<<g_rc.c : g_rc_world_size()>>

<<g_rc.c : g_rc_default_series_name()>>
<<g_rc.c : g_rc_untitled_name()>>
<<g_rc.c : g_rc_font_directory()>>
<<g_rc.c : g_rc_scheme_directory()>>
<<g_rc.c : g_rc_bitmap_directory()>>
<<g_rc.c : g_rc_bus_ripper_symname()>>

<<g_rc.c : g_rc_reset_component_library()>>
<<g_rc.c : g_rc_reset_source_library()>>


@


<<g_rc.c : copyright and license>>=
/* gEDA - GPL Electronic Design Automation
 * libgeda - gEDA's Library
 * Copyright (C) 1998-2000 Ales V. Hvezda
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA
 */

@ 


<<g_rc.c : include directives>>=
#include <config.h>

#include <stdio.h>
#include <sys/stat.h>
#include <ctype.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <gtk/gtk.h>
#include <guile/gh.h>

#include "defines.h"
#include "struct.h"
#include "globals.h"
#include "o_types.h"
#include "colors.h"

#include "../include/i_vars.h"
#include "../include/papersizes.h"
#include "../include/prototype.h"

@

@section Function @code{g_rc_parse_general()}

@defun g_rc_parse_general fname ok_msg err_msg
@end defun

<<g_rc.c : g_rc_parse_general()>>=
int
g_rc_parse_general(const char *fname, const char *ok_msg, const char *err_msg)
{
  int found_rc = 0;
  char* tmp;

  if (access(fname, R_OK) == 0) {
    /* TODO: fix g_read_file to accept "const char *" */
    tmp = u_basic_strdup(fname);
    g_read_file(tmp);
    free(tmp);
    found_rc = 1;
    s_log_message(ok_msg, fname);
  } else {
    s_log_message(err_msg, fname);
  }
  return found_rc;
}


@ %def g_rc_parse_general


@section Function @code{g_rc_parse_path()}

@defun g_rc_parse_path 
You should not free the returned character string.
@end defun
<<g_rc.c : g_rc_parse_path()>>=
char *
g_rc_parse_path()
{
  char *rc_path = NULL;
  
  if (strcmp(GEDARCDIR, "none") == 0) {
    /* rc dir not specified at configure time, so search for config in */
    /* the normal GEDADATA directory */
    rc_path = getenv("GEDADATA");
  } else {
    /* rc path specified at configure time, always return specified path */
    rc_path = GEDARCDIR;
  }

  return(rc_path);
}

@ %def g_rc_parse_path



@section Function @code{g_rc_parse_system_rc()}

@defun g_rc_parse_system_rc 
@end defun

<<g_rc.c : g_rc_parse_system_rc()>>=
static int
g_rc_parse_system_rc(char* rcname)
{
  int found_rc;
  char *filename;
  char *geda_data = getenv("GEDADATA");
  char *path_to_rc;
  char *ok_msg;
  char *err_msg;

  if (geda_data == NULL) {
    fprintf(stderr, "You must set the GEDADATA environment variable!\n");
    exit(-1);
  }

  path_to_rc = g_rc_parse_path(); /* do not free path_to_rc */

  filename = u_basic_strdup_multiple(path_to_rc,
				     PATH_SEPARATER_STRING, 
                                     "system-", rcname,
                                     NULL);
  
  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read system-", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find required system-",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);  
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_system_rc


@section Function @code{g_rc_parse_home_rc()}

@defun g_rc_parse_home_rc 
@end defun

<<g_rc.c : g_rc_parse_home_rc()>>=
static int
g_rc_parse_home_rc(char* rcname)
{
  int found_rc;
  char *filename;
  char *HOME;
  char *ok_msg;
  char *err_msg;

  HOME = (char *) getenv("HOME");
  if (HOME == NULL) {
    return 0;
  }

  filename = u_basic_strdup_multiple(HOME,
				     PATH_SEPARATER_STRING,
                                     ".gEDA",
				     PATH_SEPARATER_STRING, 
				     rcname,
                                     NULL);
  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read ~/.gEDA/", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find optional ~/.gEDA/",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_home_rc


@section Function @code{g_rc_parse_local_rc()}

@defun g_rc_parse_local_rc 
@end defun

<<g_rc.c : g_rc_parse_local_rc()>>=
static int
g_rc_parse_local_rc(char* rcname)
{
  int found_rc;
  char *filename;
  char *ok_msg;
  char *err_msg;

  filename = u_basic_strdup_multiple(".", PATH_SEPARATER_STRING, rcname, 
				     NULL);
  if (filename == NULL) {
    return 0;
  }

  ok_msg = u_basic_strdup_multiple("Read local ", rcname, " file [%s]\n",
                                   NULL);
  err_msg = u_basic_strdup_multiple("Did not find optional local ",
                                    rcname, " file [%s]\n", NULL);  
  found_rc = g_rc_parse_general(filename, ok_msg, err_msg);
  
  free(ok_msg);
  free(err_msg);
  free(filename);

  return found_rc;
}


@ %def g_rc_parse_local_rc


@section Function @code{g_rc_parse_gaf_rc()}

@defun g_rc_parse_gaf_rc 
@end defun

<<g_rc.c : g_rc_parse_gaf_rc()>>=
int
g_rc_parse_gaf_rc()
{
  int found_rc;
  char *filename;

  filename = u_basic_strdup_multiple(".", PATH_SEPARATER_STRING, "gafrc", 
				     NULL);
  if (filename == NULL) {
    return 0;
  }

  found_rc =
    g_rc_parse_general(filename,
                       "Read local gafrc file [%s]\n",
                       "Did not find optional local gafrc file [%s]\n");

  free(filename);

  return found_rc;
}

@ %def g_rc_parse_gaf_rc


@section Function @code{g_rc_parse()}

@defun g_rc_parse 
@end defun

<<g_rc.c : g_rc_parse()>>=
void
g_rc_parse(char* rcname, char* specified_rc_filename)
{
  int found_rc = 0;
  char *rc_path;
  char *geda_rcdata;

  rc_path = g_rc_parse_path(); /* do not free rc_path */

  /* set the GEDADATARC environment variable so that the rc files */
  /* know where to look for others */
  geda_rcdata = u_basic_strdup_multiple("GEDADATARC=", rc_path, NULL);
  putenv(geda_rcdata);
  
  /* visit rc files in order */
  /* Changed by SDB 1.2.2005 in response to Peter Kaiser's bug report.
   * Read gafrc files first */
  found_rc |= g_rc_parse_system_rc("gafrc");
  found_rc |= g_rc_parse_home_rc("gafrc");
  found_rc |= g_rc_parse_local_rc("gafrc");
  /* continue support for individual rc files for each program.  */
  found_rc |= g_rc_parse_system_rc(rcname);
  found_rc |= g_rc_parse_home_rc(rcname);
  found_rc |= g_rc_parse_local_rc(rcname);

/* g_rc_parse_gaf_rc defined in libgeda/g_rc.nw */
/* Don't need this now 
 *  found_rc |= g_rc_parse_gaf_rc(); 
 */


  if (specified_rc_filename != NULL) {
    if (access(specified_rc_filename, R_OK) == 0) {
      g_read_file(specified_rc_filename);
      found_rc = 1;
      s_log_message(
                    "Read specified rc file [%s]\n",
                    specified_rc_filename);
    } else {
      fprintf(stderr,
              "Did not find specified %s file [%s]\n",
              rcname, specified_rc_filename);
      s_log_message(
                    "Did not find specified %s file [%s]\n",
                    rcname, specified_rc_filename);
    }
  }


  /* Oh well, I couldn't find any rcfile, exit! */
  if (!found_rc) {
    /* TODO: these two are basically the
     * same. Inefficient! */
    s_log_message("Could not find any %s file!\n", rcname);
    fprintf(stderr, "Could not find a %s file\n", rcname);
    exit(-1);
  }
}


@ %def g_rc_parse



@section Function @code{g_rc_component_library()}

@defun g_rc_component_library path
@end defun

<<g_rc.c : g_rc_component_library()>>=
SCM
g_rc_component_library(SCM path)
{
  int ret;
  struct stat buf;
  char *cwd;
  char *string = gh_scm2newstr(path, NULL);
  char *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not an unique path? */
  if (!s_clib_uniq(string)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

#ifdef __MINGW32__
  if (string[1] == ':' && (string[2] == PATH_SEPARATER_CHAR ||
 			   string[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
  if (string[0] == PATH_SEPARATER_CHAR) {
#endif
    s_clib_add_entry(string);
  } else {
    cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
    u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
    temp = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, string, NULL);
    s_clib_add_entry(temp);
    free(temp);
    free(cwd);
  }

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_component_library


@section Function @code{g_rc_component_library_search()}

@defun g_rc_component_library_search path
@end defun

<<g_rc.c : g_rc_component_library_search()>>=
SCM
g_rc_component_library_search(SCM path)
{
  int ret;
  struct stat buf;
  DIR *top_ptr;
  struct dirent *dptr;
  char *string = gh_scm2newstr(path, NULL);
  char *fullpath;
  char *cwd, *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  top_ptr = opendir(string);

  if (top_ptr == NULL) {
    fprintf(stderr,
            "Invalid path [%s] passed to component-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  while((dptr = readdir(top_ptr))) {

    /* don't do . and .. and special case font */
    if ((strcmp(dptr->d_name, ".") != 0) && 
        (strcmp(dptr->d_name, "..") != 0) &&
        (strcmp(dptr->d_name, "font") != 0)) {

          fullpath=(char *)malloc(sizeof(char)*(strlen(string)+
                                                strlen(dptr->d_name)+2));
          sprintf(fullpath, "%s%c%s", string, PATH_SEPARATER_CHAR, 
	          dptr->d_name);
          stat(fullpath, &buf);
          if (S_ISDIR(buf.st_mode)) { 
            if (s_clib_uniq(fullpath)) {

#ifdef __MINGW32__
              if (fullpath[1] == ':' &&
                  (fullpath[2] == PATH_SEPARATER_CHAR ||
                   fullpath[2] == OTHER_PATH_SEPARATER_CHAR))  {
#else
              if (fullpath[0] == PATH_SEPARATER_CHAR) {
#endif
                s_clib_add_entry(fullpath);
#if DEBUG
                printf("absolute: %s\n", fullpath);
#endif
              } else {
                cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
		u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
                temp = u_basic_strdup_multiple(cwd, 
                                               PATH_SEPARATER_STRING, 
					       fullpath, NULL);
#if DEBUG
                printf("relative: %s\n", temp);
#endif
                s_clib_add_entry(temp);
                free(temp);
                free(cwd);
              }
            } 
          }
          free(fullpath);
        }
  }       

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_component_library_search


@section Function @code{g_rc_source_library()}

@defun g_rc_source_library path
@end defun

<<g_rc.c : g_rc_source_library()>>=
SCM
g_rc_source_library(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);
  char *temp, *cwd;

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "source-library"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to %s\n",
            string,
            "source-library");
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a unique path? */
  if (!s_slib_uniq(string)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }


#ifdef __MINGW32__
  if (string[1] == ':' && (string[2] == PATH_SEPARATER_CHAR ||
		           string[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
  if (string[0] == PATH_SEPARATER_CHAR) {
#endif
    s_slib_add_entry(string);
  } else {
    cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
    u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
    temp = u_basic_strdup_multiple(cwd, PATH_SEPARATER_STRING, string, NULL);
    s_slib_add_entry(temp);
    free(temp);
    free(cwd);
  }

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_source_library


@section Function @code{g_rc_source_library_search()}

@defun g_rc_source_library_search path
@end defun

<<g_rc.c : g_rc_source_library_search()>>=
SCM
g_rc_source_library_search(SCM path)
{
  int ret;
  struct stat buf;
  DIR *top_ptr;
  struct dirent *dptr;
  char *string = gh_scm2newstr(path, NULL);
  char *fullpath;
  char *cwd, *temp;

  /* TODO: don't I have to check string if it's NULL here? */

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to source-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  top_ptr = opendir(string);

  if (top_ptr == NULL) {
    fprintf(stderr,
            "Invalid path [%s] passed to source-library-search\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  while((dptr = readdir(top_ptr))) {

    /* don't do . and .. and special case font */
    if ((strcmp(dptr->d_name, ".") != 0) && 
        (strcmp(dptr->d_name, "..") != 0) &&
        (strcmp(dptr->d_name, "font") != 0)) {

          fullpath=(char *)malloc(sizeof(char)*(strlen(string)+
                                                strlen(dptr->d_name)+2));
          sprintf(fullpath, "%s%c%s", string, PATH_SEPARATER_CHAR, 
		  dptr->d_name);
          stat(fullpath, &buf);
          if (S_ISDIR(buf.st_mode)) { 
            if (s_slib_uniq(fullpath)) {

#ifdef __MINGW32__
              if (fullpath[1] == ':' &&
                  (fullpath[2] == PATH_SEPARATER_CHAR ||
                   fullpath[2] == OTHER_PATH_SEPARATER_CHAR)) {
#else
              if (fullpath[0] == PATH_SEPARATER_CHAR) {
#endif
                s_slib_add_entry(fullpath);
#if DEBUG
                printf("absolute: %s\n", fullpath);
#endif
              } else {
                cwd = getcwd(NULL, 1024);
#ifdef __MINGW32__
		u_basic_strip_trailing(cwd, PATH_SEPARATER_CHAR);
#endif
                temp = u_basic_strdup_multiple(cwd, 
                                               PATH_SEPARATER_STRING, 
					       fullpath, NULL);
#if DEBUG
                printf("relative: %s\n", temp);
#endif
                s_slib_add_entry(temp);
                free(temp);
                free(cwd);
              }
            } 
          }
          free(fullpath);
        }
  }       

  if (string) {
    free(string);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_source_library_search



@section Function @code{g_rc_world_size()}

@defun g_rc_world_size width height border
@end defun

<<g_rc.c : g_rc_world_size()>>=
SCM
g_rc_world_size(SCM width, SCM height, SCM border)
{
  int i_width, i_height, i_border;
  int init_right, init_bottom;

  /* yes this is legit, we are casing the resulting double to an int */
  i_width  = (int) (gh_scm2double(width ) * MILS_PER_INCH);
  i_height = (int) (gh_scm2double(height) * MILS_PER_INCH);
  i_border = (int) (gh_scm2double(border) * MILS_PER_INCH);

  PAPERSIZEtoWORLD(i_width, i_height, i_border,
                   &init_right, &init_bottom);

#if DEBUG
  printf("%d %d\n", i_width, i_height);
  printf("%d %d\n", init_right, init_bottom);
#endif

  default_init_right  = init_right;
  default_init_bottom = init_bottom;

  return SCM_BOOL_T;
}


@ %def g_rc_world_size


@section Function @code{g_rc_default_series_name()}

@defun g_rc_default_series_name name
@end defun

<<g_rc.c : g_rc_default_series_name()>>=
SCM
g_rc_default_series_name(SCM name)
{
  char *string = gh_scm2newstr(name, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "series-name"
            );
    return SCM_BOOL_F;
  }

  if (default_series_name) {
    free(default_series_name);
  }

  default_series_name = u_basic_strdup(string);

  free(string);
  return SCM_BOOL_T;
}


@ %def g_rc_default_series_name


@section Function @code{g_rc_untitled_name()}

@defun g_rc_untitled_name name
@end defun

<<g_rc.c : g_rc_untitled_name()>>=
SCM
g_rc_untitled_name(SCM name)
{
  char *string = gh_scm2newstr(name, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "untitled-name"
            );
    return SCM_BOOL_F;
  }

  if (default_untitled_name) {
    free(default_untitled_name);
  }

  default_untitled_name = u_basic_strdup(string);

  free(string);
  return SCM_BOOL_T;
}


@ %def g_rc_untitled_name



@section Function @code{g_rc_font_directory()}

@defun g_rc_font_directory path
@end defun

<<g_rc.c : g_rc_font_directory()>>=
SCM
g_rc_font_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "font-direcoty"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to font-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_font_directory) {
    free(default_font_directory);
  }
  default_font_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}

@
@ %def g_rc_font_directory


@section Function @code{g_rc_scheme_directory()}

@defun g_rc_scheme_directory path
@end defun

<<g_rc.c : g_rc_scheme_directory()>>=
SCM
g_rc_scheme_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "scheme-directory"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to scheme-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_scheme_directory) {
    free(default_scheme_directory);
  }
  default_scheme_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_scheme_directory


@section Function @code{g_rc_bitmap_directory()}

@defun g_rc_scheme_directory path
@end defun

<<g_rc.c : g_rc_bitmap_directory()>>=
SCM
g_rc_bitmap_directory(SCM path)
{
  int ret;
  struct stat buf;
  char *string = gh_scm2newstr(path, NULL);

  if (string == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "bitmap-directory"
            );
    return SCM_BOOL_F;
  }

  /* take care of any shell variables */
  string = expand_env_variables(string);

  ret = stat(string, &buf);

  /* invalid path? */
  if (ret < 0) {
    fprintf(stderr,
            "Invalid path [%s] passed to bitmap-directory\n",
            string);
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  /* not a directory? */
  if (!S_ISDIR(buf.st_mode)) {
    if (string) {
      free(string);
    }
    return SCM_BOOL_F;
  }

  if (default_bitmap_directory) {
    free(default_bitmap_directory);
  }
  default_bitmap_directory = u_basic_strdup(string);

  if (string) {
    free(string);
  }
  return SCM_BOOL_T;
}


@ %def g_rc_bitmap_directory


@section Function @code{g_rc_bus_ripper_symname()}

@defun g_rc_bus_ripper_symname mode
@end defun

<<g_rc.c : g_rc_bus_ripper_symname()>>=
SCM
g_rc_bus_ripper_symname(SCM scmsymname)
{
  char *symname = gh_scm2newstr(scmsymname, NULL);

  if (symname == NULL) {
    fprintf(stderr,
            "%s requires a string as a parameter\n",
            "bus-ripper-symname"
            );
    return SCM_BOOL_F;
  }

  if (default_bus_ripper_symname) {
    free(default_bus_ripper_symname);
  }
  default_bus_ripper_symname = u_basic_strdup(symname);

  if (symname) {
    free(symname);
  }

  return SCM_BOOL_T;
}


@ %def g_rc_bus_ripper_symname




@section Function @code{g_rc_reset_component_library()}

@defun g_rc_reset_component_library 
@end defun

<<g_rc.c : g_rc_reset_component_library()>>=
SCM
g_rc_reset_component_library(void)
{
  s_clib_cache_free();
  s_clib_free();
  s_clib_init();
  
  return SCM_BOOL_T;
}


@ %def g_rc_reset_component_library


@section Function @code{g_rc_reset_source_library()}

@defun g_rc_reset_source_library 
@end defun

<<g_rc.c : g_rc_reset_source_library()>>=
SCM
g_rc_reset_source_library(void)
{
  s_slib_free();
  s_slib_init();
  
  return SCM_BOOL_T;
}


@ %def g_rc_reset_source_library




